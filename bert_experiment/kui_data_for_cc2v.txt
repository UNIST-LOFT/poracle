0<ml>Chart-5<ml>Chart-5<ml>mmm Chart5b / source / org / jfree / data / xy / XYSeries . java 	 2017 - 03 - 20 <nl> ppp Chart5b_Patch5 / source / org / jfree / data / xy / XYSeries . java 	 2017 - 04 - 11 <nl> / / new item . . . otherwise it will be just - 1 and we should just <nl> / / append the value to the list . . . <nl> if ( this . autoSort ) { <nl> - this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> + this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <nl> } <nl> else { <nl> this . data . add ( new XYDataItem ( x , y ) ) ; <nl> 
0<ml>Time-11<ml>Time-11<ml>mmm Time11b / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java 	 2017 - 05 - 03 <nl> ppp Time11b_Patch182 / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java 	 2017 - 05 - 03 <nl> } <nl> if ( tailZone ! = null ) { <nl> - if ( tailZone . iStartRecurrence . getNameKey ( ) <nl> - . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { <nl> + if ( id . length ( ) = = 0 ) { <nl> if ( ZoneInfoCompiler . verbose ( ) ) { <nl> System . out . println ( " Fixing duplicate recurrent name key - " + <nl> tailZone . iStartRecurrence . getNameKey ( ) ) ; <nl> 
0<ml>Chart-21<ml>Chart-21<ml>mmm Chart21b / source / org / jfree / data / Range . java 	 2017 - 03 - 20 <nl> ppp Chart21b_Patch14 / source / org / jfree / data / Range . java 	 2017 - 04 - 11 <nl> } <nl> Range range = ( Range ) obj ; <nl> if ( ! ( this . lower = = range . lower ) ) { <nl> + if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) <nl> return false ; <nl> } <nl> if ( ! ( this . upper = = range . upper ) ) { <nl> 
1<ml>Math-3<ml>Math-3<ml>mmm Math3b / src / main / java / org / apache / commons / math3 / util / MathArrays . java 	 2017 - 05 - 09 <nl> ppp Math3b_Patch194 / src / main / java / org / apache / commons / math3 / util / MathArrays . java 	 2017 - 05 - 09 <nl> final double prodHighCur = prodHigh [ 0 ] ; <nl> + if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } <nl> double prodHighNext = prodHigh [ 1 ] ; <nl> double sHighPrev = prodHighCur + prodHighNext ; <nl> double sPrime = sHighPrev - prodHighNext ; <nl> 
0<ml>Math-73<ml>Math-73<ml>mmm Math73b / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java 	 2017 - 03 - 21 <nl> ppp Math73b_Patch55 / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java 	 2017 - 04 - 11 <nl> * @ throws IllegalArgumentException <nl> * / <nl> protected void verifySequence ( final double lower , final double initial , final double upper ) { <nl> - if ( ! isSequence ( lower , initial , upper ) ) { <nl> + if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { <nl> throw MathRuntimeException . createIllegalArgumentException ( <nl> " invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } " , <nl> lower , initial , upper ) ; <nl> 
1<ml>Math-89<ml>Math-89<ml>mmm Math89b / src / java / org / apache / commons / math / stat / Frequency . java 	 2017 - 05 - 09 <nl> ppp Math89b_Patch205 / src / java / org / apache / commons / math / stat / Frequency . java 	 2017 - 05 - 09 <nl> * / <nl> @ Deprecated <nl> public void addValue ( Object v ) { <nl> + if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } <nl> addValue ( ( Comparable < ? > ) v ) ; <nl> } <nl> 
0<ml>Math-24<ml>Math-24<ml>mmm Math24b / src / main / java / org / apache / commons / math3 / analysis / FunctionUtils . java 	 2017 - 05 - 03 <nl> ppp Math24b_Patch157 / src / main / java / org / apache / commons / math3 / analysis / FunctionUtils . java 	 2017 - 05 - 03 <nl> public double value ( double x ) { <nl> double r = f [ 0 ] . value ( x ) ; <nl> for ( int i = 1 ; i < f . length ; i + + ) { <nl> + if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { <nl> r + = f [ i ] . value ( x ) ; <nl> } <nl> + } <nl> return r ; <nl> } <nl> } ; <nl> 
0<ml>Math-105<ml>Math-105<ml>mmm Math105b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java 	 2017 - 03 - 21 <nl> ppp Math105b_Patch79 / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java 	 2017 - 04 - 11 <nl> public void addData ( double x , double y ) { <nl> if ( n = = 0 ) { <nl> xbar = x ; <nl> + if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) <nl> ybar = y ; <nl> } else { <nl> double dx = x - xbar ; <nl> 
0<ml>Time-4<ml>Time-4<ml>mmm Time4b / src / main / java / org / joda / time / field / ZeroIsMaxDateTimeField . java 	 2017 - 03 - 21 <nl> ppp Time4b_Patch80 / src / main / java / org / joda / time / field / ZeroIsMaxDateTimeField . java 	 2017 - 04 - 11 <nl> * @ return the minimum value of 1 <nl> * / <nl> public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { <nl> - return 1 ; <nl> + return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; <nl> } <nl> / * * <nl> 
0<ml>Math-40<ml>Math-40<ml>mmm Math40b / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2017 - 03 - 20 <nl> ppp Math40b_Patch38 / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2017 - 04 - 11 <nl> / / the guessed root is either not strictly inside the interval or it <nl> / / is a NaN ( which occurs when some sampling points share the same y ) <nl> / / we try again with a lower interpolation order <nl> - if ( signChangeIndex - start > = end - signChangeIndex ) { <nl> - / / we have more points before the sign change , drop the lowest point <nl> + if ( true ) { <nl> + + start ; <nl> } else { <nl> - / / we have more points after sign change , drop the highest point <nl> - - end ; <nl> } <nl> - <nl> / / we need to do one more attempt <nl> nextX = Double . NaN ; <nl> 
0<ml>Math-22<ml>Math-22<ml>mmm Math22b / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java 	 2017 - 08 - 23 <nl> ppp Math22b_PatchHDRepair3 / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java 	 2017 - 08 - 23 <nl> / * * { @ inheritDoc } * / <nl> public boolean isSupportLowerBoundInclusive ( ) { <nl> - return true ; <nl> + return false ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> 
0<ml>Chart-13<ml>Chart-13<ml>mmm Chart13b / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 03 - 20 <nl> ppp Chart13b_Patch9 / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 04 - 11 <nl> heightRange3 ) ; <nl> Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> w [ 3 ] = size . width ; <nl> + this . leftBlock = null ; <nl> h [ 3 ] = size . height ; <nl> } <nl> 
0<ml>Math-40<ml>Math-40<ml>mmm Math40b / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2017 - 05 - 03 <nl> ppp Math40b_Patch161 / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2017 - 05 - 03 <nl> / / the guessed root is either not strictly inside the interval or it <nl> / / is a NaN ( which occurs when some sampling points share the same y ) <nl> / / we try again with a lower interpolation order <nl> - if ( signChangeIndex - start > = end - signChangeIndex ) { <nl> + if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { <nl> / / we have more points before the sign change , drop the lowest point <nl> + + start ; <nl> } else { <nl> 
0<ml>Chart-26<ml>Chart-26<ml>mmm Chart26b / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 03 - 20 <nl> ppp Chart26b_Patch18 / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 04 - 11 <nl> / / if the incoming state is null , no information will be passed <nl> / / back to the caller - but we create a temporary state to record <nl> / / the plot area , since that is used later by the axes <nl> + if ( true ) <nl> + return ; <nl> state = new PlotRenderingInfo ( null ) ; <nl> } <nl> state . setPlotArea ( area ) ; <nl> 
0<ml>Math-105<ml>Math-105<ml>mmm Math105b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java 	 2017 - 05 - 03 <nl> ppp Math105b_Patch177 / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java 	 2017 - 05 - 03 <nl> public void addData ( double x , double y ) { <nl> if ( n = = 0 ) { <nl> xbar = x ; <nl> + if ( y < = x ) { <nl> ybar = y ; <nl> + } <nl> } else { <nl> double dx = x - xbar ; <nl> double dy = y - ybar ; <nl> 
0<ml>Math-28<ml>Math-28<ml>mmm Math28b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 05 - 09 <nl> ppp Math28b_Patch198 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 05 - 09 <nl> if ( minRatioPositions . size ( ) = = 0 ) { <nl> return null ; <nl> - } else if ( minRatioPositions . size ( ) > 1 ) { <nl> + } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { <nl> / / there ' s a degeneracy as indicated by a tie in the minimum ratio test <nl> / / 1 . check if there ' s an artificial variable that can be forced out of the basis <nl> 
1<ml>Math-99<ml>Math-99<ml>mmm Math99b / src / java / org / apache / commons / math / util / MathUtils . java 	 2017 - 05 - 09 <nl> ppp Math99b_Patch209 / src / java / org / apache / commons / math / util / MathUtils . java 	 2017 - 05 - 09 <nl> int u = p ; <nl> int v = q ; <nl> if ( ( u = = 0 ) | | ( v = = 0 ) ) { <nl> + if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } <nl> + if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } <nl> return ( Math . abs ( u ) + Math . abs ( v ) ) ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> return 0 ; <nl> } <nl> int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; <nl> + if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } <nl> return lcm ; <nl> } <nl> 
0<ml>Math-80<ml>Math-80<ml>mmm Math80b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 03 - 21 <nl> ppp Math80b_Patch59 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 04 - 11 <nl> / / flip array <nl> int j = 4 * n - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> - work [ i + k ] = work [ j - k ] ; <nl> - work [ j - k ] = tmp ; <nl> - } <nl> j - = 4 ; <nl> } <nl> return true ; <nl> 
0<ml>Lang-46<ml>Lang-46<ml>mmm Lang46b / src / java / org / apache / commons / lang / StringEscapeUtils . java 	 2017 - 03 - 20 <nl> ppp Lang46b_Patch22 / src / java / org / apache / commons / lang / StringEscapeUtils . java 	 2017 - 04 - 11 <nl> case ' \ \ ' : <nl> out . write ( ' \ \ ' ) ; <nl> out . write ( ' \ \ ' ) ; <nl> + if ( escapeSingleQuote ) <nl> break ; <nl> case ' / ' : <nl> out . write ( ' \ \ ' ) ; <nl> 
0<ml>Math-95<ml>Math-95<ml>mmm Math95b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2017 - 03 - 21 <nl> ppp Math95b_Patch75 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2017 - 04 - 11 <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> - return ret ; <nl> + return numeratorDegreesOfFreedom ; <nl> } <nl> / * * <nl> 
0<ml>Math-81<ml>Math-81<ml>mmm Math81b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 03 - 21 <nl> ppp Math81b_Patch63 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 04 - 11 <nl> } else if ( dMin = = dN2 ) { <nl> / / case 5 . <nl> + if ( true ) <nl> + return ; <nl> tType = - 5 ; <nl> double s = 0 . 25 * dMin ; <nl> 
0<ml>Math-32<ml>Math-32<ml>mmm Math32b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java 	 2017 - 03 - 20 <nl> ppp Math32b_Patch34 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java 	 2017 - 04 - 11 <nl> if ( v . length = = 0 ) { <nl> final BSPTree < Euclidean2D > tree = getTree ( false ) ; <nl> - if ( ( Boolean ) tree . getAttribute ( ) ) { <nl> - / / the instance covers the whole space <nl> - setSize ( Double . POSITIVE_INFINITY ) ; <nl> - setBarycenter ( Vector2D . NaN ) ; <nl> + if ( false ) { <nl> + setSize ( java . lang . Double . POSITIVE_INFINITY ) ; <nl> + setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; <nl> } else { <nl> setSize ( 0 ) ; <nl> - setBarycenter ( new Vector2D ( 0 , 0 ) ) ; <nl> + setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; <nl> } <nl> + <nl> } else if ( v [ 0 ] [ 0 ] = = null ) { <nl> / / there is at least one open - loop : the polygon is infinite <nl> setSize ( Double . POSITIVE_INFINITY ) ; <nl> 
0<ml>Math-81<ml>Math-81<ml>mmm Math81b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 03 - 21 <nl> ppp Math81b_Patch62 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 04 - 11 <nl> int np ; <nl> if ( dMin = = dN ) { <nl> gam = dN ; <nl> - a2 = 0 . 0 ; <nl> if ( work [ nn - 5 ] > work [ nn - 7 ] ) { <nl> return ; <nl> } <nl> 
0<ml>Math-88<ml>Math-88<ml>mmm Math88b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 03 - 21 <nl> ppp Math88b_Patch74 / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 04 - 11 <nl> * @ param divisor value of the divisor <nl> * / <nl> protected void divideRow ( final int dividendRow , final double divisor ) { <nl> + if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) <nl> for ( int j = 0 ; j < getWidth ( ) ; j + + ) { <nl> tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; <nl> } <nl> 
0<ml>Lang-51<ml>Lang-51<ml>mmm Lang51b / src / java / org / apache / commons / lang / BooleanUtils . java 	 2017 - 03 - 20 <nl> ppp Lang51b_Patch23 / src / java / org / apache / commons / lang / BooleanUtils . java 	 2017 - 04 - 11 <nl> ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> } <nl> - if ( ch = = ' Y ' ) { <nl> + if ( str ! = null ) { <nl> return <nl> ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & <nl> ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; <nl> 
0<ml>Math-78<ml>Math-78<ml>mmm Math78b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 03 - 21 <nl> ppp Math78b_Patch58 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 04 - 11 <nl> / / Inverse quadratic interpolation gives a value <nl> / / in the wrong direction , or progress is slow . <nl> / / Fall back to bisection . <nl> + if ( - 1 < = delta ) <nl> delta = 0 . 5 * dx ; <nl> oldDelta = delta ; <nl> } else { <nl> 
0<ml>Math-97<ml>Math-97<ml>mmm Math97b / src / java / org / apache / commons / math / analysis / BrentSolver . java 	 2017 - 05 - 09 <nl> ppp Math97b_Patch208 / src / java / org / apache / commons / math / analysis / BrentSolver . java 	 2017 - 05 - 09 <nl> / / Verify bracketing <nl> double sign = yMin * yMax ; <nl> - if ( sign > = 0 ) { <nl> + if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) { <nl> + <nl> / / check if either value is close to a zero <nl> / / neither value is close to zero and min and max do not bracket root . <nl> throw new IllegalArgumentException <nl> 
0<ml>Math-88<ml>Math-88<ml>mmm Math88b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> ppp Math88b_Patch176 / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> if ( basicRow ! = null ) { <nl> for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { <nl> if ( tableau . getEntry ( basicRow , j ) = = 1 ) { <nl> + if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { <nl> coefficients [ i ] = 0 ; <nl> } <nl> } <nl> } <nl> } <nl> + } <nl> return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; <nl> } <nl> 
1<ml>Math-35<ml>Math-35<ml>mmm Math35b / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java 	 2017 - 05 - 09 <nl> ppp Math35b_Patch199 / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java 	 2017 - 05 - 09 <nl> * See the License for the specific language governing permissions and <nl> * limitations under the License . <nl> * / <nl> - package org . apache . commons . math3 . genetics ; <nl> + package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> final double elitismRate ) { <nl> super ( chromosomes , populationLimit ) ; <nl> this . elitismRate = elitismRate ; <nl> + if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } <nl> + if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } <nl> } <nl> / * * <nl> public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { <nl> super ( populationLimit ) ; <nl> this . elitismRate = elitismRate ; <nl> + if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } <nl> + if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } <nl> + <nl> + <nl> } <nl> / * * <nl> 
0<ml>Chart-7<ml>Chart-7<ml>mmm Chart7b / source / org / jfree / data / time / TimePeriodValues . java 	 2017 - 03 - 20 <nl> ppp Chart7b_Patch8 / source / org / jfree / data / time / TimePeriodValues . java 	 2017 - 04 - 11 <nl> * @ return The index . <nl> * / <nl> public int getMaxMiddleIndex ( ) { <nl> - return this . maxMiddleIndex ; <nl> + return this . maxEndIndex ; <nl> } <nl> / * * <nl> 
0<ml>Math-39<ml>Math-39<ml>mmm Math39b / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java 	 2017 - 05 - 03 <nl> ppp Math39b_Patch160 / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java 	 2017 - 05 - 03 <nl> ratio = y0 [ j ] / scale [ j ] ; <nl> yOnScale2 + = ratio * ratio ; <nl> ratio = yDot0 [ j ] / scale [ j ] ; <nl> + if ( ( scale . length ) ! = ( org . apache . commons . math . ode . nonstiff . AdaptiveStepsizeIntegrator . this . maxStep ) ) { <nl> yDotOnScale2 + = ratio * ratio ; <nl> } <nl> + } <nl> double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? <nl> 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ; <nl> 
0<ml>Chart-26<ml>Chart-26<ml>mmm Chart26b / source / org / jfree / chart / axis / AxisCollection . java 	 2017 - 03 - 20 <nl> ppp Chart26b_Patch19 / source / org / jfree / chart / axis / AxisCollection . java 	 2017 - 04 - 11 <nl> if ( edge = = null ) { <nl> throw new IllegalArgumentException ( " Null ' edge ' argument . " ) ; <nl> } <nl> + if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) <nl> if ( edge = = RectangleEdge . TOP ) { <nl> this . axesAtTop . add ( axis ) ; <nl> } <nl> 
0<ml>Time-4<ml>Time-4<ml>mmm Time4b / src / main / java / org / joda / time / field / ZeroIsMaxDateTimeField . java 	 2017 - 03 - 21 <nl> ppp Time4b_Patch81 / src / main / java / org / joda / time / field / ZeroIsMaxDateTimeField . java 	 2017 - 04 - 11 <nl> * @ return the maximum value <nl> * / <nl> public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { <nl> + if ( true ) <nl> + return 0 ; <nl> return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; <nl> } <nl> 
0<ml>Math-104<ml>Math-104<ml>mmm Math104b / src / java / org / apache / commons / math / special / Gamma . java 	 2017 - 03 - 21 <nl> ppp Math104b_Patch78 / src / java / org / apache / commons / math / special / Gamma . java 	 2017 - 04 - 11 <nl> ret = Double . NaN ; <nl> } else if ( x = = 0 . 0 ) { <nl> ret = 0 . 0 ; <nl> - } else if ( a > = 1 . 0 & & x > a ) { <nl> + } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { <nl> / / use regularizedGammaQ because it should converge faster in this <nl> / / case . <nl> ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ; <nl> 
1<ml>Math-85<ml>Math-85<ml>mmm Math85b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 05 - 09 <nl> ppp Math85b_Patch204 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 05 - 09 <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> - if ( fa * fb > = 0 . 0 ) { <nl> + if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { <nl> throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> 
1<ml>Math-73<ml>Math-73<ml>mmm Math73b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 03 - 21 <nl> ppp Math73b_Patch54 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 04 - 11 <nl> / / full Brent algorithm starting with provided initial guess <nl> - return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> - <nl> + return solve ( f , min , max ) ; <nl> } <nl> / * * <nl> 
1<ml>Math-4<ml>Math-4<ml>mmm Math4b / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java 	 2017 - 05 - 09 <nl> ppp Math4b_Patch195 / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java 	 2017 - 05 - 09 <nl> / / compute the intersection on infinite line <nl> Vector3D v1D = line . intersection ( subLine . line ) ; <nl> + if ( v1D = = null ) { return null ; } <nl> / / check location of point with respect to first sub - line <nl> Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; <nl> mmm Math4b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java 	 2017 - 05 - 09 <nl> ppp Math4b_Patch195 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java 	 2017 - 05 - 09 <nl> / / compute the intersection on infinite line <nl> Vector2D v2D = line1 . intersection ( line2 ) ; <nl> - <nl> + if ( v2D = = null ) { return null ; } <nl> / / check location of point with respect to first sub - line <nl> Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; <nl> 
0<ml>Chart-3<ml>Chart-3<ml>mmm Chart3b / source / org / jfree / data / time / TimeSeries . java 	 2017 - 03 - 20 <nl> ppp Chart3b_Patch4 / source / org / jfree / data / time / TimeSeries . java 	 2017 - 04 - 11 <nl> this . data . remove ( 0 ) ; <nl> removed = true ; <nl> } <nl> - if ( removed ) { <nl> + if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { <nl> findBoundsByIteration ( ) ; <nl> if ( notify ) { <nl> fireSeriesChanged ( ) ; <nl> 
0<ml>Time-12<ml>Time-12<ml>mmm Time12b / src / main / java / org / joda / time / LocalDateTime . java 	 2017 - 05 - 03 <nl> ppp Time12b_Patch183 / src / main / java / org / joda / time / LocalDateTime . java 	 2017 - 05 - 03 <nl> * / <nl> public boolean equals ( Object partial ) { <nl> / / override to perform faster <nl> - if ( this = = partial ) { <nl> + if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { <nl> return true ; <nl> } <nl> if ( partial instanceof LocalDateTime ) { <nl> 
0<ml>Chart-25<ml>Chart-25<ml>mmm Chart25b / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2017 - 03 - 20 <nl> ppp Chart25b_Patch15 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2017 - 04 - 11 <nl> Comparable rowKey , Comparable columnKey ) { <nl> MeanAndStandardDeviation item = new MeanAndStandardDeviation ( <nl> mean , standardDeviation ) ; <nl> - this . data . addObject ( item , rowKey , columnKey ) ; <nl> double m = 0 . 0 ; <nl> double sd = 0 . 0 ; <nl> if ( mean ! = null ) { <nl> 
0<ml>Math-50<ml>Math-50<ml>mmm Math50b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 08 - 23 <nl> ppp Math50b_PatchHDRepair5 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 08 - 23 <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + x0 = 0 . 5 * ( ( int ) x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> break ; <nl> 
0<ml>Math-58<ml>Math-58<ml>mmm Math58b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java 	 2017 - 03 - 20 <nl> ppp Math58b_Patch49 / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java 	 2017 - 04 - 11 <nl> } <nl> / / compute an improved estimate for lmPar <nl> + if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) <nl> lmPar = FastMath . max ( parl , lmPar + correction ) ; <nl> } <nl> 
0<ml>Math-57<ml>Math-57<ml>mmm Math57b / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPoint . java 	 2017 - 05 - 03 <nl> ppp Math57b_Patch167 / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPoint . java 	 2017 - 05 - 03 <nl> return false ; <nl> } <nl> for ( int i = 0 ; i < point . length ; i + + ) { <nl> + if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { <nl> if ( point [ i ] ! = otherPoint [ i ] ) { <nl> return false ; <nl> } <nl> } <nl> + } <nl> return true ; <nl> } <nl> 
1<ml>Chart-14<ml>Chart-14<ml>mmm Chart14b / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 05 - 09 <nl> ppp Chart14b_Patch188 / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 05 - 09 <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> + if ( markers = = null ) { return false ; } <nl> boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> + if ( markers = = null ) { return false ; } <nl> boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> mmm Chart14b / source / org / jfree / chart / plot / XYPlot . java 	 2017 - 05 - 09 <nl> ppp Chart14b_Patch188 / source / org / jfree / chart / plot / XYPlot . java 	 2017 - 05 - 09 <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> + if ( markers = = null ) { return false ; } <nl> boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> + if ( markers = = null ) { return false ; } <nl> boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> 
0<ml>Math-78<ml>Math-78<ml>mmm Math78b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 05 - 03 <nl> ppp Math78b_Patch171 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 05 - 03 <nl> / / the equality test ( x0 = = x2 ) is intentional , <nl> / / it is part of the original Brent ' s method , <nl> / / it should NOT be replaced by proximity test <nl> - if ( x0 = = x2 ) { <nl> + if ( ( ( 1 < x2 ) & & ( ! ( y0 < = i ) ) ) | | ( x0 = = x2 ) ) { <nl> / / Linear interpolation . <nl> p = dx * r3 ; <nl> p1 = 1 . 0 - r3 ; <nl> 
0<ml>Lang-53<ml>Lang-53<ml>mmm Lang53b / src / java / org / apache / commons / lang / time / DateUtils . java 	 2017 - 03 - 20 <nl> ppp Lang53b_Patch24 / src / java / org / apache / commons / lang / time / DateUtils . java 	 2017 - 04 - 11 <nl> / / reset time <nl> if ( date . getTime ( ) ! = time ) { <nl> date . setTime ( time ) ; <nl> + if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) <nl> val . setTime ( date ) ; <nl> } <nl> / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - <nl> 
0<ml>Math-87<ml>Math-87<ml>mmm Math87b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 03 - 21 <nl> ppp Math87b_Patch73 / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 04 - 11 <nl> / / x - <nl> if ( ! restrictToNonNegative ) { <nl> + if ( ( 1 ) ! = ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) ) <nl> matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = <nl> getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; <nl> } <nl> 
0<ml>Math-82<ml>Math-82<ml>mmm Math82b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 03 - 21 <nl> ppp Math82b_Patch65 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 04 - 11 <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> - minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> } <nl> 
0<ml>Math-28<ml>Math-28<ml>mmm Math28b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 03 - 20 <nl> ppp Math28b_Patch32 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 04 - 11 <nl> int column = i + tableau . getArtificialVariableOffset ( ) ; <nl> final double entry = tableau . getEntry ( row , column ) ; <nl> if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { <nl> - return row ; <nl> } <nl> } <nl> } <nl> 
1<ml>Math-50<ml>Math-50<ml>mmm Math50b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 03 - 20 <nl> ppp Math50b_Patch45 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 04 - 11 <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> break ; <nl> 
0<ml>Math-85<ml>Math-85<ml>mmm Math85b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 08 - 23 <nl> ppp Math85b_PatchHDRepair9 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 08 - 23 <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> - if ( fa * fb > = 0 . 0 ) { <nl> + if ( fa / fb > = 0 . 0 ) { <nl> throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> 
0<ml>Time-14<ml>Time-14<ml>mmm Time14b / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java 	 2017 - 05 - 03 <nl> ppp Time14b_Patch184 / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java 	 2017 - 05 - 03 <nl> return values ; <nl> } <nl> / / month is largest field and being added to , such as month - day <nl> - if ( DateTimeUtils . isContiguous ( partial ) ) { <nl> + if ( ( ! ( ( ( fieldIndex ) ! = ( 1 ) ) & & ( valueToAdd < = values . length ) ) ) | | ( valueToAdd < - 1 ) ) { <nl> long instant = 0L ; <nl> for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { <nl> instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ; <nl> 
0<ml>Chart-15<ml>Chart-15<ml>mmm Chart15b / source / org / jfree / chart / JFreeChart . java 	 2017 - 03 - 20 <nl> ppp Chart15b_Patch12 / source / org / jfree / chart / JFreeChart . java 	 2017 - 04 - 11 <nl> if ( info ! = null ) { <nl> plotInfo = info . getPlotInfo ( ) ; <nl> } <nl> - this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; <nl> + fireChartChanged ( ) ; <nl> g2 . setClip ( savedClip ) ; <nl> 
0<ml>Lang-35<ml>Lang-35<ml>mmm Lang35b / src / main / java / org / apache / commons / lang3 / ArrayUtils . java 	 2017 - 05 - 09 <nl> ppp Lang35b_Patch192 / src / main / java / org / apache / commons / lang3 / ArrayUtils . java 	 2017 - 05 - 09 <nl> @ SuppressWarnings ( " unchecked " ) / / type must be T <nl> T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; <nl> newArray [ newArray . length - 1 ] = element ; <nl> + if ( element = = null ) { throw new IllegalArgumentException ( ) ; } <nl> return newArray ; <nl> } <nl> } else if ( element ! = null ) { <nl> clss = element . getClass ( ) ; <nl> } else { <nl> + if ( element = = null ) { throw new IllegalArgumentException ( ) ; } <nl> return ( T [ ] ) new Object [ ] { null } ; <nl> } <nl> @ SuppressWarnings ( " unchecked " ) / / the add method creates an array of type clss , which is type T <nl> 
0<ml>Math-71<ml>Math-71<ml>mmm Math71b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 03 - 20 <nl> ppp Math71b_Patch53 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 04 - 11 <nl> / / Compute new X1 , Y1 <nl> if ( Math . abs ( delta ) > tolerance ) { <nl> x1 = x1 + delta ; <nl> - } else if ( dx > 0 . 0 ) { <nl> + } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { <nl> x1 = x1 + 0 . 5 * tolerance ; <nl> } else if ( dx < = 0 . 0 ) { <nl> x1 = x1 - 0 . 5 * tolerance ; <nl> 
1<ml>Math-82<ml>Math-82<ml>mmm Math82b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 05 - 09 <nl> ppp Math82b_Patch203 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 05 - 09 <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { <nl> final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; <nl> final double entry = tableau . getEntry ( i , col ) ; <nl> - if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { <nl> + if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { <nl> final double ratio = rhs / entry ; <nl> if ( ratio < minRatio ) { <nl> minRatio = ratio ; <nl> minRatioPos = i ; <nl> } <nl> } <nl> + <nl> } <nl> return minRatioPos ; <nl> } <nl> 
0<ml>Math-2<ml>Math-2<ml>mmm Math2b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2017 - 03 - 20 <nl> ppp Math2b_Patch28 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2017 - 04 - 11 <nl> } <nl> k = 1 . 0 / k ; <nl> tmp = mu + k * sigma ; <nl> - if ( tmp < upper ) { <nl> - upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> - } <nl> } <nl> return solveInverseCumulativeProbability ( p , lower , upper ) ; <nl> 
0<ml>Chart-17<ml>Chart-17<ml>mmm Chart17b / source / org / jfree / data / time / TimeSeries . java 	 2017 - 05 - 03 <nl> ppp Chart17b_Patch90 / source / org / jfree / data / time / TimeSeries . java 	 2017 - 05 - 03 <nl> throw new IllegalArgumentException ( " Requires start > = 0 . " ) ; <nl> } <nl> if ( end < start ) { <nl> + if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { <nl> throw new IllegalArgumentException ( " Requires start < = end . " ) ; <nl> } <nl> + } <nl> TimeSeries copy = ( TimeSeries ) super . clone ( ) ; <nl> copy . data = new java . util . ArrayList ( ) ; <nl> 
0<ml>Math-84<ml>Math-84<ml>mmm Math84b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2017 - 03 - 21 <nl> ppp Math84b_Patch69 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2017 - 04 - 11 <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> + if ( true ) <nl> + return ; <nl> if ( comparator . compare ( contracted , best ) < 0 ) { <nl> / / accept the contracted simplex <nl> 
0<ml>Math-84<ml>Math-84<ml>mmm Math84b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2017 - 03 - 21 <nl> ppp Math84b_Patch68 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2017 - 04 - 11 <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( comparator . compare ( contracted , best ) < 0 ) { <nl> - / / accept the contracted simplex <nl> - <nl> - / / check convergence <nl> return ; <nl> - } <nl> } <nl> 
0<ml>Chart-21<ml>Chart-21<ml>mmm Chart21b / source / org / jfree / data / Range . java 	 2017 - 05 - 03 <nl> ppp Chart21b_Patch91 / source / org / jfree / data / Range . java 	 2017 - 05 - 03 <nl> } <nl> Range range = ( Range ) obj ; <nl> if ( ! ( this . lower = = range . lower ) ) { <nl> + if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { <nl> return false ; <nl> } <nl> + } <nl> if ( ! ( this . upper = = range . upper ) ) { <nl> return false ; <nl> } <nl> 
1<ml>Math-5<ml>Math-5<ml>mmm Math5b / src / main / java / org / apache / commons / math3 / complex / Complex . java 	 2017 - 03 - 20 <nl> ppp Math5b_Patch29 / src / main / java / org / apache / commons / math3 / complex / Complex . java 	 2017 - 04 - 11 <nl> } <nl> if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { <nl> - return NaN ; <nl> + return org . apache . commons . math3 . complex . Complex . INF ; <nl> } <nl> if ( isInfinite ) { <nl> 
0<ml>Lang-44<ml>Lang-44<ml>mmm Lang44b / src / java / org / apache / commons / lang / NumberUtils . java 	 2017 - 05 - 03 <nl> ppp Lang44b_Patch150 / src / java / org / apache / commons / lang / NumberUtils . java 	 2017 - 05 - 03 <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> - if ( dec = = null <nl> - & & exp = = null <nl> - & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> + if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> } catch ( NumberFormatException nfe ) { <nl> 
0<ml>Math-81<ml>Math-81<ml>mmm Math81b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 05 - 09 <nl> ppp Math81b_Patch202 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 05 - 09 <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> / / approximate contribution to norm squared from i < nn - 2 . <nl> - if ( end - start > 2 ) { <nl> + if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { <nl> + <nl> b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> a2 = a2 + b2 ; <nl> for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <nl> 
0<ml>Lang-39<ml>Lang-39<ml>mmm Lang39b / src / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp Lang39b_Patch193 / src / java / org / apache / commons / lang3 / StringUtils . java <nl> if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | <nl> searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) <nl> { <nl> + if ( replaceIndex = = 0 . 0 ) { return " cbc " ; } <nl> continue ; <nl> } <nl> tempIndex = text . indexOf ( searchList [ i ] ) ; <nl> 
0<ml>Chart-1<ml>Chart-1<ml>mmm Chart1b / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2017 - 04 - 11 <nl> ppp Chart1b_Patch2 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2017 - 04 - 10 <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> - return result ; <nl> - } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { <nl> for ( int i = 0 ; i < seriesCount ; i + + ) { <nl> Only in Chart1b_Patch2 / source / org / jfree / chart / renderer / category : AbstractCategoryItemRenderer . java . orig <nl> 
0<ml>Time-16<ml>Time-16<ml>mmm Time16b / src / main / java / org / joda / time / format / DateTimeParserBucket . java 	 2017 - 05 - 03 <nl> ppp Time16b_Patch185 / src / main / java / org / joda / time / format / DateTimeParserBucket . java 	 2017 - 05 - 03 <nl> DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; <nl> if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { <nl> saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; <nl> + if ( resetFields ) { <nl> return computeMillis ( resetFields , text ) ; <nl> } <nl> } <nl> + } <nl> long millis = iMillis ; <nl> try { <nl> 
0<ml>Chart-15<ml>Chart-15<ml>mmm Chart15b / source / org / jfree / chart / plot / PiePlot3D . java 	 2017 - 03 - 20 <nl> ppp Chart15b_Patch13 / source / org / jfree / chart / plot / PiePlot3D . java 	 2017 - 04 - 11 <nl> PlotRenderingInfo info ) { <nl> / / adjust for insets . . . <nl> + if ( true ) <nl> + return ; <nl> RectangleInsets insets = getInsets ( ) ; <nl> insets . trim ( plotArea ) ; <nl> 
0<ml>Math-82<ml>Math-82<ml>mmm Math82b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 08 - 23 <nl> ppp Math82b_PatchHDRepair8 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 08 - 23 <nl> final double entry = tableau . getEntry ( i , col ) ; <nl> if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { <nl> final double ratio = rhs / entry ; <nl> - if ( ratio < minRatio ) { <nl> + if ( ratio < = minRatio ) { <nl> minRatio = ratio ; <nl> minRatioPos = i ; <nl> } <nl> 
0<ml>Math-28<ml>Math-28<ml>mmm Math28b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 03 - 20 <nl> ppp Math28b_Patch33 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 04 - 11 <nl> for ( Integer row : minRatioPositions ) { <nl> int i = tableau . getNumObjectiveFunctions ( ) ; <nl> for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { <nl> - if ( row = = tableau . getBasicRow ( i ) ) { <nl> + if ( true ) { <nl> if ( i < minIndex ) { <nl> minIndex = i ; <nl> minRow = row ; <nl> 
0<ml>Math-81<ml>Math-81<ml>mmm Math81b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 03 - 21 <nl> ppp Math81b_Patch64 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 04 - 11 <nl> / / approximate contribution to norm squared from i < nn - 2 . <nl> if ( end - start > 2 ) { <nl> + if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) <nl> b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> a2 = a2 + b2 ; <nl> for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <nl> 
0<ml>Math-85<ml>Math-85<ml>mmm Math85b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 03 - 21 <nl> ppp Math85b_Patch72 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 04 - 11 <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> + if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) <nl> if ( fa * fb > = 0 . 0 ) { <nl> throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> 
1<ml>Lang-55<ml>Lang-55<ml>mmm Lang55b / src / java / org / apache / commons / lang / time / StopWatch . java 	 2017 - 03 - 20 <nl> ppp Lang55b_Patch25 / src / java / org / apache / commons / lang / time / StopWatch . java 	 2017 - 04 - 11 <nl> if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { <nl> throw new IllegalStateException ( " Stopwatch is not running . " ) ; <nl> } <nl> + if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) <nl> stopTime = System . currentTimeMillis ( ) ; <nl> this . runningState = STATE_STOPPED ; <nl> } <nl> 
0<ml>Math-50<ml>Math-50<ml>mmm Math50b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 05 - 03 <nl> ppp Math50b_Patch166 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 05 - 03 <nl> / / are satisfied with the current approximation . <nl> if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , <nl> atol ) ) { <nl> + if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { <nl> switch ( allowed ) { <nl> case ANY_SIDE : <nl> return x1 ; <nl> } <nl> } <nl> } <nl> + } <nl> / * * < em > Secant < / em > - based root - finding methods . * / <nl> protected enum Method { <nl> 
1<ml>Chart-19<ml>Chart-19<ml>mmm Chart19b / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 05 - 09 <nl> ppp Chart19b_Patch189 / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 05 - 09 <nl> * @ since 1 . 0 . 3 <nl> * / <nl> public int getDomainAxisIndex ( CategoryAxis axis ) { <nl> + if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } <nl> return this . domainAxes . indexOf ( axis ) ; <nl> } <nl> result = p . getRangeAxisIndex ( axis ) ; <nl> } <nl> } <nl> + if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } <nl> return result ; <nl> } <nl> 
1<ml>Time-19<ml>Time-19<ml>mmm Time19b / src / main / java / org / joda / time / DateTimeZone . java 	 2017 - 08 - 23 <nl> ppp Time19b_PatchHDRepair10 / src / main / java / org / joda / time / DateTimeZone . java 	 2017 - 08 - 23 <nl> return offsetLocal ; <nl> } <nl> } <nl> - } else if ( offsetLocal > 0 ) { <nl> + } else if ( offsetLocal > = 0 ) { <nl> long prev = previousTransition ( instantAdjusted ) ; <nl> if ( prev < instantAdjusted ) { <nl> int offsetPrev = getOffset ( prev ) ; <nl> 
0<ml>Math-57<ml>Math-57<ml>mmm Math57b / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPoint . java 	 2017 - 03 - 20 <nl> ppp Math57b_Patch48 / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPoint . java 	 2017 - 04 - 11 <nl> } <nl> for ( int i = 0 ; i < point . length ; i + + ) { <nl> if ( point [ i ] ! = otherPoint [ i ] ) { <nl> + if ( ( 1 ) ! = ( org . apache . commons . math . stat . clustering . EuclideanIntegerPoint . this . point . length ) ) <nl> return false ; <nl> } <nl> } <nl> 
1<ml>Math-34<ml>Math-34<ml>mmm Math34b / src / main / java / org / apache / commons / math3 / genetics / ListPopulation . java 	 2017 - 08 - 23 <nl> ppp Math34b_PatchHDRepair4 / src / main / java / org / apache / commons / math3 / genetics / ListPopulation . java 	 2017 - 08 - 23 <nl> * @ return chromosome iterator <nl> * / <nl> public Iterator < Chromosome > iterator ( ) { <nl> - return chromosomes . iterator ( ) ; <nl> + return getChromosomes ( ) . iterator ( ) ; <nl> } <nl> } <nl> 
0<ml>Math-8<ml>Math-8<ml>mmm Math8b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java 	 2017 - 03 - 20 <nl> ppp Math8b_Patch30 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java 	 2017 - 04 - 11 <nl> final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; <nl> - for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> - out [ i ] = sample ( ) ; <nl> - } <nl> return out ; <nl> 
0<ml>Math-82<ml>Math-82<ml>mmm Math82b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 03 - 21 <nl> ppp Math82b_Patch67 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2017 - 04 - 11 <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> + if ( ( 0 ) ! = ( minValue ) ) <nl> minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> 
1<ml>Lang-58<ml>Lang-58<ml>mmm Lang58b / src / java / org / apache / commons / lang / math / NumberUtils . java 	 2017 - 03 - 20 <nl> ppp Lang58b_Patch26 / src / java / org / apache / commons / lang / math / NumberUtils . java 	 2017 - 04 - 11 <nl> return createBigInteger ( numeric ) ; <nl> } <nl> + if ( - 1 < expPos ) <nl> throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> case ' f ' : <nl> case ' F ' : <nl> 
0<ml>Math-81<ml>Math-81<ml>mmm Math81b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 05 - 03 <nl> ppp Math81b_Patch173 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 05 - 03 <nl> break ; <nl> case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . <nl> - if ( dMin1 = = dN1 & & dMin2 = = dN2 ) { <nl> + if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . main ! = null ) { <nl> / / cases 7 and 8 . <nl> tType = - 7 ; <nl> 
0<ml>Math-49<ml>Math-49<ml>mmm Math49b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java 	 2017 - 05 - 03 <nl> ppp Math49b_Patch165 / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java 	 2017 - 05 - 03 <nl> if ( ! isDefaultValue ( value ) ) { <nl> entries . put ( index , value ) ; <nl> } else if ( entries . containsKey ( index ) ) { <nl> + if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { <nl> entries . remove ( index ) ; <nl> } <nl> } <nl> + } <nl> / * * { @ inheritDoc } * / <nl> @ Override <nl> 
1<ml>Math-70<ml>Math-70<ml>mmm Math70b / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolver . java 	 2017 - 08 - 23 <nl> ppp Math70b_PatchHDRepair7 / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolver . java 	 2017 - 08 - 23 <nl> / * * { @ inheritDoc } * / <nl> public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) <nl> throws MaxIterationsExceededException , FunctionEvaluationException { <nl> - return solve ( min , max ) ; <nl> + return solve ( f , min , max ) ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> 
0<ml>Time-11<ml>Time-11<ml>mmm Time11b / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java 	 2017 - 03 - 21 <nl> ppp Time11b_Patch84 / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java 	 2017 - 04 - 11 <nl> millis = next . getMillis ( ) ; <nl> saveMillis = next . getSaveMillis ( ) ; <nl> if ( tailZone = = null & & i = = ruleSetCount - 1 ) { <nl> + if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) <nl> tailZone = rs . buildTailZone ( id ) ; <nl> / / If tailZone is not null , don ' t break out of main loop until <nl> / / at least one more transition is calculated . This ensures a <nl> 
0<ml>Chart-25<ml>Chart-25<ml>mmm Chart25b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2017 - 05 - 03 <nl> ppp Chart25b_Patch92 / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2017 - 05 - 03 <nl> StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; <nl> PlotOrientation orientation = plot . getOrientation ( ) ; <nl> + if ( 0 = = 1 ) { <nl> if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> rangeAxis , statData , row , column ) ; <nl> statData , row , column ) ; <nl> } <nl> } <nl> + } <nl> / * * <nl> * Draws an item for a plot with a horizontal orientation . <nl> 
0<ml>Lang-58<ml>Lang-58<ml>mmm Lang58b / src / java / org / apache / commons / lang / math / NumberUtils . java 	 2017 - 05 - 03 <nl> ppp Lang58b_Patch153 / src / java / org / apache / commons / lang / math / NumberUtils . java 	 2017 - 05 - 03 <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> - if ( dec = = null <nl> - & & exp = = null <nl> - & & isDigits ( numeric . substring ( 1 ) ) <nl> - & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { <nl> + if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> } catch ( NumberFormatException nfe ) { <nl> 
0<ml>Math-73<ml>Math-73<ml>mmm Math73b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 05 - 09 <nl> ppp Math73b_Patch201 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java 	 2017 - 05 - 09 <nl> } <nl> + if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } <nl> / / full Brent algorithm starting with provided initial guess <nl> return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> 
0<ml>Time-18<ml>Time-18<ml>mmm Time18b / src / main / java / org / joda / time / chrono / BasicChronology . java 	 2017 - 05 - 03 <nl> ppp Time18b_Patch186 / src / main / java / org / joda / time / chrono / BasicChronology . java 	 2017 - 05 - 03 <nl> long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { <nl> FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; <nl> FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; <nl> + if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { <nl> FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; <nl> + } <nl> return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; <nl> } <nl> 
0<ml>Chart-13<ml>Chart-13<ml>mmm Chart13b / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 03 - 20 <nl> ppp Chart13b_Patch10 / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 04 - 11 <nl> h [ 1 ] = size . height ; <nl> } <nl> h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; <nl> - if ( this . leftBlock ! = null ) { <nl> - RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> - new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> - LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - LengthConstraintType . FIXED ) ; <nl> - Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> - } <nl> h [ 3 ] = h [ 2 ] ; <nl> if ( this . rightBlock ! = null ) { <nl> RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , <nl> 
0<ml>Math-69<ml>Math-69<ml>mmm Math69b / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java 	 2017 - 05 - 03 <nl> ppp Math69b_Patch169 / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java 	 2017 - 05 - 03 <nl> for ( int j = 0 ; j < i ; j + + ) { <nl> double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; <nl> outMatrix . setEntry ( i , j , corr ) ; <nl> + if ( 2 < nVars ) { <nl> outMatrix . setEntry ( j , i , corr ) ; <nl> } <nl> + } <nl> outMatrix . setEntry ( i , i , 1d ) ; <nl> } <nl> return outMatrix ; <nl> 
0<ml>Chart-1<ml>Chart-1<ml>mmm Chart1b / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2017 - 04 - 11 <nl> ppp Chart1b_Patch1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2017 - 04 - 11 <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> - return result ; <nl> - } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { <nl> for ( int i = 0 ; i < seriesCount ; i + + ) { <nl> 
1<ml>Math-53<ml>Math-53<ml>mmm Math53b / src / main / java / org / apache / commons / math / complex / Complex . java 	 2017 - 03 - 20 <nl> ppp Math53b_Patch47 / src / main / java / org / apache / commons / math / complex / Complex . java 	 2017 - 04 - 11 <nl> public Complex add ( Complex rhs ) <nl> throws NullArgumentException { <nl> MathUtils . checkNotNull ( rhs ) ; <nl> + if ( ( isNaN ) | | ( rhs . isNaN ) ) { <nl> + return org . apache . commons . math . complex . Complex . NaN ; <nl> + } <nl> return createComplex ( real + rhs . getReal ( ) , <nl> imaginary + rhs . getImaginary ( ) ) ; <nl> } <nl> 
1<ml>Math-50<ml>Math-50<ml>mmm Math50b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 03 - 20 <nl> ppp Math50b_Patch46 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2017 - 04 - 11 <nl> break ; <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> + if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) <nl> if ( x = = x1 ) { <nl> x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> 
0<ml>Time-19<ml>Time-19<ml>mmm Time19b / src / main / java / org / joda / time / DateTimeZone . java 	 2017 - 05 - 03 <nl> ppp Time19b_Patch187 / src / main / java / org / joda / time / DateTimeZone . java 	 2017 - 05 - 03 <nl> return offsetLocal ; <nl> } <nl> } <nl> - } else if ( offsetLocal > 0 ) { <nl> + } else if ( org . joda . time . DateTimeZone . this . iID ! = null ) { <nl> long prev = previousTransition ( instantAdjusted ) ; <nl> if ( prev < instantAdjusted ) { <nl> int offsetPrev = getOffset ( prev ) ; <nl> 
0<ml>Chart-13<ml>Chart-13<ml>mmm Chart13b / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 05 - 01 <nl> ppp Chart13b_Patch11 / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 05 - 02 <nl> w [ 2 ] = size . width ; <nl> } <nl> h [ 3 ] = h [ 2 ] ; <nl> - if ( this . rightBlock ! = null ) { <nl> + if ( null ! = null ) { <nl> RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , <nl> new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , <nl> LengthConstraintType . RANGE , h [ 2 ] , null , <nl> 
0<ml>Math-58<ml>Math-58<ml>mmm Math58b / src / main / java / org / apache / commons / math / analysis / function / Gaussian . java 	 2017 - 05 - 03 <nl> ppp Math58b_Patch168 / src / main / java / org / apache / commons / math / analysis / function / Gaussian . java 	 2017 - 05 - 03 <nl> if ( param . length ! = 3 ) { <nl> throw new DimensionMismatchException ( param . length , 3 ) ; <nl> } <nl> + if ( ( param [ 2 ] ) = = 0 ) { <nl> if ( param [ 2 ] < = 0 ) { <nl> throw new NotStrictlyPositiveException ( param [ 2 ] ) ; <nl> } <nl> } <nl> } <nl> + } <nl> / * * <nl> * @ param xMinusMean { @ code x - mean } . <nl> 
1<ml>Lang-24<ml>Lang-24<ml>mmm Lang24b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java 	 2017 - 05 - 09 <nl> ppp Lang24b_Patch191 / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java 	 2017 - 05 - 09 <nl> } <nl> if ( chars [ i ] = = ' l ' <nl> | | chars [ i ] = = ' L ' ) { <nl> + if ( hasDecPoint = = true ) { return false ; } <nl> / / not allowing L with an exponent or decimal point <nl> return foundDigit & & ! hasExp ; <nl> } <nl> 
0<ml>Lang-53<ml>Lang-53<ml>mmm Lang53b / src / java / org / apache / commons / lang / time / DateUtils . java 	 2017 - 05 - 03 <nl> ppp Lang53b_Patch152 / src / java / org / apache / commons / lang / time / DateUtils . java 	 2017 - 05 - 03 <nl> / / reset time <nl> if ( date . getTime ( ) ! = time ) { <nl> date . setTime ( time ) ; <nl> + if ( org . apache . commons . lang . time . DateUtils . RANGE_WEEK_CENTER = = millisecs ) { <nl> val . setTime ( date ) ; <nl> } <nl> + } <nl> / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - <nl> boolean roundUp = false ; <nl> 
0<ml>Chart-26<ml>Chart-26<ml>mmm Chart26b / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 05 - 03 <nl> ppp Chart26b_Patch93 / source / org / jfree / chart / plot / CategoryPlot . java 	 2017 - 05 - 03 <nl> / / if the plot area is too small , just return . . . <nl> boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; <nl> boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; <nl> - if ( b1 | | b2 ) { <nl> + if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { <nl> return ; <nl> } <nl> 
0<ml>Math-53<ml>Math-53<ml>mmm Math53b / src / main / java / org / apache / commons / math / complex / Complex . java 	 2017 - 08 - 23 <nl> ppp Math53b_PatchHDRepair6 / src / main / java / org / apache / commons / math / complex / Complex . java 	 2017 - 08 - 23 <nl> public Complex add ( Complex rhs ) <nl> throws NullArgumentException { <nl> MathUtils . checkNotNull ( rhs ) ; <nl> - return createComplex ( real + rhs . getReal ( ) , <nl> + return createComplex ( real + rhs . getArgument ( ) , <nl> imaginary + rhs . getImaginary ( ) ) ; <nl> } <nl> 
0<ml>Math-80<ml>Math-80<ml>mmm Math80b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 05 - 03 <nl> ppp Math80b_Patch172 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2017 - 05 - 03 <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> for ( int k = 0 ; k < 4 ; k + = step ) { <nl> final double tmp = work [ i + k ] ; <nl> + if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { <nl> work [ i + k ] = work [ j - k ] ; <nl> + } <nl> work [ j - k ] = tmp ; <nl> } <nl> j - = 4 ; <nl> 
0<ml>Math-2<ml>Math-2<ml>mmm Math2b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2017 - 03 - 20 <nl> ppp Math2b_Patch27 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2017 - 04 - 11 <nl> k = 1 . 0 / k ; <nl> tmp = mu + k * sigma ; <nl> if ( tmp < upper ) { <nl> - upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> + tmp = mu + ( k * sigma ) ; <nl> } <nl> } <nl> 
0<ml>Chart-13<ml>Chart-13<ml>mmm Chart13b / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 05 - 03 <nl> ppp Chart13b_Patch89 / source / org / jfree / chart / block / BorderArrangement . java 	 2017 - 05 - 03 <nl> w [ 2 ] = size . width ; <nl> } <nl> h [ 3 ] = h [ 2 ] ; <nl> + if ( null ! = null ) { <nl> if ( this . rightBlock ! = null ) { <nl> RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , <nl> new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , <nl> Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> w [ 3 ] = size . width ; <nl> } <nl> + } <nl> h [ 4 ] = h [ 2 ] ; <nl> w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; <nl> RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; <nl> 
0<ml>Time-11<ml>Time-11<ml>mmm Time11b / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java 	 2017 - 03 - 21 <nl> ppp Time11b_Patch82 / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java 	 2017 - 04 - 11 <nl> if ( tailZone ! = null ) { <nl> if ( tailZone . iStartRecurrence . getNameKey ( ) <nl> . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { <nl> - if ( ZoneInfoCompiler . verbose ( ) ) { <nl> - System . out . println ( " Fixing duplicate recurrent name key - " + <nl> - tailZone . iStartRecurrence . getNameKey ( ) ) ; <nl> - } <nl> if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { <nl> tailZone = new DSTZone ( <nl> tailZone . getID ( ) , <nl> 
0<ml>Math-4<ml>Math-4<ml>mmm Math4b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java 	 2017 - 05 - 03 <nl> ppp Math4b_Patch155 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java 	 2017 - 05 - 03 <nl> public Vector2D intersection ( final Line other ) { <nl> final double d = sin * other . cos - other . sin * cos ; <nl> if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { <nl> + if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { <nl> return null ; <nl> } <nl> + } <nl> return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , <nl> ( sin * other . originOffset - other . sin * originOffset ) / d ) ; <nl> } <nl> 
1<ml>Math-93<ml>Math-93<ml>mmm Math93b / src / java / org / apache / commons / math / util / MathUtils . java 	 2017 - 05 - 09 <nl> ppp Math93b_Patch207 / src / java / org / apache / commons / math / util / MathUtils . java 	 2017 - 05 - 09 <nl> * @ version $ Revision $ $ Date $ <nl> * / <nl> public final class MathUtils { <nl> + private static long patch_method ( int n ) { <nl> + long result = 1 ; <nl> + for ( int i = 2 ; i < = n ; i + + ) { <nl> + result * = i ; <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> / * * Smallest positive number such that 1 - EPSILON is not numerically equal to 1 . * / <nl> public static final double EPSILON = 0x1 . 0p - 53 ; <nl> if ( n < 0 ) { <nl> throw new IllegalArgumentException ( " must have n > = 0 for n ! " ) ; <nl> } <nl> + if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } <nl> + <nl> return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; <nl> } <nl> 
1<ml>Math-5<ml>Math-5<ml>mmm Math5b / src / main / java / org / apache / commons / math3 / complex / Complex . java 	 2017 - 05 - 09 <nl> ppp Math5b_Patch196 / src / main / java / org / apache / commons / math3 / complex / Complex . java 	 2017 - 05 - 09 <nl> } <nl> if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { <nl> + if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } <nl> return NaN ; <nl> } <nl> 
0<ml>Time-4<ml>Time-4<ml>mmm Time4b / src / main / java / org / joda / time / Partial . java 	 2017 - 05 - 03 <nl> ppp Time4b_Patch180 / src / main / java / org / joda / time / Partial . java 	 2017 - 05 - 03 <nl> System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; <nl> System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; <nl> newTypes [ i ] = fieldType ; <nl> + if ( ( ( 20 ) - ( value + newTypes . length ) < value ) | | ( ( 2 ) ! = ( org . joda . time . Partial . this . iTypes . length ) ) ) { <nl> newValues [ i ] = value ; <nl> + } <nl> System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; <nl> System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; <nl> / / use public constructor to ensure full validation <nl> 
0<ml>Chart-25<ml>Chart-25<ml>mmm Chart25b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2017 - 03 - 20 <nl> ppp Chart25b_Patch16 / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2017 - 04 - 11 <nl> int pass ) { <nl> / / defensive check <nl> + if ( true ) <nl> + return ; <nl> if ( ! ( data instanceof StatisticalCategoryDataset ) ) { <nl> throw new IllegalArgumentException ( <nl> " Requires StatisticalCategoryDataset . " ) ; <nl> 
1<ml>Chart-5<ml>Chart-5<ml>mmm Chart5b / source / org / jfree / data / xy / XYSeries . java 	 2017 - 03 - 20 <nl> ppp Chart5b_Patch7 / source / org / jfree / data / xy / XYSeries . java 	 2017 - 04 - 11 <nl> / / Collections . binarySearch ( ) and tells us where to insert the <nl> / / new item . . . otherwise it will be just - 1 and we should just <nl> / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> + if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { <nl> this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> } <nl> else { <nl> 
0<ml>Math-33<ml>Math-33<ml>mmm Math33b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java 	 2017 - 03 - 20 <nl> ppp Math33b_Patch36 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java 	 2017 - 04 - 11 <nl> for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { <nl> final double entry = tableau . getEntry ( 0 , i ) ; <nl> if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { <nl> + if ( ( org . apache . commons . math3 . optimization . linear . SimplexTableau . NEGATIVE_VAR_COLUMN_LABEL . length ( ) ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) <nl> columnsToDrop . add ( i ) ; <nl> } <nl> } <nl> 
0<ml>Math-97<ml>Math-97<ml>mmm Math97b / src / java / org / apache / commons / math / analysis / BrentSolver . java 	 2017 - 03 - 21 <nl> ppp Math97b_Patch77 / src / java / org / apache / commons / math / analysis / BrentSolver . java 	 2017 - 04 - 11 <nl> if ( sign > = 0 ) { <nl> / / check if either value is close to a zero <nl> / / neither value is close to zero and min and max do not bracket root . <nl> + if ( min < = 1 ) <nl> throw new IllegalArgumentException <nl> ( " Function values at endpoints do not have different signs . " + <nl> " Endpoints : [ " + min + " , " + max + " ] " + <nl> 
0<ml>Math-33<ml>Math-33<ml>mmm Math33b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> ppp Math33b_Patch159 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { <nl> final double entry = tableau . getEntry ( 0 , i ) ; <nl> if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { <nl> + if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { <nl> columnsToDrop . add ( i ) ; <nl> } <nl> } <nl> + } <nl> / / non - basic artificial variables <nl> for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { <nl> 
0<ml>Lang-39<ml>Lang-39<ml>mmm Lang39b / src / java / org / apache / commons / lang3 / StringUtils . java 	 2017 - 03 - 20 <nl> ppp Lang39b_Patch20 / src / java / org / apache / commons / lang3 / StringUtils . java 	 2017 - 04 - 11 <nl> int increase = 0 ; <nl> / / count the replacement text elements that are larger than their corresponding text being replaced <nl> + if ( repeat ) <nl> for ( int i = 0 ; i < searchList . length ; i + + ) { <nl> int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> if ( greater > 0 ) { <nl> 
0<ml>Math-87<ml>Math-87<ml>mmm Math87b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> ppp Math87b_Patch175 / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> / / x - <nl> if ( ! restrictToNonNegative ) { <nl> + if ( ( 1 ) ! = ( constraints . size ( ) ) ) { <nl> matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = <nl> getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; <nl> } <nl> + } <nl> / / RHS <nl> matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ; <nl> 
0<ml>Math-42<ml>Math-42<ml>mmm Math42b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> ppp Math42b_Patch163 / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2017 - 05 - 03 <nl> for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { <nl> int col = i + getArtificialVariableOffset ( ) ; <nl> if ( getBasicRow ( col ) = = null ) { <nl> + if ( 1 < = org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { <nl> columnsToDrop . add ( col ) ; <nl> } <nl> } <nl> + } <nl> double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; <nl> for ( int i = 1 ; i < getHeight ( ) ; i + + ) { <nl> 
1<ml>Lang-57<ml>Lang-57<ml>mmm Lang57b / src / java / org / apache / commons / lang / LocaleUtils . java 	 2017 - 08 - 23 <nl> ppp Lang57b_PatchHDRepair1 / src / java / org / apache / commons / lang / LocaleUtils . java 	 2017 - 08 - 23 <nl> * @ return true if the locale is a known locale <nl> * / <nl> public static boolean isAvailableLocale ( Locale locale ) { <nl> - return cAvailableLocaleSet . contains ( locale ) ; <nl> + return availableLocaleList ( ) . contains ( locale ) ; <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
0<ml>Math-41<ml>Math-41<ml>mmm Math41b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java 	 2017 - 05 - 03 <nl> ppp Math41b_Patch162 / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java 	 2017 - 05 - 03 <nl> for ( int i = begin ; i < begin + length ; i + + ) { <nl> correction + = weights [ i ] * ( values [ i ] - xbarw ) ; <nl> } <nl> + if ( xbarw < length ) { <nl> return xbarw + ( correction / sumw ) ; <nl> } <nl> + } <nl> return Double . NaN ; <nl> } <nl> 
0<ml>Math-85<ml>Math-85<ml>mmm Math85b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 05 - 03 <nl> ppp Math85b_Patch174 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2017 - 05 - 03 <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> - if ( fa * fb > = 0 . 0 ) { <nl> + if ( maximumIterations = = initial ) { <nl> throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> 
0<ml>Math-28<ml>Math-28<ml>mmm Math28b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 05 - 03 <nl> ppp Math28b_Patch158 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2017 - 05 - 03 <nl> } <nl> } <nl> } <nl> + if ( minRatioPositions . isEmpty ( ) ) { <nl> return minRow ; <nl> } <nl> + } <nl> return minRatioPositions . get ( 0 ) ; <nl> } <nl> 
1<ml>Lang-44<ml>Lang-44<ml>mmm Lang44b / src / java / org / apache / commons / lang / NumberUtils . java 	 2017 - 03 - 20 <nl> ppp Lang44b_Patch21 / src / java / org / apache / commons / lang / NumberUtils . java 	 2017 - 04 - 11 <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> + if ( ( val . length ( ) ) ! = ( 1 ) ) <nl> if ( dec = = null <nl> & & exp = = null <nl> & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> 
0<ml>Math-95<ml>Math-95<ml>mmm Math95b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2017 - 03 - 21 <nl> ppp Math95b_Patch76 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2017 - 04 - 11 <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> + if ( true ) <nl> + return 0d ; <nl> return ret ; <nl> } <nl> 
0<ml>Math-40<ml>Math-40<ml>mmm Math40b / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2017 - 03 - 20 <nl> ppp Math40b_Patch37 / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2017 - 04 - 11 <nl> double targetY ; <nl> if ( agingA > = MAXIMAL_AGING ) { <nl> / / we keep updating the high bracket , try to compensate this <nl> + signChangeIndex + + ; <nl> targetY = - REDUCTION_FACTOR * yB ; <nl> } else if ( agingB > = MAXIMAL_AGING ) { <nl> / / we keep updating the low bracket , try to compensate this <nl> 
1<ml>Time-15<ml>Time-15<ml>mmm Time15b / src / main / java / org / joda / time / field / FieldUtils . java 	 2017 - 05 - 09 <nl> ppp Time15b_Patch210 / src / main / java / org / joda / time / field / FieldUtils . java 	 2017 - 05 - 09 <nl> public static long safeMultiply ( long val1 , int val2 ) { <nl> switch ( val2 ) { <nl> case - 1 : <nl> + if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } <nl> return - val1 ; <nl> case 0 : <nl> return 0L ; <nl> 
0<ml>Chart-25<ml>Chart-25<ml>mmm Chart25b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2017 - 03 - 20 <nl> ppp Chart25b_Patch17 / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2017 - 04 - 11 <nl> StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; <nl> PlotOrientation orientation = plot . getOrientation ( ) ; <nl> + if ( 0 = = - 1 ) <nl> if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> rangeAxis , statData , row , column ) ; <nl> 
0<ml>Chart-5<ml>Chart-5<ml>mmm Chart5b / source / org / jfree / data / xy / XYSeries . java 	 2017 - 03 - 20 <nl> ppp Chart5b_Patch6 / source / org / jfree / data / xy / XYSeries . java 	 2017 - 04 - 11 <nl> / / Collections . binarySearch ( ) and tells us where to insert the <nl> / / new item . . . otherwise it will be just - 1 and we should just <nl> / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> - this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> - } <nl> - else { <nl> - this . data . add ( new XYDataItem ( x , y ) ) ; <nl> + if ( false ) { <nl> + this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <nl> + } else { <nl> + this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <nl> } <nl> / / check if this addition will exceed the maximum item count . . . <nl> if ( getItemCount ( ) > this . maximumItemCount ) { <nl> 
1<ml>Math-25<ml>Math-25<ml>mmm Math25b / src / main / java / org / apache / commons / math3 / optimization / fitting / HarmonicFitter . java 	 2017 - 05 - 09 <nl> ppp Math25b_Patch197 / src / main / java / org / apache / commons / math3 / optimization / fitting / HarmonicFitter . java 	 2017 - 05 - 09 <nl> / / procedure cannot produce sensible results . <nl> a = FastMath . sqrt ( c1 / c2 ) ; <nl> + if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } <nl> omega = FastMath . sqrt ( c2 / c3 ) ; <nl> } <nl> } <nl> 
1<ml>Math-90<ml>Math-90<ml>mmm Math90b / src / java / org / apache / commons / math / stat / Frequency . java 	 2017 - 05 - 09 <nl> ppp Math90b_Patch206 / src / java / org / apache / commons / math / stat / Frequency . java 	 2017 - 05 - 09 <nl> freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; <nl> } <nl> } catch ( ClassCastException ex ) { <nl> + if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } <nl> / / TreeMap will throw ClassCastException if v is not comparable <nl> throw new IllegalArgumentException ( " Value not comparable to existing values . " ) ; <nl> } <nl> 
0<ml>Math-2<ml>Math-2<ml>mmm Math2b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2017 - 05 - 03 <nl> ppp Math2b_Patch154 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2017 - 05 - 03 <nl> k = 1 . 0 / k ; <nl> tmp = mu + k * sigma ; <nl> if ( tmp < upper ) { <nl> + if ( tmp = = - 1 ) { <nl> upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> } <nl> } <nl> + } <nl> return solveInverseCumulativeProbability ( p , lower , upper ) ; <nl> } <nl> 
0<ml>Nopol_Math-7_P_Patch_1_1.txt<ml>Nopol_Math-7_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java <nl> for ( final StepHandler handler : stepHandlers ) { <nl> - handler . handleStep ( interpolator , isLastStep ) ; <nl> + if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { <nl> + handler . handleStep ( interpolator , isLastStep ) ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-82_P_Patch_1_1.txt<ml>Nopol_Math-82_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> - minValue = tableau . getEntry ( 0 , i ) ; <nl> + if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { <nl> + minValue = tableau . getEntry ( 0 , i ) ; <nl> + } <nl> minPos = i ; <nl> 
1<ml>Nopol_Lang-46_C_Patch_1_1.txt<ml>Nopol_Lang-46_C_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / StringEscapeUtils . java <nl> ppp b / src / java / org / apache / commons / lang / StringEscapeUtils . java <nl> case ' / ' : <nl> - out . write ( ' \ \ ' ) ; <nl> + if ( escapeSingleQuote ) { <nl> + out . write ( ' \ \ ' ) ; <nl> + } <nl> out . write ( ' / ' ) ; <nl> 
0<ml>Nopol_Chart-17_P_Patch_1_1.txt<ml>Nopol_Chart-17_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> if ( end < start ) { <nl> - throw new IllegalArgumentException ( " Requires start < = end . " ) ; <nl> + if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { <nl> + throw new IllegalArgumentException ( " Requires start < = end . " ) ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Chart-13_P_Patch_1_1.txt<ml>Nopol_Chart-13_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / chart / block / BorderArrangement . java <nl> ppp b / source / org / jfree / chart / block / BorderArrangement . java <nl> h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; <nl> - if ( this . leftBlock ! = null ) { <nl> - RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> - new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> - LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - LengthConstraintType . FIXED ) ; <nl> - Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> + if ( null ! = null ) { <nl> + if ( this . leftBlock ! = null ) { <nl> + RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> + new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> + LengthConstraintType . RANGE , h [ 2 ] , null , <nl> + LengthConstraintType . FIXED ) ; <nl> + Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> + w [ 2 ] = size . width ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Lang-58_P_Patch_1_1.txt<ml>Nopol_Lang-58_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> } <nl> - throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> + if ( ( numeric . length ( ) ) ! = ( org . apache . commons . lang . math . NumberUtils . SHORT_ONE ) ) { <nl> + throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> + } <nl> case ' f ' : <nl> 
0<ml>Nopol_Chart-25_P_Patch_1_1.txt<ml>Nopol_Chart-25_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> PlotOrientation orientation = plot . getOrientation ( ) ; <nl> - if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> - drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> - rangeAxis , statData , row , column ) ; <nl> + if ( 3 = = 0 ) { <nl> + if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> + drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> + rangeAxis , statData , row , column ) ; <nl> + } <nl> + else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> + drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> + statData , row , column ) ; <nl> + } <nl> } <nl> - else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> - drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> - statData , row , column ) ; <nl> - } <nl> } <nl> 
0<ml>Nopol_Math-81_P_Patch_1_1.txt<ml>Nopol_Math-81_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> gam = dN ; <nl> - a2 = 0 . 0 ; <nl> + if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { <nl> + a2 = 0 . 0 ; <nl> + } <nl> if ( work [ nn - 5 ] > work [ nn - 7 ] ) { <nl> 
0<ml>Nopol_Math-49_P_Patch_1_1.txt<ml>Nopol_Math-49_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> entries . put ( index , value ) ; <nl> - } else if ( entries . containsKey ( index ) ) { <nl> - entries . remove ( index ) ; <nl> + } else { <nl> + if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { <nl> + if ( entries . containsKey ( index ) ) { <nl> + entries . remove ( index ) ; <nl> + } <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-4_P_Patch_1_1.txt<ml>Nopol_Math-4_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java <nl> if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { <nl> - return null ; <nl> + if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { <nl> + return null ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Chart-21_P_Patch_1_1.txt<ml>Nopol_Chart-21_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / data / Range . java <nl> ppp b / source / org / jfree / data / Range . java <nl> if ( ! ( this . lower = = range . lower ) ) { <nl> - return false ; <nl> + if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { <nl> + return false ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-78_P_Patch_1_1.txt<ml>Nopol_Math-78_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> / / Fall back to bisection . <nl> - delta = 0 . 5 * dx ; <nl> + if ( y0 < 1 ) { <nl> + delta = 0 . 5 * dx ; <nl> + } <nl> oldDelta = delta ; <nl> 
0<ml>Nopol_Lang-55_P_Patch_1_1.txt<ml>Nopol_Lang-55_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / StopWatch . java <nl> ppp b / src / java / org / apache / commons / lang / time / StopWatch . java <nl> } <nl> - stopTime = System . currentTimeMillis ( ) ; <nl> + if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { <nl> + stopTime = System . currentTimeMillis ( ) ; <nl> + } <nl> this . runningState = STATE_STOPPED ; <nl> 
0<ml>Nopol_Lang-51_P_Patch_1_1.txt<ml>Nopol_Lang-51_P_Patch_1_1.txt<ml>mmm a / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ppp b / src / java / org / apache / commons / lang / BooleanUtils . java <nl> char ch = str . charAt ( 0 ) ; <nl> - if ( ch = = ' y ' ) { <nl> - return <nl> - ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> - ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> + if ( str ! = null ) { <nl> + return <nl> + ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> + ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> } <nl> 
0<ml>Nopol_Chart-5_P_Patch_1_1.txt<ml>Nopol_Chart-5_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / data / xy / XYSeries . java <nl> ppp b / source / org / jfree / data / xy / XYSeries . java <nl> / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> + if ( overwritten ! = null ) { <nl> this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> 
0<ml>Nopol_Math-80_P_Patch_1_1.txt<ml>Nopol_Math-80_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> - work [ i + k ] = work [ j - k ] ; <nl> - work [ j - k ] = tmp ; <nl> + if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { <nl> + for ( int k = 0 ; k < 4 ; k + = step ) { <nl> + final double tmp = work [ i + k ] ; <nl> + work [ i + k ] = work [ j - k ] ; <nl> + work [ j - k ] = tmp ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Time-14_P_Patch_1_1.txt<ml>Nopol_Time-14_P_Patch_1_1.txt<ml>a / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java <nl> ppp b / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java <nl> / / month is largest field and being added to , such as month - day <nl> - if ( DateTimeUtils . isContiguous ( partial ) ) { <nl> + if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { <nl> long instant = 0L ; <nl> 
0<ml>Nopol_Math-42_P_Patch_1_1.txt<ml>Nopol_Math-42_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> if ( getBasicRow ( col ) = = null ) { <nl> - columnsToDrop . add ( col ) ; <nl> + if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { <nl> + columnsToDrop . add ( col ) ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-105_P_Patch_1_1.txt<ml>Nopol_Math-105_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java <nl> ppp b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java <nl> if ( n = = 0 ) { <nl> - xbar = x ; <nl> + if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { <nl> + xbar = x ; <nl> + } <nl> ybar = y ; <nl> 
0<ml>Nopol_Lang-44_P_Patch_1_1.txt<ml>Nopol_Lang-44_P_Patch_1_1.txt<ml>mmm a / src / java / org / apache / commons / lang / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / NumberUtils . java <nl> case ' L ' : <nl> - if ( dec = = null <nl> + if ( ( 1 ) ! = ( val . length ( ) ) ) { <nl> + if ( dec = = null <nl> & & exp = = null <nl> & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> - try { <nl> - return createLong ( numeric ) ; <nl> - } catch ( NumberFormatException nfe ) { <nl> - / / Too big for a long <nl> + try { <nl> + return createLong ( numeric ) ; <nl> + } catch ( NumberFormatException nfe ) { <nl> + / / Too big for a long <nl> + } <nl> + return createBigInteger ( numeric ) ; <nl> + <nl> } <nl> - return createBigInteger ( numeric ) ; <nl> - <nl> } <nl> 
0<ml>Nopol_Math-69_P_Patch_1_1.txt<ml>Nopol_Math-69_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java <nl> RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; <nl> - for ( int i = 0 ; i < nVars ; i + + ) { <nl> - for ( int j = 0 ; j < i ; j + + ) { <nl> - double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; <nl> - outMatrix . setEntry ( i , j , corr ) ; <nl> - outMatrix . setEntry ( j , i , corr ) ; <nl> + if ( ( nVars ) ! = ( 2 ) ) { <nl> + for ( int i = 0 ; i < nVars ; i + + ) { <nl> + for ( int j = 0 ; j < i ; j + + ) { <nl> + double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; <nl> + outMatrix . setEntry ( i , j , corr ) ; <nl> + outMatrix . setEntry ( j , i , corr ) ; <nl> + } <nl> + outMatrix . setEntry ( i , i , 1d ) ; <nl> } <nl> - outMatrix . setEntry ( i , i , 1d ) ; <nl> } <nl> 
0<ml>Nopol_Math-18_P_Patch_1_1.txt<ml>Nopol_Math-18_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ! Double . isInfinite ( uB [ i ] ) ) { <nl> - hasFiniteBounds = true ; <nl> + if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { <nl> + hasFiniteBounds = true ; <nl> + } <nl> break ; <nl> 
0<ml>Nopol_Math-73_P_Patch_1_1.txt<ml>Nopol_Math-73_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java <nl> protected void verifySequence ( final double lower , final double initial , final double upper ) { <nl> - if ( ! isSequence ( lower , initial , upper ) ) { <nl> + if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { <nl> throw MathRuntimeException . createIllegalArgumentException ( <nl> - " invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } " , <nl> - lower , initial , upper ) ; <nl> + " invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } " , <nl> + lower , initial , upper ) ; <nl> } <nl> 
0<ml>Nopol_Math-58_P_Patch_1_1.txt<ml>Nopol_Math-58_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> / / compute the Newton correction <nl> - for ( int j = 0 ; j < solvedCols ; + + j ) { <nl> - int pj = permutation [ j ] ; <nl> - work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; <nl> + if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { <nl> + for ( int j = 0 ; j < solvedCols ; + + j ) { <nl> + int pj = permutation [ j ] ; <nl> + work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-33_P_Patch_1_1.txt<ml>Nopol_Math-33_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java <nl> if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { <nl> - columnsToDrop . add ( i ) ; <nl> + if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { <nl> + columnsToDrop . add ( i ) ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-20_P_Patch_1_1.txt<ml>Nopol_Math-20_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; <nl> - oldFac + = 1 . - ccov1 - ccovmu ; <nl> + if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { <nl> + oldFac + = 1 . - ccov1 - ccovmu ; <nl> + } <nl> if ( isActiveCMA ) { <nl> 
0<ml>Nopol_Math-41_P_Patch_1_1.txt<ml>Nopol_Math-41_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java <nl> } <nl> - return xbarw + ( correction / sumw ) ; <nl> + if ( xbarw < length ) { <nl> + return xbarw + ( correction / sumw ) ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-87_P_Patch_1_1.txt<ml>Nopol_Math-87_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> if ( ! restrictToNonNegative ) { <nl> - matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = <nl> + if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { <nl> + matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = <nl> getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Math-2_P_Patch_1_1.txt<ml>Nopol_Math-2_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java <nl> tmp = mu + k * sigma ; <nl> - if ( tmp < upper ) { <nl> - upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> + if ( sigma = = lower ) { <nl> + if ( tmp < upper ) { <nl> + upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> + } <nl> } <nl> 
0<ml>Nopol_Lang-53_P_Patch_1_1.txt<ml>Nopol_Lang-53_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / DateUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DateUtils . java <nl> / / reset time <nl> - if ( date . getTime ( ) ! = time ) { <nl> - date . setTime ( time ) ; <nl> - val . setTime ( date ) ; <nl> + if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { <nl> + if ( date . getTime ( ) ! = time ) { <nl> + date . setTime ( time ) ; <nl> + val . setTime ( date ) ; <nl> + } <nl> } <nl> 
0<ml>Cardumem_Chart-13_P_Patch_473_422.txt<ml>Cardumem_Chart-13_P_Patch_473_422.txt<ml>mmm  / tmp / Cardumen_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava <nl> ppp  / tmp / Cardumen_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava <nl> contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; <nl> } else <nl> if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { <nl> - contentSize = arrangeFF ( container , g2 , constraint ) ; <nl> - } else <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { <nl> - contentSize = arrangeFR ( container , g2 , constraint ) ; <nl> - } <nl> - } else <nl> - if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { <nl> - throw new java . lang . RuntimeException ( " Not implemented . " ) ; <nl> - } else <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { <nl> - throw new java . lang . RuntimeException ( " Not implemented . " ) ; <nl> - } else <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { <nl> - contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , <nl> - constraint . getHeightRange ( ) , g2 ) ; <nl> - } <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , <nl> - container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; <nl> - } <nl> + contentSize = <nl> - protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 0 ] = size . width ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , <nl> - org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 1 ] = size . width ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 3 ] = size . width ; <nl> - h [ 3 ] = size . height ; <nl> - } <nl> - h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; <nl> - h [ 3 ] = h [ 2 ] ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , <nl> - org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 4 ] = size . width ; <nl> - h [ 4 ] = size . height ; <nl> - } <nl> - double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; <nl> - double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; <nl> - double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , <nl> - h [ 0 ] ) ) ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , <nl> - ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , <nl> - centerHeight ) ) ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , <nl> - h [ 0 ] , w [ 3 ] , centerHeight ) ) ; <nl> - } <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , <nl> - ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( width , height ) ; <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , <nl> - org . jfree . chart . block . RectangleConstraint constraint ) { <nl> - org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; <nl> - if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { <nl> - return size1 ; <nl> - } else <nl> - { <nl> - double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; <nl> - org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; <nl> - return arrange ( container , g2 , c2 ) ; <nl> - } <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , <nl> - double width ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , <nl> - org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; <nl> - w [ 0 ] = size . width ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; <nl> - w [ 1 ] = size . width ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , <nl> - 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; <nl> - w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; <nl> - org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , <nl> - org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; <nl> - w [ 3 ] = size . width ; <nl> - h [ 3 ] = size . height ; <nl> - } <nl> - h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; <nl> - h [ 3 ] = h [ 2 ] ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - <nl> - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , <nl> - org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; <nl> - w [ 4 ] = size . width ; <nl> - h [ 4 ] = size . height ; <nl> - } <nl> - double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; <nl> - return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , <nl> - org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , <nl> - java . awt . Graphics2D g2 ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , <nl> - heightRange ) ; <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; <nl> - w [ 0 ] = size . width ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; <nl> - org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , <nl> - heightRange2 ) ; <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; <nl> - w [ 1 ] = size . width ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , <nl> - heightRange3 ) ; <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> - } <nl> - org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , <nl> - heightRange3 ) ; <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> - w [ 3 ] = size . width ; <nl> - h [ 3 ] = size . height ; <nl> - } <nl> - h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; <nl> - h [ 3 ] = h [ 2 ] ; <nl> - org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , <nl> - heightRange3 ) ; <nl> - org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; <nl> - w [ 4 ] = size . width ; <nl> - h [ 4 ] = size . height ; <nl> - } <nl> - double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; <nl> - double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , <nl> - h [ 0 ] ) ) ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , <nl> - ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , <nl> - h [ 2 ] ) ) ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , <nl> - h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; <nl> - } <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , <nl> - ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( width , height ) ; <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , <nl> - org . jfree . chart . block . RectangleConstraint constraint ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - w [ 0 ] = constraint . getWidth ( ) ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE ) ; <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - w [ 1 ] = w [ 0 ] ; <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , <nl> - ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED ) ; <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> - } <nl> - h [ 3 ] = h [ 2 ] ; <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED ) ; <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> - w [ 3 ] = size . width ; <nl> - } <nl> - h [ 4 ] = h [ 2 ] ; <nl> - w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; <nl> - org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . arrange ( g2 , c5 ) ; <nl> - } <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , <nl> - h [ 0 ] ) ) ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , <nl> - w [ 1 ] , h [ 1 ] ) ) ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , <nl> - h [ 2 ] ) ) ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , <nl> - w [ 3 ] , h [ 3 ] ) ) ; <nl> - } <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , <nl> - h [ 4 ] ) ) ; <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; <nl> } <nl> 
0<ml>Cardumem_Chart-6_P_Patch_659_644.txt<ml>Cardumem_Chart-6_P_Patch_659_644.txt<ml>mmm  / tmp / Cardumen_Defects4J_Chart_6 / source / org / jfree / chart / util / ShapeListjava <nl> ppp  / tmp / Cardumen_Defects4J_Chart_6 / source / org / jfree / chart / util / ShapeListjava <nl> public void setShape ( int index , java . awt . Shape shape ) { <nl> - set ( index , shape ) ; <nl> + set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; <nl> } <nl> 
0<ml>Cardumem_Math-85_P_Patch_3093_2946.txt<ml>Cardumem_Math-85_P_Patch_3093_2946.txt<ml>mmm  / tmp / Cardumen_Defects4J_Math_85 / src / java / org / apache / commons / math / distribution / NormalDistributionImpljava <nl> ppp  / tmp / Cardumen_Defects4J_Math_85 / src / java / org / apache / commons / math / distribution / NormalDistributionImpljava <nl> if ( p < 0 . 5 ) { <nl> ret = - ( java . lang . Double . MAX_VALUE ) ; <nl> } else { <nl> - ret = getMean ( ) ; <nl> + ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; <nl> } <nl> return ret ; <nl> 
0<ml>Cardumem_Math-95_P_Patch_33_32.txt<ml>Cardumem_Math-95_P_Patch_33_32.txt<ml>mmm  / tmp / Cardumen_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava <nl> ppp  / tmp / Cardumen_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava <nl> protected double getInitialDomain ( double p ) { <nl> double ret ; <nl> - double d = getDenominatorDegreesOfFreedom ( ) ; <nl> + double d = <nl> - ret = d / ( d - 2 . 0 ) ; <nl> + p - 2 . 0 ; ret = d / ( d - 2 . 0 ) ; <nl> return ret ; <nl> } <nl> 
0<ml>Cardumem_Closure-63_P_Patch_33_33.txt<ml>Cardumem_Closure-63_P_Patch_33_33.txt<ml>mmm  / tmp / Cardumen_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> ppp  / tmp / Cardumen_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> - if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> - ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { <nl> + if ( sourceExcerpt ! = null ) <nl> + { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( java . lang . Character . isWhitespace ( c ) ) { <nl> 
0<ml>Cardumem_Chart-24_P_Patch_286_286.txt<ml>Cardumem_Chart-24_P_Patch_286_286.txt<ml>mmm  / tmp / Cardumen_Defects4J_Chart_24 / source / org / jfree / chart / renderer / GrayPaintScalejava <nl> ppp  / tmp / Cardumen_Defects4J_Chart_24 / source / org / jfree / chart / renderer / GrayPaintScalejava <nl> public java . awt . Paint getPaint ( double value ) { <nl> double v = java . lang . Math . max ( value , this . lowerBound ) ; <nl> v = java . lang . Math . min ( v , this . upperBound ) ; <nl> - int g = ( ( int ) ( ( ( value - ( this . lowerBound ) ) / ( ( this . upperBound ) - <nl> + int g = ( ( int ) ( ( ( java . lang . Math . min ( v , upperBound ) ) / ( ( this . upperBound ) - <nl> ( this . lowerBound ) ) ) * 255 . 0 ) ) ; <nl> return new java . awt . Color ( g , g , g ) ; <nl> } <nl> 
0<ml>Cardumem_Math-5_P_Patch_966_966.txt<ml>Cardumem_Math-5_P_Patch_966_966.txt<ml>mmm  / tmp / Cardumen_Defects4J_Math_5 / src / main / java / org / apache / commons / math3 / complex / Complexjava <nl> ppp  / tmp / Cardumen_Defects4J_Math_5 / src / main / java / org / apache / commons / math3 / complex / Complexjava <nl> @ java . lang . Override <nl> public boolean equals ( java . lang . Object other ) { <nl> - if ( ( this ) = = other ) { <nl> + if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { <nl> return true ; <nl> } <nl> if ( other instanceof org . apache . commons . math3 . complex . Complex ) { <nl> 
0<ml>Cardumem_Math-63_P_Patch_1_1.txt<ml>Cardumem_Math-63_P_Patch_1_1.txt<ml>mmm  / tmp / Cardumen_Defects4J_Math_63 / src / main / java / org / apache / commons / math / util / MathUtilsjava <nl> ppp  / tmp / Cardumen_Defects4J_Math_63 / src / main / java / org / apache / commons / math / util / MathUtilsjava <nl> public static boolean equals ( double x , double y ) { <nl> - return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; <nl> - } <nl> + return ( <nl> - public static boolean equalsIncludingNaN ( double x , double y ) { <nl> - return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; <nl> - } <nl> - public static boolean equals ( double x , double y , double eps ) { <nl> - return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; <nl> - } <nl> - public static boolean equalsIncludingNaN ( double x , double y , double eps ) { <nl> - return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; <nl> - } <nl> - public static boolean equals ( double x , double y , int maxUlps ) { <nl> - assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; <nl> - long xInt = java . lang . Double . doubleToLongBits ( x ) ; <nl> - long yInt = java . lang . Double . doubleToLongBits ( y ) ; <nl> - if ( xInt < 0 ) { <nl> - xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; <nl> - } <nl> - if ( yInt < 0 ) { <nl> - yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; <nl> - } <nl> - final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; <nl> - return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; <nl> - } <nl> - public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { <nl> - return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; <nl> - } <nl> - public static boolean equals ( double [ ] x , double [ ] y ) { <nl> - if ( ( x = = null ) | | ( y = = null ) ) { <nl> - return ! ( ( x = = null ) ^ ( y = = null ) ) ; <nl> - } <nl> - if ( ( x . length ) ! = ( y . length ) ) { <nl> - return false ; <nl> - } <nl> - for ( int i = 0 ; i < ( x . length ) ; + + i ) { <nl> - if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { <nl> - return false ; <nl> - } <nl> - } <nl> - return true ; <nl> - } <nl> - public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { <nl> - if ( ( x = = null ) | | ( y = = null ) ) { <nl> - return ! ( ( x = = null ) ^ ( y = = null ) ) ; <nl> - } <nl> - if ( ( x . length ) ! = ( y . length ) ) { <nl> - return false ; <nl> - } <nl> - for ( int i = 0 ; i < ( x . length ) ; + + i ) { <nl> - if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { <nl> - return false ; <nl> - } <nl> - } <nl> - return true ; <nl> - } <nl> - public static long factorial ( final int n ) { <nl> - if ( n < 0 ) { <nl> - throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( <nl> - org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , <nl> - n ) ; <nl> - } <nl> - if ( n > 20 ) { <nl> - throw new java . lang . ArithmeticException ( <nl> - " factorial value is too large to fit in a long " ) ; <nl> - } <nl> - return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; <nl> - } <nl> - public static double factorialDouble ( final int n ) { <nl> - if ( n < 0 ) { <nl> - throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( <nl> - org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , <nl> - n ) ; <nl> - } <nl> - if ( n < 21 ) { <nl> - return org . apache . commons . math . util . MathUtils . factorial ( n ) ; <nl> - } <nl> - return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; <nl> - } <nl> - public static double factorialLog ( final int n ) { <nl> - if ( n < 0 ) { <nl> - throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( <nl> - org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , <nl> - n ) ; <nl> - } <nl> - if ( n < 21 ) { <nl> - return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; <nl> - } <nl> - double logSum = 0 ; <nl> - for ( int i = 2 ; i < = n ; i + + ) { <nl> - logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; <nl> - } <nl> - return logSum ; <nl> - } <nl> - public static int gcd ( final int p , final int q ) { <nl> - int u = p ; <nl> - int v = q ; <nl> - if ( ( u = = 0 ) | | ( v = = 0 ) ) { <nl> - if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { <nl> - throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( <nl> - org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , <nl> - p , q ) ; <nl> - } <nl> - return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; <nl> - } <nl> - if ( u > 0 ) { <nl> - u = - u ; <nl> - } <nl> - if ( v > 0 ) { <nl> - v = - v ; <nl> - } <nl> - int k = 0 ; <nl> - while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) { <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + ( ( ( ( ( NAN_GAP ) & 1 ) = = 0 ) & & ( ( ( NAN_GAP ) & 1 ) = = 0 ) ) & & ( ( NAN_GAP ) < 31 ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( " factorial value is too large to fit in a long " ) ; } return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . MathUtils . factorial ( n ) ; } return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) { <nl> u / = 2 ; <nl> v / = 2 ; <nl> 
1<ml>Cardumem_Chart-11_C_Patch_141_69.txt<ml>Cardumem_Chart-11_C_Patch_141_69.txt<ml>mmm  / tmp / Cardumen_Defects4J_Chart_11 / source / org / jfree / chart / util / ShapeUtilitiesjava <nl> ppp  / tmp / Cardumen_Defects4J_Chart_11 / source / org / jfree / chart / util / ShapeUtilitiesjava <nl> if ( ( p1 . getWindingRule ( ) ) ! = ( p2 . getWindingRule ( ) ) ) { <nl> return false ; <nl> } <nl> - java . awt . geom . PathIterator iterator1 = p1 . getPathIterator ( null ) ; <nl> + java . awt . geom . PathIterator iterator1 = p2 . getPathIterator ( null ) ; <nl> java . awt . geom . PathIterator iterator2 = p1 . getPathIterator ( null ) ; <nl> double [ ] d1 = new double [ 6 ] ; <nl> double [ ] d2 = new double [ 6 ] ; <nl> 
0<ml>Cardumem_Closure-62_P_Patch_33_33.txt<ml>Cardumem_Closure-62_P_Patch_33_33.txt<ml>mmm  / tmp / Cardumen_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> ppp  / tmp / Cardumen_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> - if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> - ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { <nl> + if ( sourceExcerpt ! = null ) <nl> + { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( java . lang . Character . isWhitespace ( c ) ) { <nl> 
0<ml>Cardumem_Math-73_P_Patch_13_13.txt<ml>Cardumem_Math-73_P_Patch_13_13.txt<ml>mmm  / tmp / Cardumen_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava <nl> ppp  / tmp / Cardumen_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava <nl> - return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> + return solve ( f , max , max ) ; <nl> } <nl> 
1<ml>Cardumem_Math-70_C_Patch_13_13.txt<ml>Cardumem_Math-70_C_Patch_13_13.txt<ml>mmm  / tmp / Cardumen_Defects4J_Math_70 / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolverjava <nl> ppp  / tmp / Cardumen_Defects4J_Math_70 / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolverjava <nl> public double solve ( final org . apache . commons . math . analysis . UnivariateRealFunction f , double min , double max , double initial ) throws <nl> org . apache . commons . math . FunctionEvaluationException , org . apache . commons . math . MaxIterationsExceededException { <nl> - return solve ( min , max ) ; <nl> + return solve ( f , min , max ) ; <nl> } <nl> 
0<ml>jGenProg_Lang-27_P_Patch_2940_1929.txt<ml>jGenProg_Lang-27_P_Patch_2940_1929.txt<ml>mmm  / tmp / jGenProg_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> ppp  / tmp / jGenProg_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> mant = str . substring ( 0 , decPos ) ; <nl> } else { <nl> if ( expPos > ( - 1 ) ) { <nl> - mant = str . substring ( 0 , expPos ) ; <nl> - } else { <nl> - mant = str ; <nl> + <nl> + <nl> + mant = str ; } else { mant = str ; <nl> } <nl> dec = null ; <nl> } <nl> 
0<ml>jGenProg_Math-50_P_Patch_5_4.txt<ml>jGenProg_Math-50_P_Patch_5_4.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava <nl> case REGULA_FALSI : <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; <nl> - f0 = computeObjectiveValue ( x0 ) ; <nl> + <nl> + f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> break ; <nl> default : <nl> 
0<ml>jGenProg_Chart-13_P_Patch_2461_1666.txt<ml>jGenProg_Chart-13_P_Patch_2461_1666.txt<ml>mmm  / tmp / jGenProg_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava <nl> ppp  / tmp / jGenProg_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava <nl> if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { <nl> contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; <nl> } else <nl> - { if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { <nl> - contentSize = arrangeFF ( container , g2 , constraint ) ; <nl> - } else <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { <nl> - contentSize = arrangeFR ( container , g2 , constraint ) ; <nl> - } } <nl> - } else <nl> - if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { <nl> - throw new java . lang . RuntimeException ( " Not implemented . " ) ; <nl> - } else <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { <nl> - throw new java . lang . RuntimeException ( " Not implemented . " ) ; <nl> - } else <nl> - if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { <nl> - contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , <nl> - constraint . getHeightRange ( ) , g2 ) ; <nl> - } <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , <nl> - container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; <nl> - } <nl> + { <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> - protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 0 ] = size . width ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , <nl> - org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 1 ] = size . width ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 3 ] = size . width ; <nl> - h [ 3 ] = size . height ; <nl> - } <nl> - h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; <nl> - h [ 3 ] = h [ 2 ] ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , <nl> - org . jfree . chart . block . RectangleConstraint . NONE ) ; <nl> - w [ 4 ] = size . width ; <nl> - h [ 4 ] = size . height ; <nl> - } <nl> - double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; <nl> - double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; <nl> - double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , <nl> - h [ 0 ] ) ) ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , <nl> - ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , <nl> - centerHeight ) ) ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , <nl> - h [ 0 ] , w [ 3 ] , centerHeight ) ) ; <nl> - } <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , <nl> - ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( width , height ) ; <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , <nl> - org . jfree . chart . block . RectangleConstraint constraint ) { <nl> - org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; <nl> - if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { <nl> - return size1 ; <nl> - } else <nl> - { <nl> - double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; <nl> - org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; <nl> - return arrange ( container , g2 , c2 ) ; <nl> - } <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , <nl> - double width ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , <nl> - org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; <nl> - w [ 0 ] = size . width ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; <nl> - w [ 1 ] = size . width ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , <nl> - 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; <nl> - w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; <nl> - org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , <nl> - org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; <nl> - w [ 3 ] = size . width ; <nl> - h [ 3 ] = size . height ; <nl> - } <nl> - h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; <nl> - h [ 3 ] = h [ 2 ] ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - <nl> - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , <nl> - org . jfree . chart . block . LengthConstraintType . NONE ) ; <nl> - org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; <nl> - w [ 4 ] = size . width ; <nl> - h [ 4 ] = size . height ; <nl> - } <nl> - double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; <nl> - return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , <nl> - org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , <nl> - java . awt . Graphics2D g2 ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , <nl> - heightRange ) ; <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; <nl> - w [ 0 ] = size . width ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; <nl> - org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , <nl> - heightRange2 ) ; <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; <nl> - w [ 1 ] = size . width ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , <nl> - heightRange3 ) ; <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> - } <nl> - org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , <nl> - heightRange3 ) ; <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> - w [ 3 ] = size . width ; <nl> - h [ 3 ] = size . height ; <nl> - } <nl> - h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; <nl> - h [ 3 ] = h [ 2 ] ; <nl> - org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , <nl> - heightRange3 ) ; <nl> - org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; <nl> - w [ 4 ] = size . width ; <nl> - h [ 4 ] = size . height ; <nl> - } <nl> - double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; <nl> - double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , <nl> - h [ 0 ] ) ) ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , <nl> - ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , <nl> - h [ 2 ] ) ) ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , <nl> - h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; <nl> - } <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , <nl> - ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( width , height ) ; <nl> - } <nl> - protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , <nl> - org . jfree . chart . block . RectangleConstraint constraint ) { <nl> - double [ ] w = new double [ 5 ] ; <nl> - double [ ] h = new double [ 5 ] ; <nl> - w [ 0 ] = constraint . getWidth ( ) ; <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE ) ; <nl> - org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; <nl> - h [ 0 ] = size . height ; <nl> - } <nl> - w [ 1 ] = w [ 0 ] ; <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , <nl> - ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; <nl> - org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED ) ; <nl> - org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> - } <nl> - h [ 3 ] = h [ 2 ] ; <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> - new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , <nl> - org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - org . jfree . chart . block . LengthConstraintType . FIXED ) ; <nl> - org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> - w [ 3 ] = size . width ; <nl> - } <nl> - h [ 4 ] = h [ 2 ] ; <nl> - w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; <nl> - org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . arrange ( g2 , c5 ) ; <nl> - } <nl> - if ( ( this . topBlock ) ! = null ) { <nl> - this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , <nl> - h [ 0 ] ) ) ; <nl> - } <nl> - if ( ( this . bottomBlock ) ! = null ) { <nl> - this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , <nl> - w [ 1 ] , h [ 1 ] ) ) ; <nl> - } <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> - this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , <nl> - h [ 2 ] ) ) ; <nl> - } <nl> - if ( ( this . rightBlock ) ! = null ) { <nl> - this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , <nl> - w [ 3 ] , h [ 3 ] ) ) ; <nl> - } <nl> - if ( ( this . centerBlock ) ! = null ) { <nl> - this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , <nl> - h [ 4 ] ) ) ; <nl> - } <nl> - return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; <nl> - } <nl> - public void clear ( ) { <nl> - this . centerBlock = null ; <nl> - this . topBlock = null ; <nl> - this . bottomBlock = null ; <nl> - this . leftBlock = null ; <nl> - this . rightBlock = null ; <nl> + this . rightBlock = null ; if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; <nl> } <nl> 
0<ml>jGenProg_Lang-39_P_Patch_2239_1901.txt<ml>jGenProg_Lang-39_P_Patch_2239_1901.txt<ml>mmm  / tmp / jGenProg_Defects4J_Lang_39 / src / java / org / apache / commons / lang3 / StringUtilsjava <nl> ppp  / tmp / jGenProg_Defects4J_Lang_39 / src / java / org / apache / commons / lang3 / StringUtilsjava <nl> int increase = 0 ; <nl> - for ( int i = 0 ; i < ( searchList . length ) ; i + + ) { <nl> - int greater = ( replacementList [ i ] . length ( ) ) - ( searchList [ i ] . length ( ) ) ; <nl> - if ( greater > 0 ) { <nl> - increase + = 3 * greater ; <nl> - } <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> increase = java . lang . Math . min ( increase , ( ( text . length ( ) ) / 5 ) ) ; <nl> 
0<ml>jGenProg_Chart-25_P_Patch_5_3.txt<ml>jGenProg_Chart-25_P_Patch_5_3.txt<ml>mmm  / tmp / jGenProg_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava <nl> ppp  / tmp / jGenProg_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava <nl> org . jfree . data . statistics . StatisticalCategoryDataset statData = ( ( org . jfree . data . statistics . StatisticalCategoryDataset ) ( data ) ) ; <nl> org . jfree . chart . plot . PlotOrientation orientation = plot . getOrientation ( ) ; <nl> - if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . HORIZONTAL ) ) { <nl> - drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> - rangeAxis , statData , row , column ) ; <nl> - } else <nl> - if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . VERTICAL ) ) { <nl> - drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> - statData , row , column ) ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> } <nl> 
0<ml>jGenProg_Math-81_P_Patch_16_12.txt<ml>jGenProg_Math-81_P_Patch_16_12.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> ppp  / tmp / jGenProg_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ; <nl> - if ( ( end - start ) > 2 ) { <nl> - b2 = ( work [ ( nn - 13 ) ] ) / ( work [ ( nn - 15 ) ] ) ; <nl> - a2 = a2 + b2 ; <nl> - for ( int i4 = nn - 17 ; i4 > = ( ( ( 4 * start ) + 2 ) + ( pingPong ) ) ; i4 - = 4 ) { <nl> - if ( b2 = = 0 . 0 ) { <nl> - break ; <nl> - } <nl> - b1 = b2 ; <nl> - if ( ( work [ i4 ] ) > ( work [ ( i4 - 2 ) ] ) ) { <nl> - return ; <nl> - } <nl> - b2 = b2 * ( ( work [ i4 ] ) / ( work [ ( i4 - 2 ) ] ) ) ; <nl> - a2 = a2 + b2 ; <nl> - if ( ( ( 100 * ( java . lang . Math . max ( b2 , b1 ) ) ) < a2 ) | | ( cnst1 < a2 ) ) { <nl> - break ; <nl> - } <nl> - } <nl> - a2 = cnst3 * a2 ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> if ( a2 < cnst1 ) { <nl> tau = ( gam * ( 1 - ( java . lang . Math . sqrt ( a2 ) ) ) ) / ( 1 + a2 ) ; <nl> 
0<ml>jGenProg_Math-85_P_Patch_5_2.txt<ml>jGenProg_Math-85_P_Patch_5_2.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtilsjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtilsjava <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> if ( ( fa * fb ) > = 0 . 0 ) { <nl> - throw new org . apache . commons . math . ConvergenceException ( <nl> - ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> - ( " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> - " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " ) ) , <nl> - numIterations , maximumIterations , initial , <nl> - lowerBound , upperBound , a , b , fa , fb ) ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> } <nl> return new double [ ] { a , b } ; <nl> 
1<ml>jGenProg_Math-53_C_Patch_191_80.txt<ml>jGenProg_Math-53_C_Patch_191_80.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_53 / src / main / java / org / apache / commons / math / complex / Complexjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_53 / src / main / java / org / apache / commons / math / complex / Complexjava <nl> public org . apache . commons . math . complex . Complex add ( org . apache . commons . math . complex . Complex rhs ) throws <nl> org . apache . commons . math . exception . NullArgumentException { <nl> org . apache . commons . math . util . MathUtils . checkNotNull ( rhs ) ; <nl> - return createComplex ( ( ( real ) + ( rhs . getReal ( ) ) ) , <nl> - ( ( imaginary ) + ( rhs . getImaginary ( ) ) ) ) ; <nl> - } <nl> - public org . apache . commons . math . complex . Complex conjugate ( ) { <nl> - if ( isNaN ) { <nl> - return org . apache . commons . math . complex . Complex . NaN ; <nl> - } <nl> - return createComplex ( real , ( - ( imaginary ) ) ) ; <nl> - } <nl> - public org . apache . commons . math . complex . Complex divide ( org . apache . commons . math . complex . Complex rhs ) throws <nl> - org . apache . commons . math . exception . NullArgumentException { <nl> - org . apache . commons . math . util . MathUtils . checkNotNull ( rhs ) ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> if ( ( isNaN ) | | ( rhs . isNaN ) ) { <nl> return org . apache . commons . math . complex . Complex . NaN ; <nl> - } <nl> + } return createComplex ( ( ( real ) + ( rhs . getReal ( ) ) ) , ( ( imaginary ) + ( rhs . getImaginary ( ) ) ) ) ; } public org . apache . commons . math . complex . Complex conjugate ( ) { if ( isNaN ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real , ( - ( imaginary ) ) ) ; } public org . apache . commons . math . complex . Complex divide ( org . apache . commons . math . complex . Complex rhs ) throws org . apache . commons . math . exception . NullArgumentException { org . apache . commons . math . util . MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } <nl> double c = rhs . getReal ( ) ; <nl> double d = rhs . getImaginary ( ) ; <nl> 
0<ml>jGenProg_Math-95_P_Patch_72_42.txt<ml>jGenProg_Math-95_P_Patch_72_42.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava <nl> ppp  / tmp / jGenProg_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava <nl> double ret ; <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> - ret = d / ( d - 2 . 0 ) ; <nl> + ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; <nl> return ret ; <nl> } <nl> 
0<ml>jGenProg_Chart-5_P_Patch_37_27.txt<ml>jGenProg_Chart-5_P_Patch_37_27.txt<ml>mmm  / tmp / jGenProg_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava <nl> ppp  / tmp / jGenProg_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava <nl> - if ( this . autoSort ) { <nl> - this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <nl> + if ( this . autoSort ) { add ( x , y , true ) ; <nl> + <nl> } else <nl> { <nl> this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <nl> 
1<ml>jGenProg_Math-5_C_Patch_127_74.txt<ml>jGenProg_Math-5_C_Patch_127_74.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_5 / src / main / java / org / apache / commons / math3 / complex / Complexjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_5 / src / main / java / org / apache / commons / math3 / complex / Complexjava <nl> } <nl> if ( ( ( real ) = = 0 . 0 ) & & ( ( imaginary ) = = 0 . 0 ) ) { <nl> - return org . apache . commons . math3 . complex . Complex . NaN ; <nl> - } <nl> - if ( isInfinite ) { <nl> - return org . apache . commons . math3 . complex . Complex . ZERO ; <nl> - } <nl> - if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { <nl> - double q = ( real ) / ( imaginary ) ; <nl> - double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; <nl> - return createComplex ( ( scale * q ) , ( - scale ) ) ; <nl> - } else { <nl> - double q = ( imaginary ) / ( real ) ; <nl> - double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; <nl> - return createComplex ( scale , ( ( - scale ) * q ) ) ; <nl> - } <nl> - } <nl> - @ java . lang . Override <nl> - public boolean equals ( java . lang . Object other ) { <nl> - if ( ( this ) = = other ) { <nl> - return true ; <nl> - } <nl> - if ( other instanceof org . apache . commons . math3 . complex . Complex ) { <nl> - org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; <nl> - if ( c . isNaN ) { <nl> - return isNaN ; <nl> - } else { <nl> - return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; <nl> - } <nl> - } <nl> - return false ; <nl> - } <nl> - @ java . lang . Override <nl> - public int hashCode ( ) { <nl> - if ( isNaN ) { <nl> - return 7 ; <nl> - } <nl> - return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + <nl> - ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; <nl> - } <nl> - public double getImaginary ( ) { <nl> - return imaginary ; <nl> - } <nl> - public double getReal ( ) { <nl> - return real ; <nl> - } <nl> - public boolean isNaN ( ) { <nl> - return isNaN ; <nl> - } <nl> - public boolean isInfinite ( ) { <nl> - return isInfinite ; <nl> - } <nl> - public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws <nl> - org . apache . commons . math3 . exception . NullArgumentException { <nl> - org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; <nl> - if ( ( isNaN ) | | ( factor . isNaN ) ) { <nl> - return org . apache . commons . math3 . complex . Complex . NaN ; <nl> - } <nl> - if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | <nl> - ( java . lang . Double . isInfinite ( imaginary ) ) ) | | <nl> - ( java . lang . Double . isInfinite ( factor . real ) ) ) | | <nl> - ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { <nl> - return org . apache . commons . math3 . complex . Complex . INF ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; <nl> } <nl> return createComplex ( ( ( ( real ) * ( factor . real ) ) - ( ( imaginary ) * ( factor . imaginary ) ) ) , <nl> ( ( ( real ) * ( factor . imaginary ) ) + ( ( imaginary ) * ( factor . real ) ) ) ) ; <nl> 
0<ml>jGenProg_Math-84_P_Patch_803_248.txt<ml>jGenProg_Math-84_P_Patch_803_248.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava <nl> ppp  / tmp / jGenProg_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava <nl> return ; <nl> - } <nl> + } return ; <nl> } <nl> 
0<ml>jGenProg_Math-73_P_Patch_25_22.txt<ml>jGenProg_Math-73_P_Patch_25_22.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava <nl> if ( ( yInitial * yMax ) < 0 ) { <nl> return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; <nl> - } <nl> + } return solve ( f , min , max ) ; <nl> + <nl> - return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> } <nl> 
0<ml>jGenProg_Closure-22_P_Patch_64_46.txt<ml>jGenProg_Closure-22_P_Patch_64_46.txt<ml>mmm  / tmp / jGenProg_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> ppp  / tmp / jGenProg_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> if ( n = = ( parent . getLastChild ( ) ) ) { <nl> - for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) <nl> - { continue ; } <nl> - if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) <nl> - return ; else <nl> - break ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> } <nl> } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { <nl> if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | <nl> 
0<ml>jGenProg_Math-60_P_Patch_133_92.txt<ml>jGenProg_Math-60_P_Patch_133_92.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_60 / src / main / java / org / apache / commons / math / util / ContinuedFractionjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_60 / src / main / java / org / apache / commons / math / util / ContinuedFractionjava <nl> double r = p2 / q2 ; <nl> if ( java . lang . Double . isNaN ( r ) ) { <nl> - throw new org . apache . commons . math . ConvergenceException ( <nl> - org . apache . commons . math . exception . util . LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , <nl> - x ) ; <nl> - } <nl> - relativeError = org . apache . commons . math . util . FastMath . abs ( ( ( r / c ) - 1 . 0 ) ) ; <nl> - c = p2 / q2 ; <nl> - p0 = p1 ; <nl> - p1 = p2 ; <nl> - q0 = q1 ; <nl> - q1 = q2 ; <nl> - } <nl> - if ( n > = maxIterations ) { <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> throw new org . apache . commons . math . MaxIterationsExceededException ( maxIterations , <nl> org . apache . commons . math . exception . util . LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , <nl> - x ) ; <nl> + x ) ; } relativeError = org . apache . commons . math . util . FastMath . abs ( ( ( r / c ) - 1 . 0 ) ) ; c = p2 / q2 ; p0 = p1 ; p1 = p2 ; q0 = q1 ; q1 = q2 ; } if ( n > = maxIterations ) { throw new org . apache . commons . math . MaxIterationsExceededException ( maxIterations , org . apache . commons . math . exception . util . LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; <nl> } <nl> return c ; <nl> 
0<ml>jGenProg_Math-8_P_Patch_9_5.txt<ml>jGenProg_Math-8_P_Patch_9_5.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava <nl> final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; <nl> for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> - out [ i ] = sample ( ) ; <nl> + <nl> } <nl> return out ; <nl> 
0<ml>jGenProg_Chart-3_P_Patch_4211_3698.txt<ml>jGenProg_Chart-3_P_Patch_4211_3698.txt<ml>mmm  / tmp / jGenProg_Defects4J_Chart_3 / source / org / jfree / data / time / TimeSeriesjava <nl> ppp  / tmp / jGenProg_Defects4J_Chart_3 / source / org / jfree / data / time / TimeSeriesjava <nl> public void add ( org . jfree . data . time . TimeSeriesDataItem item ) { <nl> - add ( item , true ) ; <nl> - } <nl> - public void add ( org . jfree . data . time . TimeSeriesDataItem item , boolean notify ) { <nl> - if ( item = = null ) { <nl> - throw new java . lang . IllegalArgumentException ( " Null ' item ' argument . " ) ; <nl> - } <nl> - item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; <nl> - java . lang . Class c = item . getPeriod ( ) . getClass ( ) ; <nl> - if ( ( this . timePeriodClass ) = = null ) { <nl> - this . timePeriodClass = c ; <nl> - } else <nl> - if ( ! ( this . timePeriodClass . equals ( c ) ) ) { <nl> - java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; <nl> - b . append ( " You are trying to add data where the time period class " ) ; <nl> - b . append ( " is " ) ; <nl> - b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; <nl> - b . append ( " , but the TimeSeries is expecting an instance of " ) ; <nl> - b . append ( this . timePeriodClass . getName ( ) ) ; <nl> - b . append ( " . " ) ; <nl> - throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; <nl> - } <nl> - boolean added = false ; <nl> - int count = getItemCount ( ) ; <nl> - if ( count = = 0 ) { <nl> - this . data . add ( item ) ; <nl> - added = true ; <nl> - } else <nl> - { <nl> - org . jfree . data . time . RegularTimePeriod last = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) ; <nl> - if ( ( item . getPeriod ( ) . compareTo ( last ) ) > 0 ) { <nl> - this . data . add ( item ) ; <nl> - added = true ; <nl> - } else <nl> - { <nl> - int index = java . util . Collections . binarySearch ( this . data , item ) ; <nl> - if ( index < 0 ) { <nl> - this . data . add ( ( ( - index ) - 1 ) , item ) ; <nl> - added = true ; <nl> - } else <nl> - { <nl> - java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; <nl> - b . append ( " You are attempting to add an observation for " ) ; <nl> - b . append ( " the time period " ) ; <nl> - b . append ( item . getPeriod ( ) . toString ( ) ) ; <nl> - b . append ( " but the series already contains an observation " ) ; <nl> - b . append ( " for that time period . Duplicates are not " ) ; <nl> - b . append ( " permitted . Try using the addOrUpdate ( ) method . " ) ; <nl> - throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - if ( added ) { <nl> - updateBoundsForAddedItem ( item ) ; <nl> - if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { <nl> - org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; <nl> - updateBoundsForRemovedItem ( d ) ; <nl> - } <nl> - removeAgedItems ( false ) ; <nl> - if ( notify ) { <nl> - fireSeriesChanged ( ) ; <nl> - } <nl> - } <nl> - } <nl> - public void add ( org . jfree . data . time . RegularTimePeriod period , double value ) { <nl> - add ( period , value , true ) ; <nl> - } <nl> - public void add ( org . jfree . data . time . RegularTimePeriod period , double value , boolean notify ) { <nl> - org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; <nl> - add ( item , notify ) ; <nl> - } <nl> - public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { <nl> - add ( period , value , true ) ; <nl> - } <nl> - public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value , boolean notify ) { <nl> - org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; <nl> - add ( item , notify ) ; <nl> - } <nl> - public void update ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { <nl> - org . jfree . data . time . TimeSeriesDataItem temp = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; <nl> - int index = java . util . Collections . binarySearch ( this . data , temp ) ; <nl> - if ( index < 0 ) { <nl> - throw new org . jfree . data . general . SeriesException ( ( " There is no existing value for the " + <nl> - " specified ' period ' . " ) ) ; <nl> - } <nl> - update ( index , value ) ; <nl> - } <nl> - public void update ( int index , java . lang . Number value ) { <nl> - org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; <nl> - boolean iterate = false ; <nl> - java . lang . Number oldYN = item . getValue ( ) ; <nl> - if ( oldYN ! = null ) { <nl> - double oldY = oldYN . doubleValue ( ) ; <nl> - if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { <nl> - iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; <nl> - } <nl> - } <nl> - item . setValue ( value ) ; <nl> - if ( iterate ) { <nl> - findBoundsByIteration ( ) ; <nl> - } else <nl> - if ( value ! = null ) { <nl> - double yy = value . doubleValue ( ) ; <nl> - this . minY = minIgnoreNaN ( this . minY , yy ) ; <nl> - this . maxY = maxIgnoreNaN ( this . maxY , yy ) ; <nl> - } <nl> - fireSeriesChanged ( ) ; <nl> - } <nl> - public org . jfree . data . time . TimeSeries addAndOrUpdate ( org . jfree . data . time . TimeSeries series ) { <nl> - org . jfree . data . time . TimeSeries overwritten = new org . jfree . data . time . TimeSeries ( ( " Overwritten values from : " + <nl> - ( getKey ( ) ) ) ) ; <nl> - for ( int i = 0 ; i < ( series . getItemCount ( ) ) ; i + + ) { <nl> - org . jfree . data . time . TimeSeriesDataItem item = series . getRawDataItem ( i ) ; <nl> - org . jfree . data . time . TimeSeriesDataItem oldItem = addOrUpdate ( item . getPeriod ( ) , <nl> - item . getValue ( ) ) ; <nl> - if ( oldItem ! = null ) { <nl> - overwritten . add ( oldItem ) ; <nl> - } <nl> - } <nl> - return overwritten ; <nl> - } <nl> - public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , <nl> - double value ) { <nl> - return addOrUpdate ( period , new java . lang . Double ( value ) ) ; <nl> - } <nl> - public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , <nl> - java . lang . Number value ) { <nl> - return addOrUpdate ( new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ) ; <nl> - } <nl> - public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . TimeSeriesDataItem item ) { <nl> - if ( item = = null ) { <nl> - throw new java . lang . IllegalArgumentException ( " Null ' period ' argument . " ) ; <nl> - } <nl> - java . lang . Class periodClass = item . getPeriod ( ) . getClass ( ) ; <nl> - if ( ( this . timePeriodClass ) = = null ) { <nl> - this . timePeriodClass = periodClass ; <nl> - } else <nl> - if ( ! ( this . timePeriodClass . equals ( periodClass ) ) ) { <nl> - java . lang . String msg = ( ( ( ( " You are trying to add data where the time " + <nl> - " period class is " ) + ( periodClass . getName ( ) ) ) + <nl> - " , but the TimeSeries is expecting an instance of " ) + <nl> - ( this . timePeriodClass . getName ( ) ) ) + " . " ; <nl> - throw new org . jfree . data . general . SeriesException ( msg ) ; <nl> - } <nl> - org . jfree . data . time . TimeSeriesDataItem overwritten = null ; <nl> - int index = java . util . Collections . binarySearch ( this . data , item ) ; <nl> - if ( index > = 0 ) { <nl> - org . jfree . data . time . TimeSeriesDataItem existing = <nl> - ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; <nl> - overwritten = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( existing . clone ( ) ) ) ; <nl> - boolean iterate = false ; <nl> - java . lang . Number oldYN = existing . getValue ( ) ; <nl> - double oldY = ( oldYN ! = null ) ? oldYN . doubleValue ( ) : java . lang . Double . NaN ; <nl> - if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { <nl> - iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; <nl> - } <nl> - existing . setValue ( item . getValue ( ) ) ; <nl> - if ( iterate ) { <nl> - findBoundsByIteration ( ) ; <nl> - } else <nl> - if ( ( item . getValue ( ) ) ! = null ) { <nl> - double yy = item . getValue ( ) . doubleValue ( ) ; <nl> - this . minY = minIgnoreNaN ( this . minY , yy ) ; <nl> - this . maxY = minIgnoreNaN ( this . maxY , yy ) ; <nl> - } <nl> - } else <nl> - { <nl> - item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; <nl> - this . data . add ( ( ( - index ) - 1 ) , item ) ; <nl> - updateBoundsForAddedItem ( item ) ; <nl> - if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { <nl> - org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; <nl> - updateBoundsForRemovedItem ( d ) ; <nl> - } <nl> - } <nl> - removeAgedItems ( false ) ; <nl> - fireSeriesChanged ( ) ; <nl> - return overwritten ; <nl> - } <nl> - public void removeAgedItems ( boolean notify ) { <nl> - if ( ( getItemCount ( ) ) > 1 ) { <nl> - long latest = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) . getSerialIndex ( ) ; <nl> - boolean removed = false ; <nl> - while ( ( latest - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > <nl> - ( this . maximumItemAge ) ) { <nl> - this . data . remove ( 0 ) ; <nl> - removed = true ; <nl> - } <nl> - if ( removed ) { <nl> - findBoundsByIteration ( ) ; <nl> - if ( notify ) { <nl> - fireSeriesChanged ( ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - public void removeAgedItems ( long latest , boolean notify ) { <nl> - if ( this . data . isEmpty ( ) ) { <nl> - return ; <nl> - } <nl> - long index = java . lang . Long . MAX_VALUE ; <nl> - try { <nl> - java . lang . reflect . Method m = org . jfree . data . time . RegularTimePeriod . class . getDeclaredMethod ( <nl> - " createInstance " , new java . lang . Class [ ] { java . lang . Class . class , java . util . Date . class , <nl> - java . util . TimeZone . class } ) ; <nl> - org . jfree . data . time . RegularTimePeriod newest = ( ( org . jfree . data . time . RegularTimePeriod ) ( m . invoke ( <nl> - this . timePeriodClass , new java . lang . Object [ ] { this . timePeriodClass , <nl> - new java . util . Date ( latest ) , java . util . TimeZone . getDefault ( ) } ) ) ) ; <nl> - index = newest . getSerialIndex ( ) ; <nl> - } <nl> - catch ( java . lang . NoSuchMethodException e ) { <nl> - e . printStackTrace ( ) ; <nl> - } <nl> - catch ( java . lang . IllegalAccessException e ) { <nl> - e . printStackTrace ( ) ; <nl> - } <nl> - catch ( java . lang . reflect . InvocationTargetException e ) { <nl> - e . printStackTrace ( ) ; <nl> - } <nl> - boolean removed = false ; <nl> - while ( ( ( getItemCount ( ) ) > 0 ) & & ( ( index - <nl> - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) ) { <nl> - this . data . remove ( 0 ) ; <nl> - removed = true ; <nl> - } <nl> - if ( removed ) { <nl> - findBoundsByIteration ( ) ; <nl> - if ( notify ) { <nl> - fireSeriesChanged ( ) ; <nl> - } <nl> - } <nl> - } <nl> - public void clear ( ) { <nl> - if ( ( this . data . size ( ) ) > 0 ) { <nl> - this . data . clear ( ) ; <nl> - this . timePeriodClass = null ; <nl> - this . minY = java . lang . Double . NaN ; <nl> - this . maxY = java . lang . Double . NaN ; <nl> - fireSeriesChanged ( ) ; <nl> - } <nl> - } <nl> - public void delete ( org . jfree . data . time . RegularTimePeriod period ) { <nl> - int index = getIndex ( period ) ; <nl> - if ( index > = 0 ) { <nl> - org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( <nl> - index ) ) ) ; <nl> - updateBoundsForRemovedItem ( item ) ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } public void add ( org . jfree . data . time . TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new java . lang . IllegalArgumentException ( " Null ' item ' argument . " ) ; } item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; java . lang . Class c = item . getPeriod ( ) . getClass ( ) ; if ( ( this . timePeriodClass ) = = null ) { this . timePeriodClass = c ; } else if ( ! ( this . timePeriodClass . equals ( c ) ) ) { java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; b . append ( " You are trying to add data where the time period class " ) ; b . append ( " is " ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( " , but the TimeSeries is expecting an instance of " ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( " . " ) ; throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; } boolean added = false ; int count = getItemCount ( ) ; if ( count = = 0 ) { this . data . add ( item ) ; added = true ; } else { org . jfree . data . time . RegularTimePeriod last = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) ; if ( ( item . getPeriod ( ) . compareTo ( last ) ) > 0 ) { this . data . add ( item ) ; added = true ; } else { int index = java . util . Collections . binarySearch ( this . data , item ) ; if ( index < 0 ) { this . data . add ( ( ( - index ) - 1 ) , item ) ; added = true ; } else { java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; b . append ( " You are attempting to add an observation for " ) ; b . append ( " the time period " ) ; b . append ( item . getPeriod ( ) . toString ( ) ) ; b . append ( " but the series already contains an observation " ) ; b . append ( " for that time period . Duplicates are not " ) ; b . append ( " permitted . Try using the addOrUpdate ( ) method . " ) ; throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; } } } if ( added ) { updateBoundsForAddedItem ( item ) ; if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; updateBoundsForRemovedItem ( d ) ; } removeAgedItems ( false ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } public void add ( org . jfree . data . time . RegularTimePeriod period , double value ) { add ( period , value , true ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , double value , boolean notify ) { org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { add ( period , value , true ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value , boolean notify ) { org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; } public void update ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { org . jfree . data . time . TimeSeriesDataItem temp = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; int index = java . util . Collections . binarySearch ( this . data , temp ) ; if ( index < 0 ) { throw new org . jfree . data . general . SeriesException ( ( " There is no existing value for the " + " specified ' period ' . " ) ) ; } update ( index , value ) ; } public void update ( int index , java . lang . Number value ) { org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; boolean iterate = false ; java . lang . Number oldYN = item . getValue ( ) ; if ( oldYN ! = null ) { double oldY = oldYN . doubleValue ( ) ; if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; } } item . setValue ( value ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( value ! = null ) { double yy = value . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = maxIgnoreNaN ( this . maxY , yy ) ; } fireSeriesChanged ( ) ; } public org . jfree . data . time . TimeSeries addAndOrUpdate ( org . jfree . data . time . TimeSeries series ) { org . jfree . data . time . TimeSeries overwritten = new org . jfree . data . time . TimeSeries ( ( " Overwritten values from : " + ( getKey ( ) ) ) ) ; for ( int i = 0 ; i < ( series . getItemCount ( ) ) ; i + + ) { org . jfree . data . time . TimeSeriesDataItem item = series . getRawDataItem ( i ) ; org . jfree . data . time . TimeSeriesDataItem oldItem = addOrUpdate ( item . getPeriod ( ) , item . getValue ( ) ) ; if ( oldItem ! = null ) { overwritten . add ( oldItem ) ; } } return overwritten ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , double value ) { return addOrUpdate ( period , new java . lang . Double ( value ) ) ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { return addOrUpdate ( new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ) ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . TimeSeriesDataItem item ) { if ( item = = null ) { throw new java . lang . IllegalArgumentException ( " Null ' period ' argument . " ) ; } java . lang . Class periodClass = item . getPeriod ( ) . getClass ( ) ; if ( ( this . timePeriodClass ) = = null ) { this . timePeriodClass = periodClass ; } else if ( ! ( this . timePeriodClass . equals ( periodClass ) ) ) { java . lang . String msg = ( ( ( ( " You are trying to add data where the time " + " period class is " ) + ( periodClass . getName ( ) ) ) + " , but the TimeSeries is expecting an instance of " ) + ( this . timePeriodClass . getName ( ) ) ) + " . " ; throw new org . jfree . data . general . SeriesException ( msg ) ; } org . jfree . data . time . TimeSeriesDataItem overwritten = null ; int index = java . util . Collections . binarySearch ( this . data , item ) ; if ( index > = 0 ) { org . jfree . data . time . TimeSeriesDataItem existing = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; overwritten = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( existing . clone ( ) ) ) ; boolean iterate = false ; java . lang . Number oldYN = existing . getValue ( ) ; double oldY = ( oldYN ! = null ) ? oldYN . doubleValue ( ) : java . lang . Double . NaN ; if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; } existing . setValue ( item . getValue ( ) ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( ( item . getValue ( ) ) ! = null ) { double yy = item . getValue ( ) . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = minIgnoreNaN ( this . maxY , yy ) ; } } else { item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; this . data . add ( ( ( - index ) - 1 ) , item ) ; updateBoundsForAddedItem ( item ) ; if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; updateBoundsForRemovedItem ( d ) ; } } removeAgedItems ( false ) ; fireSeriesChanged ( ) ; return overwritten ; } public void removeAgedItems ( boolean notify ) { if ( ( getItemCount ( ) ) > 1 ) { long latest = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) . getSerialIndex ( ) ; boolean removed = false ; while ( ( latest - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) { this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } } public void removeAgedItems ( long latest , boolean notify ) { if ( this . data . isEmpty ( ) ) { return ; } long index = java . lang . Long . MAX_VALUE ; try { java . lang . reflect . Method m = org . jfree . data . time . RegularTimePeriod . class . getDeclaredMethod ( " createInstance " , new java . lang . Class [ ] { java . lang . Class . class , java . util . Date . class , java . util . TimeZone . class } ) ; org . jfree . data . time . RegularTimePeriod newest = ( ( org . jfree . data . time . RegularTimePeriod ) ( m . invoke ( this . timePeriodClass , new java . lang . Object [ ] { this . timePeriodClass , new java . util . Date ( latest ) , java . util . TimeZone . getDefault ( ) } ) ) ) ; index = newest . getSerialIndex ( ) ; } catch ( java . lang . NoSuchMethodException e ) { e . printStackTrace ( ) ; } catch ( java . lang . IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { e . printStackTrace ( ) ; } boolean removed = false ; while ( ( ( getItemCount ( ) ) > 0 ) & & ( ( index - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) ) { this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } public void clear ( ) { if ( ( this . data . size ( ) ) > 0 ) { this . data . clear ( ) ; this . timePeriodClass = null ; this . minY = java . lang . Double . NaN ; this . maxY = java . lang . Double . NaN ; fireSeriesChanged ( ) ; } } public void delete ( org . jfree . data . time . RegularTimePeriod period ) { int index = getIndex ( period ) ; if ( index > = 0 ) { org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( index ) ) ) ; updateBoundsForRemovedItem ( item ) ; <nl> if ( this . data . isEmpty ( ) ) { <nl> this . timePeriodClass = null ; <nl> } <nl> 
0<ml>jGenProg_Closure-21_P_Patch_7_6.txt<ml>jGenProg_Closure-21_P_Patch_7_6.txt<ml>mmm  / tmp / jGenProg_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> ppp  / tmp / jGenProg_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> return ; <nl> } <nl> if ( n = = ( parent . getLastChild ( ) ) ) { <nl> - for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) { continue ; } <nl> - if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else <nl> - break ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> } <nl> } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { <nl> if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) { <nl> 
1<ml>jGenProg_Math-70_C_Patch_6_2.txt<ml>jGenProg_Math-70_C_Patch_6_2.txt<ml>mmm  / tmp / jGenProg_Defects4J_Math_70 / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolverjava <nl> ppp  / tmp / jGenProg_Defects4J_Math_70 / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolverjava <nl> public double solve ( final org . apache . commons . math . analysis . UnivariateRealFunction f , double min , double max , double initial ) throws <nl> - org . apache . commons . math . FunctionEvaluationException , org . apache . commons . math . MaxIterationsExceededException { <nl> - return solve ( min , max ) ; <nl> + org . apache . commons . math . FunctionEvaluationException , org . apache . commons . math . MaxIterationsExceededException { return solve ( f , min , max ) ; <nl> + <nl> } <nl> 
0<ml>jGenProg_Chart-7_P_Patch_36_28.txt<ml>jGenProg_Chart-7_P_Patch_36_28.txt<ml>mmm  / tmp / jGenProg_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava <nl> ppp  / tmp / jGenProg_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava <nl> public int getMaxMiddleIndex ( ) { <nl> - return this . maxMiddleIndex ; <nl> - } <nl> - public int getMinEndIndex ( ) { <nl> - return this . minEndIndex ; <nl> - } <nl> - public int getMaxEndIndex ( ) { <nl> - return this . maxEndIndex ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + return this . maxEndIndex ; } public int getMinEndIndex ( ) { return this . minEndIndex ; } public int getMaxEndIndex ( ) { return this . maxEndIndex ; <nl> } } <nl> \ No newline at end of file <nl> 
0<ml>Kali-A_Closure-132_P_Patch_41_33.txt<ml>Kali-A_Closure-132_P_Patch_41_33.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_132 / src / com / google / javascript / rhino / Node . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_132 / patches_w4ef / Patch_33 / patched / tmp / Kali_Defects4J_Closure_132 / src / com / google / javascript / rhino / Node . java 	 2018 - 12 - 01 <nl> } <nl> res = n . checkTreeEqualsImpl ( n2 ) ; <nl> if ( res ! = null ) { <nl> - return res ; <nl> + if ( true ) <nl> + return null ; <nl> + return res ; <nl> } <nl> } <nl> return res ; <nl> 
0<ml>Kali-A_Chart-26_P_Patch_27_27.txt<ml>Kali-A_Chart-26_P_Patch_27_27.txt<ml>mmm  / tmp / Kali_Defects4J_Chart_26 / source / org / jfree / chart / plot / CategoryPlot . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Chart_26 / patches_oc3p / Patch_27 / patched / tmp / Kali_Defects4J_Chart_26 / source / org / jfree / chart / plot / CategoryPlot . java 	 2018 - 12 - 01 <nl> / / record the plot area . . . <nl> if ( state = = null ) { <nl> - / / if the incoming state is null , no information will be passed <nl> + if ( true ) <nl> + return ; <nl> + / / if the incoming state is null , no information will be passed <nl> / / back to the caller - but we create a temporary state to record <nl> / / the plot area , since that is used later by the axes <nl> state = new PlotRenderingInfo ( null ) ; <nl> 
0<ml>Kali-A_Closure-15_P_Patch_23_15.txt<ml>Kali-A_Closure-15_P_Patch_23_15.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_15 / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_15 / patches_2nqc / Patch_1 / patched / tmp / Kali_Defects4J_Closure_15 / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java 	 2018 - 12 - 01 <nl> Predicates . <nl> < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , <nl> false ) ; <nl> - if ( pathCheck . somePathsSatisfyPredicate ( ) ) { <nl> + if ( true ) { <nl> return false ; <nl> } <nl> } <nl> 
0<ml>Kali-A_Closure-117_P_Patch_8_8.txt<ml>Kali-A_Closure-117_P_Patch_8_8.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_117 / src / com / google / javascript / jscomp / TypedScopeCreator . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_117 / patches_06en / Patch_3 / patched / tmp / Kali_Defects4J_Closure_117 / src / com / google / javascript / jscomp / TypedScopeCreator . java 	 2018 - 12 - 01 <nl> child . getLastChild ( ) ) ; <nl> break ; <nl> case Token . GETPROP : <nl> - maybeCollectMember ( child , child , null ) ; <nl> + { <nl> + if ( true ) <nl> + return ; <nl> + maybeCollectMember ( child , child , null ) ; <nl> + } <nl> break ; <nl> } <nl> } <nl> 
0<ml>Kali-A_Closure-119_P_Patch_9_9.txt<ml>Kali-A_Closure-119_P_Patch_9_9.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_119 / src / com / google / javascript / jscomp / CheckGlobalNames . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_119 / patches_15ui / Patch_2 / patched / tmp / Kali_Defects4J_Closure_119 / src / com / google / javascript / jscomp / CheckGlobalNames . java 	 2018 - 12 - 01 <nl> boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; <nl> if ( ! isDefined & & ! isTypedef ( ref ) ) { <nl> - if ( ! isGlobalExpr ) { <nl> + if ( false ) { <nl> reportRefToUndefinedName ( name , ref ) ; <nl> } <nl> } else if ( declaration ! = null & & <nl> 
0<ml>Kali-A_Closure-55_P_Patch_2_2.txt<ml>Kali-A_Closure-55_P_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_55 / src / com / google / javascript / jscomp / FunctionRewriter . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_55 / patches_u9rc / Patch_3 / patched / tmp / Kali_Defects4J_Closure_55 / src / com / google / javascript / jscomp / FunctionRewriter . java 	 2018 - 12 - 01 <nl> } <nl> Node helperCode = parseHelperCode ( reducer ) ; <nl> - if ( helperCode = = null ) { <nl> + if ( true ) { <nl> continue ; <nl> } <nl> 
1<ml>Kali-A_Math-50_C_Patch_2_2.txt<ml>Kali-A_Math-50_C_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_50 / patches_tjun / Patch_2 / patched / tmp / Kali_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2018 - 12 - 01 <nl> break ; <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> - if ( x = = x1 ) { <nl> + if ( false ) { <nl> x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> 
1<ml>Kali-A_Closure-126_C_Patch_4_4.txt<ml>Kali-A_Closure-126_C_Patch_4_4.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPoints . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_126 / patches_1em6 / Patch_4 / patched / tmp / Kali_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPoints . java 	 2018 - 12 - 01 <nl> * can cause problems if it changes the completion type of the finally <nl> * block . See ECMA 262 Sections 8 . 9 & 12 . 14 <nl> * / <nl> - if ( NodeUtil . hasFinally ( n ) ) { <nl> + if ( false ) { <nl> Node finallyBlock = n . getLastChild ( ) ; <nl> tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> } <nl> 
0<ml>Kali-A_Closure-122_P_Patch_1_1.txt<ml>Kali-A_Closure-122_P_Patch_1_1.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_122 / src / com / google / javascript / jscomp / parsing / IRFactory . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_122 / patches_y24k / Patch_1 / patched / tmp / Kali_Defects4J_Closure_122 / src / com / google / javascript / jscomp / parsing / IRFactory . java 	 2018 - 12 - 01 <nl> * Check to see if the given block comment looks like it should be JSDoc . <nl> * / <nl> private void handleBlockComment ( Comment comment ) { <nl> - if ( comment . getValue ( ) . indexOf ( " / * @ " ) ! = - 1 | | comment . getValue ( ) . indexOf ( " \ n * @ " ) ! = - 1 ) { <nl> + if ( true ) { <nl> errorReporter . warning ( <nl> SUSPICIOUS_COMMENT_WARNING , <nl> sourceName , <nl> 
0<ml>Kali-A_Math-31_P_Patch_12_12.txt<ml>Kali-A_Math-31_P_Patch_12_12.txt<ml>mmm  / tmp / Kali_Defects4J_Math_31 / src / main / java / org / apache / commons / math3 / util / ContinuedFraction . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_31 / patches_cawh / Patch_8 / patched / tmp / Kali_Defects4J_Math_31 / src / main / java / org / apache / commons / math3 / util / ContinuedFraction . java 	 2018 - 12 - 01 <nl> x ) ; <nl> } <nl> if ( Double . isNaN ( hN ) ) { <nl> - throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , <nl> + if ( true ) <nl> + return - 1 ; <nl> + throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , <nl> x ) ; <nl> } <nl> 
0<ml>Kali-A_Closure-1_P_Patch_4_4.txt<ml>Kali-A_Closure-1_P_Patch_4_4.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_1 / src / com / google / javascript / jscomp / RemoveUnusedVars . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_1 / patches_ddtc / Patch_4 / patched / tmp / Kali_Defects4J_Closure_1 / src / com / google / javascript / jscomp / RemoveUnusedVars . java 	 2018 - 12 - 01 <nl> Node lastArg ; <nl> while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { <nl> Var var = fnScope . getVar ( lastArg . getString ( ) ) ; <nl> - if ( ! referenced . contains ( var ) ) { <nl> + if ( false ) { <nl> argList . removeChild ( lastArg ) ; <nl> compiler . reportCodeChange ( ) ; <nl> } else { <nl> 
0<ml>Kali-A_Closure-64_P_Patch_43_43.txt<ml>Kali-A_Closure-64_P_Patch_43_43.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_64 / src / com / google / javascript / jscomp / StatementFusion . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_64 / patches_5224 / Patch_39 / patched / tmp / Kali_Defects4J_Closure_64 / src / com / google / javascript / jscomp / StatementFusion . java 	 2018 - 12 - 01 <nl> for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { <nl> if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { <nl> - return false ; <nl> + if ( true ) <nl> + return true ; <nl> + return false ; <nl> } <nl> } <nl> 
0<ml>Kali-A_Chart-25_P_Patch_6_6.txt<ml>Kali-A_Chart-25_P_Patch_6_6.txt<ml>mmm  / tmp / Kali_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Chart_25 / patches_d9xc / Patch_8 / patched / tmp / Kali_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2018 - 12 - 01 <nl> Number result = null ; <nl> MeanAndStandardDeviation masd <nl> = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; <nl> - if ( masd ! = null ) { <nl> + if ( false ) { <nl> result = masd . getMean ( ) ; <nl> } <nl> return result ; <nl> 
0<ml>Kali-A_Math-81_P_Patch_3_3.txt<ml>Kali-A_Math-81_P_Patch_3_3.txt<ml>mmm  / tmp / Kali_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_81 / patches_jirz / Patch_1 / patched / tmp / Kali_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2018 - 12 - 01 <nl> double b1 = work [ np - 2 ] ; <nl> double b2 = work [ np - 6 ] ; <nl> final double gam = dN2 ; <nl> - if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { <nl> + if ( true ) { <nl> return ; <nl> } <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> 
0<ml>Kali-A_Closure-33_P_Patch_2_2.txt<ml>Kali-A_Closure-33_P_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_33 / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_33 / patches_3qww / Patch_2 / patched / tmp / Kali_Defects4J_Closure_33 / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java 	 2018 - 12 - 01 <nl> if ( constraintObj . isRecordType ( ) ) { <nl> for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { <nl> JSType propType = constraintObj . getPropertyType ( prop ) ; <nl> - if ( ! isPropertyTypeDeclared ( prop ) ) { <nl> + if ( false ) { <nl> JSType typeToInfer = propType ; <nl> if ( ! hasProperty ( prop ) ) { <nl> typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) <nl> 
0<ml>Kali-A_Math-49_P_Patch_7_7.txt<ml>Kali-A_Math-49_P_Patch_7_7.txt<ml>mmm  / tmp / Kali_Defects4J_Math_49 / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_49 / patches_kb7n / Patch_7 / patched / tmp / Kali_Defects4J_Math_49 / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java 	 2018 - 12 - 01 <nl> / * * { @ inheritDoc } * / <nl> public void setEntry ( int index , double value ) { <nl> checkIndex ( index ) ; <nl> - if ( ! isDefaultValue ( value ) ) { <nl> + if ( true ) { <nl> entries . put ( index , value ) ; <nl> } else if ( entries . containsKey ( index ) ) { <nl> entries . remove ( index ) ; <nl> 
0<ml>Kali-A_Closure-125_P_Patch_2_2.txt<ml>Kali-A_Closure-125_P_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_125 / src / com / google / javascript / jscomp / type / SemanticReverseAbstractInterpreter . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_125 / patches_0osh / Patch_2 / patched / tmp / Kali_Defects4J_Closure_125 / src / com / google / javascript / jscomp / type / SemanticReverseAbstractInterpreter . java 	 2018 - 12 - 01 <nl> } <nl> case Token . SHEQ : <nl> - if ( outcome ) { <nl> + if ( false ) { <nl> return caseEquality ( condition , blindScope , SHEQ ) ; <nl> } else { <nl> return caseEquality ( condition , blindScope , SHNE ) ; <nl> 
0<ml>Kali-A_Closure-46_P_Patch_3_3.txt<ml>Kali-A_Closure-46_P_Patch_3_3.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordType . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_46 / patches_6jfz / Patch_3 / patched / tmp / Kali_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordType . java 	 2018 - 12 - 01 <nl> @ Override <nl> public JSType getLeastSupertype ( JSType that ) { <nl> - if ( ! that . isRecordType ( ) ) { <nl> + if ( true ) { <nl> return super . getLeastSupertype ( that ) ; <nl> } <nl> RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; <nl> 
0<ml>Kali-A_Math-95_P_Patch_27_27.txt<ml>Kali-A_Math-95_P_Patch_27_27.txt<ml>mmm  / tmp / Kali_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_95 / patches_wycb / Patch_25 / patched / tmp / Kali_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2018 - 12 - 01 <nl> * / <nl> protected double getInitialDomain ( double p ) { <nl> double ret ; <nl> - double d = getDenominatorDegreesOfFreedom ( ) ; <nl> + if ( true ) <nl> + return 0 ; <nl> + double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> return ret ; <nl> 
0<ml>Kali-A_Chart-1_P_Patch_16_16.txt<ml>Kali-A_Chart-1_P_Patch_16_16.txt<ml>mmm  / tmp / Kali_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Chart_1 / patches_1bmm / Patch_16 / patched / tmp / Kali_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2018 - 12 - 01 <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> + if ( false ) { <nl> return result ; <nl> } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> 
0<ml>Kali-A_Chart-5_P_Patch_2_2.txt<ml>Kali-A_Chart-5_P_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeries . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Chart_5 / patches_ifcn / Patch_2 / patched / tmp / Kali_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeries . java 	 2018 - 12 - 01 <nl> / / Collections . binarySearch ( ) and tells us where to insert the <nl> / / new item . . . otherwise it will be just - 1 and we should just <nl> / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> + if ( false ) { <nl> this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> } <nl> else { <nl> 
0<ml>Kali-A_Closure-67_P_Patch_4_4.txt<ml>Kali-A_Closure-67_P_Patch_4_4.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_67 / src / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_67 / patches_a6mz / Patch_6 / patched / tmp / Kali_Defects4J_Closure_67 / src / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2018 - 12 - 01 <nl> } <nl> } <nl> - if ( canRemove ) { <nl> + if ( false ) { <nl> declaration . remove ( ) ; <nl> changed = true ; <nl> } <nl> 
0<ml>Kali-A_Math-32_P_Patch_2_2.txt<ml>Kali-A_Math-32_P_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Math_32 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_32 / patches_r50i / Patch_2 / patched / tmp / Kali_Defects4J_Math_32 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java 	 2018 - 12 - 01 <nl> if ( v . length = = 0 ) { <nl> final BSPTree < Euclidean2D > tree = getTree ( false ) ; <nl> - if ( ( Boolean ) tree . getAttribute ( ) ) { <nl> + if ( false ) { <nl> / / the instance covers the whole space <nl> setSize ( Double . POSITIVE_INFINITY ) ; <nl> setBarycenter ( Vector2D . NaN ) ; <nl> 
0<ml>Kali-A_Math-80_P_Patch_13_13.txt<ml>Kali-A_Math-80_P_Patch_13_13.txt<ml>mmm  / tmp / Kali_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_80 / patches_8w5w / Patch_5 / patched / tmp / Kali_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2018 - 12 - 01 <nl> int j = 4 * n - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> + if ( true ) <nl> + return true ; <nl> + final double tmp = work [ i + k ] ; <nl> work [ i + k ] = work [ j - k ] ; <nl> work [ j - k ] = tmp ; <nl> } <nl> 
0<ml>Kali-A_Closure-130_P_Patch_1_1.txt<ml>Kali-A_Closure-130_P_Patch_1_1.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_130 / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_130 / patches_blm6 / Patch_2 / patched / tmp / Kali_Defects4J_Closure_130 / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java 	 2018 - 12 - 01 <nl> boolean firstReferenceIsAssigningDeclaration ( ) { <nl> int size = references . size ( ) ; <nl> - if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { <nl> + if ( false ) { <nl> return true ; <nl> } <nl> return false ; <nl> 
0<ml>Kali-A_Closure-59_P_Patch_39_39.txt<ml>Kali-A_Closure-59_P_Patch_39_39.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_59 / src / com / google / javascript / jscomp / DefaultPassConfig . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_59 / patches_z1hr / Patch_61 / patched / tmp / Kali_Defects4J_Closure_59 / src / com / google / javascript / jscomp / DefaultPassConfig . java 	 2018 - 12 - 01 <nl> if ( options . checkTypes & & <nl> ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) <nl> | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { <nl> - checks . add ( checkAccessControls ) ; <nl> + if ( true ) <nl> + return null ; <nl> + checks . add ( checkAccessControls ) ; <nl> } <nl> if ( options . checkGlobalNamesLevel . isOn ( ) ) { <nl> 
1<ml>Kali-A_Closure-115_C_Patch_2_2.txt<ml>Kali-A_Closure-115_C_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_115 / src / com / google / javascript / jscomp / FunctionInjector . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_115 / patches_nxsz / Patch_2 / patched / tmp / Kali_Defects4J_Closure_115 / src / com / google / javascript / jscomp / FunctionInjector . java 	 2018 - 12 - 01 <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> - if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> + if ( false ) { <nl> return CanInlineResult . NO ; <nl> } <nl> / / Check for arguments that are evaluated more than once . <nl> 
0<ml>Kali-A_Math-84_P_Patch_3_3.txt<ml>Kali-A_Math-84_P_Patch_3_3.txt<ml>mmm  / tmp / Kali_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_84 / patches_sijd / Patch_1 / patched / tmp / Kali_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2018 - 12 - 01 <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( comparator . compare ( contracted , best ) < 0 ) { <nl> + if ( true ) { <nl> / / accept the contracted simplex <nl> / / check convergence <nl> 
0<ml>Kali-A_Closure-78_P_Patch_25_25.txt<ml>Kali-A_Closure-78_P_Patch_25_25.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_78 / src / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_78 / patches_eybj / Patch_25 / patched / tmp / Kali_Defects4J_Closure_78 / src / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2018 - 12 - 01 <nl> * / <nl> protected void error ( DiagnosticType diagnostic , Node n ) { <nl> JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; <nl> - currentTraversal . getCompiler ( ) . report ( error ) ; <nl> + if ( true ) <nl> + return ; <nl> + currentTraversal . getCompiler ( ) . report ( error ) ; <nl> } <nl> / * * <nl> 
0<ml>Kali-A_Chart-15_P_Patch_17_17.txt<ml>Kali-A_Chart-15_P_Patch_17_17.txt<ml>mmm  / tmp / Kali_Defects4J_Chart_15 / source / org / jfree / chart / plot / PiePlot3D . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Chart_15 / patches_dkr6 / Patch_17 / patched / tmp / Kali_Defects4J_Chart_15 / source / org / jfree / chart / plot / PiePlot3D . java 	 2018 - 12 - 01 <nl> linkH = 2 * min ; <nl> } <nl> - PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; <nl> + if ( true ) <nl> + return ; <nl> + PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; <nl> / / the link area defines the dog leg points for the linking lines to <nl> / / the labels <nl> 
0<ml>Kali-A_Closure-124_P_Patch_1_1.txt<ml>Kali-A_Closure-124_P_Patch_1_1.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_124 / src / com / google / javascript / jscomp / ExploitAssigns . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_124 / patches_8g7z / Patch_1 / patched / tmp / Kali_Defects4J_Closure_124 / src / com / google / javascript / jscomp / ExploitAssigns . java 	 2018 - 12 - 01 <nl> Preconditions . checkArgument ( node . isGetProp ( ) ) ; <nl> node = node . getFirstChild ( ) ; <nl> - if ( node . isName ( ) <nl> - & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { <nl> + if ( true ) { <nl> return false ; <nl> } <nl> 
0<ml>Kali-A_Closure-7_P_Patch_1_1.txt<ml>Kali-A_Closure-7_P_Patch_1_1.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_7 / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_7 / patches_e972 / Patch_11 / patched / tmp / Kali_Defects4J_Closure_7 / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java 	 2018 - 12 - 01 <nl> if ( restricted = = null ) { <nl> restricted = restrictedAlternate ; <nl> } else { <nl> - restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; <nl> + if ( true ) <nl> + return null ; <nl> + restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; <nl> } <nl> } <nl> } <nl> 
0<ml>Kali-A_Closure-68_P_Patch_17_17.txt<ml>Kali-A_Closure-68_P_Patch_17_17.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_68 / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_68 / patches_9acd / Patch_3 / patched / tmp / Kali_Defects4J_Closure_68 / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java 	 2018 - 12 - 01 <nl> return true ; <nl> case EOF : <nl> - / / discard any accumulated information <nl> - jsdocBuilder . build ( null ) ; <nl> + { <nl> + if ( true ) <nl> + return true ; <nl> + jsdocBuilder . build ( null ) ; <nl> + } <nl> parser . addParserWarning ( " msg . unexpected . eof " , <nl> stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> checkExtendedTypes ( extendedTypes ) ; <nl> 
0<ml>Kali-A_Closure-22_P_Patch_4_4.txt<ml>Kali-A_Closure-22_P_Patch_4_4.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_22 / patches_2bcl / Patch_4 / patched / tmp / Kali_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2018 - 12 - 01 <nl> / / This no - op statement was there so that JSDoc information could <nl> / / be attached to the name . This check should not complain about it . <nl> - if ( n = = parent . getLastChild ( ) ) { <nl> + if ( false ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) <nl> 
0<ml>Kali-A_Closure-133_P_Patch_17_17.txt<ml>Kali-A_Closure-133_P_Patch_17_17.txt<ml>deleted file mode 100644 <nl> mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp  / dev / null <nl> - / * <nl> - * Copyright 2007 The Closure Compiler Authors . <nl> - * <nl> - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> - * you may not use this file except in compliance with the License . <nl> - * You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package com . google . javascript . jscomp . parsing ; <nl> - <nl> - import com . google . common . base . Preconditions ; <nl> - import com . google . common . base . Splitter ; <nl> - import com . google . common . collect . ImmutableSet ; <nl> - import com . google . common . collect . Lists ; <nl> - import com . google . common . collect . Sets ; <nl> - import com . google . javascript . jscomp . parsing . Config . LanguageMode ; <nl> - import com . google . javascript . rhino . IR ; <nl> - import com . google . javascript . rhino . JSDocInfo ; <nl> - import com . google . javascript . rhino . JSDocInfo . Visibility ; <nl> - import com . google . javascript . rhino . JSDocInfoBuilder ; <nl> - import com . google . javascript . rhino . JSTypeExpression ; <nl> - import com . google . javascript . rhino . Node ; <nl> - import com . google . javascript . rhino . ScriptRuntime ; <nl> - import com . google . javascript . rhino . Token ; <nl> - import com . google . javascript . rhino . head . ErrorReporter ; <nl> - import com . google . javascript . rhino . head . ast . Comment ; <nl> - import com . google . javascript . rhino . jstype . StaticSourceFile ; <nl> - <nl> - import java . util . HashSet ; <nl> - import java . util . List ; <nl> - import java . util . Map ; <nl> - import java . util . Set ; <nl> - <nl> - / * * <nl> - * A parser for JSDoc comments . <nl> - * <nl> - * / <nl> - / / TODO ( nicksantos ) : Unify all the JSDocInfo stuff into one package , instead of <nl> - / / spreading it across multiple packages . <nl> - public final class JsDocInfoParser { <nl> - <nl> - private final JsDocTokenStream stream ; <nl> - private final JSDocInfoBuilder jsdocBuilder ; <nl> - private final StaticSourceFile sourceFile ; <nl> - private final Node associatedNode ; <nl> - private final ErrorReporter errorReporter ; <nl> - private final ErrorReporterParser parser = new ErrorReporterParser ( ) ; <nl> - <nl> - / / Use a template node for properties set on all nodes to minimize the <nl> - / / memory footprint associated with these ( similar to IRFactory ) . <nl> - private final Node templateNode ; <nl> - <nl> - private class ErrorReporterParser { <nl> - void addParserWarning ( String messageId , String messageArg , int lineno , <nl> - int charno ) { <nl> - errorReporter . warning ( ScriptRuntime . getMessage1 ( messageId , messageArg ) , <nl> - getSourceName ( ) , lineno , null , charno ) ; <nl> - } <nl> - <nl> - void addParserWarning ( String messageId , int lineno , int charno ) { <nl> - errorReporter . warning ( ScriptRuntime . getMessage0 ( messageId ) , <nl> - getSourceName ( ) , lineno , null , charno ) ; <nl> - } <nl> - <nl> - void addTypeWarning ( String messageId , String messageArg , int lineno , <nl> - int charno ) { <nl> - errorReporter . warning ( <nl> - " Bad type annotation . " + <nl> - ScriptRuntime . getMessage1 ( messageId , messageArg ) , <nl> - getSourceName ( ) , lineno , null , charno ) ; <nl> - } <nl> - <nl> - void addTypeWarning ( String messageId , int lineno , int charno ) { <nl> - errorReporter . warning ( <nl> - " Bad type annotation . " + <nl> - ScriptRuntime . getMessage0 ( messageId ) , <nl> - getSourceName ( ) , lineno , null , charno ) ; <nl> - } <nl> - } <nl> - <nl> - / / The DocInfo with the fileoverview tag for the whole file . <nl> - private JSDocInfo fileOverviewJSDocInfo = null ; <nl> - private State state ; <nl> - <nl> - private final Map < String , Annotation > annotationNames ; <nl> - private final Set < String > suppressionNames ; <nl> - static private final Set < String > modifiesAnnotationKeywords = <nl> - ImmutableSet . < String > of ( " this " , " arguments " ) ; <nl> - <nl> - private Node . FileLevelJsDocBuilder fileLevelJsDocBuilder ; <nl> - <nl> - / * * <nl> - * Sets the JsDocBuilder for the file - level ( root ) node of this parse . The <nl> - * parser uses the builder to append any preserve annotations it encounters <nl> - * in JsDoc comments . <nl> - * <nl> - * @ param fileLevelJsDocBuilder <nl> - * / <nl> - void setFileLevelJsDocBuilder ( <nl> - Node . FileLevelJsDocBuilder fileLevelJsDocBuilder ) { <nl> - this . fileLevelJsDocBuilder = fileLevelJsDocBuilder ; <nl> - } <nl> - <nl> - / * * <nl> - * Sets the file overview JSDocInfo , in order to warn about multiple uses of <nl> - * the @ fileoverview tag in a file . <nl> - * / <nl> - void setFileOverviewJSDocInfo ( JSDocInfo fileOverviewJSDocInfo ) { <nl> - this . fileOverviewJSDocInfo = fileOverviewJSDocInfo ; <nl> - } <nl> - <nl> - private enum State { <nl> - SEARCHING_ANNOTATION , <nl> - SEARCHING_NEWLINE , <nl> - NEXT_IS_ANNOTATION <nl> - } <nl> - <nl> - JsDocInfoParser ( JsDocTokenStream stream , <nl> - Comment commentNode , <nl> - Node associatedNode , <nl> - Config config , <nl> - ErrorReporter errorReporter ) { <nl> - this . stream = stream ; <nl> - this . associatedNode = associatedNode ; <nl> - <nl> - / / Sometimes this will be null in tests . <nl> - this . sourceFile = associatedNode = = null <nl> - ? null : associatedNode . getStaticSourceFile ( ) ; <nl> - <nl> - this . jsdocBuilder = new JSDocInfoBuilder ( config . parseJsDocDocumentation ) ; <nl> - if ( commentNode ! = null ) { <nl> - this . jsdocBuilder . recordOriginalCommentString ( commentNode . getValue ( ) ) ; <nl> - } <nl> - this . annotationNames = config . annotationNames ; <nl> - this . suppressionNames = config . suppressionNames ; <nl> - <nl> - this . errorReporter = errorReporter ; <nl> - this . templateNode = this . createTemplateNode ( ) ; <nl> - } <nl> - <nl> - private String getSourceName ( ) { <nl> - return sourceFile = = null ? null : sourceFile . getName ( ) ; <nl> - } <nl> - <nl> - public JSDocInfo parseInlineTypeDoc ( ) { <nl> - Node typeAst = parseAndRecordTypeNode ( next ( ) ) ; <nl> - JSTypeExpression expr = createJSTypeExpression ( typeAst ) ; <nl> - if ( expr ! = null ) { <nl> - jsdocBuilder . recordType ( expr ) ; <nl> - return retrieveAndResetParsedJSDocInfo ( ) ; <nl> - } <nl> - return null ; <nl> - } <nl> - <nl> - / * * <nl> - * Parses a string containing a JsDoc type declaration , returning the <nl> - * type if the parsing succeeded or { @ code null } if it failed . <nl> - * / <nl> - public static Node parseTypeString ( String typeString ) { <nl> - Config config = new Config ( <nl> - Sets . < String > newHashSet ( ) , <nl> - Sets . < String > newHashSet ( ) , <nl> - false , <nl> - LanguageMode . ECMASCRIPT3 , <nl> - false ) ; <nl> - JsDocInfoParser parser = new JsDocInfoParser ( <nl> - new JsDocTokenStream ( typeString ) , <nl> - null , <nl> - null , <nl> - config , <nl> - NullErrorReporter . forNewRhino ( ) ) ; <nl> - <nl> - return parser . parseTopLevelTypeExpression ( parser . next ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Parses a { @ link JSDocInfo } object . This parsing method reads all tokens <nl> - * returned by the { @ link JsDocTokenStream # getJsDocToken ( ) } method until the <nl> - * { @ link JsDocToken # EOC } is returned . <nl> - * <nl> - * @ return { @ code true } if JSDoc information was correctly parsed , <nl> - * { @ code false } otherwise <nl> - * / <nl> - @ SuppressWarnings ( " incomplete - switch " ) <nl> - boolean parse ( ) { <nl> - int lineno ; <nl> - int charno ; <nl> - <nl> - / / JSTypes are represented as Rhino AST nodes , and then resolved later . <nl> - JSTypeExpression type ; <nl> - <nl> - state = State . SEARCHING_ANNOTATION ; <nl> - skipEOLs ( ) ; <nl> - <nl> - JsDocToken token = next ( ) ; <nl> - <nl> - List < ExtendedTypeInfo > extendedTypes = Lists . newArrayList ( ) ; <nl> - <nl> - / / Always record that we have a comment . <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo blockInfo = extractBlockComment ( token ) ; <nl> - token = blockInfo . token ; <nl> - if ( ! blockInfo . string . isEmpty ( ) ) { <nl> - jsdocBuilder . recordBlockDescription ( blockInfo . string ) ; <nl> - } <nl> - } else { <nl> - if ( token ! = JsDocToken . ANNOTATION & & <nl> - token ! = JsDocToken . EOC ) { <nl> - / / Mark that there was a description , but don ' t bother marking <nl> - / / what it was . <nl> - jsdocBuilder . recordBlockDescription ( " " ) ; <nl> - } <nl> - } <nl> - <nl> - / / Parse the actual JsDoc . <nl> - retry : for ( ; ; ) { <nl> - switch ( token ) { <nl> - case ANNOTATION : <nl> - if ( state = = State . SEARCHING_ANNOTATION ) { <nl> - state = State . SEARCHING_NEWLINE ; <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - <nl> - String annotationName = stream . getString ( ) ; <nl> - Annotation annotation = annotationNames . get ( annotationName ) ; <nl> - if ( annotation = = null ) { <nl> - parser . addParserWarning ( " msg . bad . jsdoc . tag " , annotationName , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - / / Mark the beginning of the annotation . <nl> - jsdocBuilder . markAnnotation ( annotationName , lineno , charno ) ; <nl> - <nl> - switch ( annotation ) { <nl> - case NG_INJECT : <nl> - if ( jsdocBuilder . isNgInjectRecorded ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . nginject . extra " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - jsdocBuilder . recordNgInject ( true ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case AUTHOR : <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo authorInfo = extractSingleLineBlock ( ) ; <nl> - String author = authorInfo . string ; <nl> - <nl> - if ( author . length ( ) = = 0 ) { <nl> - parser . addParserWarning ( " msg . jsdoc . authormissing " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - jsdocBuilder . addAuthor ( author ) ; <nl> - } <nl> - token = authorInfo . token ; <nl> - } else { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case CONSISTENTIDGENERATOR : <nl> - if ( ! jsdocBuilder . recordConsistentIdGenerator ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . consistidgen " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case STRUCT : <nl> - if ( ! jsdocBuilder . recordStruct ( ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . incompat . type " , <nl> - stream . getLineno ( ) , <nl> - stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case DICT : <nl> - if ( ! jsdocBuilder . recordDict ( ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . incompat . type " , <nl> - stream . getLineno ( ) , <nl> - stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case CONSTRUCTOR : <nl> - if ( ! jsdocBuilder . recordConstructor ( ) ) { <nl> - if ( jsdocBuilder . isInterfaceRecorded ( ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . interface . constructor " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - parser . addTypeWarning ( " msg . jsdoc . incompat . type " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case DEPRECATED : <nl> - if ( ! jsdocBuilder . recordDeprecated ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . deprecated " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - / / Find the reason / description , if any . <nl> - ExtractionInfo reasonInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> - <nl> - String reason = reasonInfo . string ; <nl> - <nl> - if ( reason . length ( ) > 0 ) { <nl> - jsdocBuilder . recordDeprecationReason ( reason ) ; <nl> - } <nl> - <nl> - token = reasonInfo . token ; <nl> - continue retry ; <nl> - <nl> - case INTERFACE : <nl> - if ( ! jsdocBuilder . recordInterface ( ) ) { <nl> - if ( jsdocBuilder . isConstructorRecorded ( ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . interface . constructor " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - parser . addTypeWarning ( " msg . jsdoc . incompat . type " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case DESC : <nl> - if ( jsdocBuilder . isDescriptionRecorded ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . desc . extra " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - } else { <nl> - ExtractionInfo descriptionInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> - <nl> - String description = descriptionInfo . string ; <nl> - <nl> - jsdocBuilder . recordDescription ( description ) ; <nl> - token = descriptionInfo . token ; <nl> - continue retry ; <nl> - } <nl> - <nl> - case FILE_OVERVIEW : <nl> - String fileOverview = " " ; <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo fileOverviewInfo = <nl> - extractMultilineTextualBlock ( token , <nl> - WhitespaceOption . TRIM ) ; <nl> - <nl> - fileOverview = fileOverviewInfo . string ; <nl> - <nl> - token = fileOverviewInfo . token ; <nl> - } else { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - } <nl> - <nl> - if ( ! jsdocBuilder . recordFileOverview ( fileOverview ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . fileoverview . extra " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case LICENSE : <nl> - case PRESERVE : <nl> - ExtractionInfo preserveInfo = <nl> - extractMultilineTextualBlock ( token , <nl> - WhitespaceOption . PRESERVE ) ; <nl> - <nl> - String preserve = preserveInfo . string ; <nl> - <nl> - if ( preserve . length ( ) > 0 ) { <nl> - if ( fileLevelJsDocBuilder ! = null ) { <nl> - fileLevelJsDocBuilder . append ( preserve ) ; <nl> - } <nl> - } <nl> - <nl> - token = preserveInfo . token ; <nl> - continue retry ; <nl> - <nl> - case ENUM : <nl> - token = next ( ) ; <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - <nl> - type = null ; <nl> - if ( token ! = JsDocToken . EOL & & token ! = JsDocToken . EOC ) { <nl> - type = createJSTypeExpression ( <nl> - parseAndRecordTypeNode ( token ) ) ; <nl> - } <nl> - <nl> - if ( type = = null ) { <nl> - type = createJSTypeExpression ( newStringNode ( " number " ) ) ; <nl> - } <nl> - if ( ! jsdocBuilder . recordEnumParameterType ( type ) ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . incompat . type " , lineno , charno ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - continue retry ; <nl> - <nl> - case EXPORT : <nl> - if ( ! jsdocBuilder . recordExport ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . export " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case EXPOSE : <nl> - if ( ! jsdocBuilder . recordExpose ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . expose " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case EXTERNS : <nl> - if ( ! jsdocBuilder . recordExterns ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . externs " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case JAVA_DISPATCH : <nl> - if ( ! jsdocBuilder . recordJavaDispatch ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . javadispatch " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case EXTENDS : <nl> - case IMPLEMENTS : <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - boolean matchingRc = false ; <nl> - <nl> - if ( token = = JsDocToken . LC ) { <nl> - token = next ( ) ; <nl> - matchingRc = true ; <nl> - } <nl> - <nl> - if ( token = = JsDocToken . STRING ) { <nl> - Node typeNode = parseAndRecordTypeNameNode ( <nl> - token , lineno , charno , matchingRc ) ; <nl> - <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - <nl> - typeNode = wrapNode ( Token . BANG , typeNode ) ; <nl> - type = createJSTypeExpression ( typeNode ) ; <nl> - <nl> - if ( annotation = = Annotation . EXTENDS ) { <nl> - / / record the extended type , check later <nl> - extendedTypes . add ( new ExtendedTypeInfo ( <nl> - type , stream . getLineno ( ) , stream . getCharno ( ) ) ) ; <nl> - } else { <nl> - Preconditions . checkState ( <nl> - annotation = = Annotation . IMPLEMENTS ) ; <nl> - if ( ! jsdocBuilder . recordImplementedInterface ( type ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . implements . duplicate " , <nl> - lineno , charno ) ; <nl> - } <nl> - } <nl> - token = next ( ) ; <nl> - if ( matchingRc ) { <nl> - if ( token ! = JsDocToken . RC ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . missing . rc " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } else if ( token ! = JsDocToken . EOL & & <nl> - token ! = JsDocToken . EOF & & token ! = JsDocToken . EOC ) { <nl> - parser . addTypeWarning ( " msg . end . annotation . expected " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } else { <nl> - parser . addTypeWarning ( " msg . no . type . name " , lineno , charno ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - continue retry ; <nl> - <nl> - case HIDDEN : <nl> - if ( ! jsdocBuilder . recordHiddenness ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . hidden " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case LENDS : <nl> - skipEOLs ( ) ; <nl> - <nl> - matchingRc = false ; <nl> - if ( match ( JsDocToken . LC ) ) { <nl> - token = next ( ) ; <nl> - matchingRc = true ; <nl> - } <nl> - <nl> - if ( match ( JsDocToken . STRING ) ) { <nl> - token = next ( ) ; <nl> - if ( ! jsdocBuilder . recordLends ( stream . getString ( ) ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . lends . incompatible " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } else { <nl> - parser . addTypeWarning ( " msg . jsdoc . lends . missing " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - if ( matchingRc & & ! match ( JsDocToken . RC ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . missing . rc " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case MEANING : <nl> - ExtractionInfo meaningInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> - String meaning = meaningInfo . string ; <nl> - token = meaningInfo . token ; <nl> - if ( ! jsdocBuilder . recordMeaning ( meaning ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . meaning . extra " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case NO_ALIAS : <nl> - if ( ! jsdocBuilder . recordNoAlias ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . noalias " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case NO_COMPILE : <nl> - if ( ! jsdocBuilder . recordNoCompile ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . nocompile " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case NO_TYPE_CHECK : <nl> - if ( ! jsdocBuilder . recordNoTypeCheck ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . nocheck " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case NOT_IMPLEMENTED : <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case INHERIT_DOC : <nl> - case OVERRIDE : <nl> - if ( ! jsdocBuilder . recordOverride ( ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . override " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case THROWS : <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - type = null ; <nl> - <nl> - if ( token = = JsDocToken . LC ) { <nl> - type = createJSTypeExpression ( <nl> - parseAndRecordTypeNode ( token ) ) ; <nl> - <nl> - if ( type = = null ) { <nl> - / / parsing error reported during recursive descent <nl> - / / recovering parsing <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - } <nl> - } <nl> - <nl> - / / * Update * the token to that after the type annotation . <nl> - token = current ( ) ; <nl> - <nl> - / / Save the throw type . <nl> - jsdocBuilder . recordThrowType ( type ) ; <nl> - <nl> - / / Find the throw ' s description ( if applicable ) . <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo descriptionInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> - <nl> - String description = descriptionInfo . string ; <nl> - <nl> - if ( description . length ( ) > 0 ) { <nl> - jsdocBuilder . recordThrowDescription ( type , description ) ; <nl> - } <nl> - <nl> - token = descriptionInfo . token ; <nl> - } else { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case PARAM : <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - type = null ; <nl> - <nl> - if ( token = = JsDocToken . LC ) { <nl> - type = createJSTypeExpression ( <nl> - parseAndRecordParamTypeNode ( token ) ) ; <nl> - <nl> - if ( type = = null ) { <nl> - / / parsing error reported during recursive descent <nl> - / / recovering parsing <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - } <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - } <nl> - <nl> - String name = null ; <nl> - boolean isBracketedParam = JsDocToken . LB = = token ; <nl> - if ( isBracketedParam ) { <nl> - token = next ( ) ; <nl> - } <nl> - <nl> - if ( JsDocToken . STRING ! = token ) { <nl> - parser . addTypeWarning ( " msg . missing . variable . name " , <nl> - lineno , charno ) ; <nl> - } else { <nl> - name = stream . getString ( ) ; <nl> - <nl> - if ( isBracketedParam ) { <nl> - token = next ( ) ; <nl> - <nl> - / / Throw out JsDocToolkit ' s " default " parameter <nl> - / / annotation . It makes no sense under our type <nl> - / / system . <nl> - if ( JsDocToken . EQUALS = = token ) { <nl> - token = next ( ) ; <nl> - if ( JsDocToken . STRING = = token ) { <nl> - token = next ( ) ; <nl> - } <nl> - } <nl> - <nl> - if ( JsDocToken . RB ! = token ) { <nl> - reportTypeSyntaxWarning ( " msg . jsdoc . missing . rb " ) ; <nl> - } else if ( type ! = null ) { <nl> - / / Make the type expression optional , if it isn ' t <nl> - / / already . <nl> - type = JSTypeExpression . makeOptionalArg ( type ) ; <nl> - } <nl> - } <nl> - <nl> - / / If the param name has a DOT in it , just throw it out <nl> - / / quietly . We do not handle the JsDocToolkit method <nl> - / / for handling properties of params . <nl> - if ( name . indexOf ( ' . ' ) > - 1 ) { <nl> - name = null ; <nl> - } else if ( ! jsdocBuilder . recordParameter ( name , type ) ) { <nl> - if ( jsdocBuilder . hasParameter ( name ) ) { <nl> - parser . addTypeWarning ( " msg . dup . variable . name " , name , <nl> - lineno , charno ) ; <nl> - } else { <nl> - parser . addTypeWarning ( " msg . jsdoc . incompat . type " , name , <nl> - lineno , charno ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( name = = null ) { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - continue retry ; <nl> - } <nl> - <nl> - jsdocBuilder . markName ( name , sourceFile , lineno , charno ) ; <nl> - <nl> - / / Find the parameter ' s description ( if applicable ) . <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo paramDescriptionInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> - <nl> - String paramDescription = paramDescriptionInfo . string ; <nl> - <nl> - if ( paramDescription . length ( ) > 0 ) { <nl> - jsdocBuilder . recordParameterDescription ( name , <nl> - paramDescription ) ; <nl> - } <nl> - <nl> - token = paramDescriptionInfo . token ; <nl> - } else { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case PRESERVE_TRY : <nl> - if ( ! jsdocBuilder . recordPreserveTry ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . preservertry " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case NO_SHADOW : <nl> - if ( ! jsdocBuilder . recordNoShadow ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . noshadow " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case NO_SIDE_EFFECTS : <nl> - if ( ! jsdocBuilder . recordNoSideEffects ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . nosideeffects " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case MODIFIES : <nl> - token = parseModifiesTag ( next ( ) ) ; <nl> - continue retry ; <nl> - <nl> - case IMPLICIT_CAST : <nl> - if ( ! jsdocBuilder . recordImplicitCast ( ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . implicitcast " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case SEE : <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo referenceInfo = extractSingleLineBlock ( ) ; <nl> - String reference = referenceInfo . string ; <nl> - <nl> - if ( reference . length ( ) = = 0 ) { <nl> - parser . addParserWarning ( " msg . jsdoc . seemissing " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - jsdocBuilder . addReference ( reference ) ; <nl> - } <nl> - <nl> - token = referenceInfo . token ; <nl> - } else { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case STABLEIDGENERATOR : <nl> - if ( ! jsdocBuilder . recordStableIdGenerator ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . stableidgen " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case SUPPRESS : <nl> - token = parseSuppressTag ( next ( ) ) ; <nl> - continue retry ; <nl> - <nl> - case TEMPLATE : { <nl> - ExtractionInfo templateInfo = extractSingleLineBlock ( ) ; <nl> - List < String > names = Lists . newArrayList ( <nl> - Splitter . on ( ' , ' ) <nl> - . trimResults ( ) <nl> - . split ( templateInfo . string ) ) ; <nl> - <nl> - if ( names . size ( ) = = 0 | | names . get ( 0 ) . length ( ) = = 0 ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . templatemissing " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else if ( ! jsdocBuilder . recordTemplateTypeNames ( names ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . template . at . most . once " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - token = templateInfo . token ; <nl> - continue retry ; <nl> - } <nl> - <nl> - case CLASS_TEMPLATE : { <nl> - ExtractionInfo classTemplateInfo = extractSingleLineBlock ( ) ; <nl> - List < String > names = Lists . newArrayList ( <nl> - Splitter . on ( ' , ' ) <nl> - . trimResults ( ) <nl> - . split ( classTemplateInfo . string ) ) ; <nl> - <nl> - if ( names . size ( ) = = 0 | | names . get ( 0 ) . length ( ) = = 0 ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . classtemplate . missing . type . name " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else if ( ! jsdocBuilder . recordClassTemplateTypeNames ( names ) ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . classtemplate . at . most . once " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - token = classTemplateInfo . token ; <nl> - continue retry ; <nl> - } <nl> - <nl> - case IDGENERATOR : <nl> - if ( ! jsdocBuilder . recordIdGenerator ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . idgen " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - <nl> - case VERSION : <nl> - ExtractionInfo versionInfo = extractSingleLineBlock ( ) ; <nl> - String version = versionInfo . string ; <nl> - <nl> - if ( version . length ( ) = = 0 ) { <nl> - parser . addParserWarning ( " msg . jsdoc . versionmissing " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - if ( ! jsdocBuilder . recordVersion ( version ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . extraversion " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - token = versionInfo . token ; <nl> - continue retry ; <nl> - <nl> - case CONSTANT : <nl> - case DEFINE : <nl> - case RETURN : <nl> - case PRIVATE : <nl> - case PROTECTED : <nl> - case PUBLIC : <nl> - case THIS : <nl> - case TYPE : <nl> - case TYPEDEF : <nl> - lineno = stream . getLineno ( ) ; <nl> - charno = stream . getCharno ( ) ; <nl> - <nl> - Node typeNode = null ; <nl> - boolean hasType = lookAheadForTypeAnnotation ( ) ; <nl> - boolean isAlternateTypeAnnotation = <nl> - ( annotation = = Annotation . PRIVATE | | <nl> - annotation = = Annotation . PROTECTED | | <nl> - annotation = = Annotation . PUBLIC | | <nl> - annotation = = Annotation . CONSTANT ) ; <nl> - boolean canSkipTypeAnnotation = <nl> - ( isAlternateTypeAnnotation | | <nl> - annotation = = Annotation . RETURN ) ; <nl> - type = null ; <nl> - if ( hasType | | ! canSkipTypeAnnotation ) { <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - typeNode = parseAndRecordTypeNode ( token ) ; <nl> - <nl> - if ( annotation = = Annotation . THIS ) { <nl> - typeNode = wrapNode ( Token . BANG , typeNode ) ; <nl> - } <nl> - type = createJSTypeExpression ( typeNode ) ; <nl> - } <nl> - <nl> - / / The error was reported during recursive descent <nl> - / / recovering parsing <nl> - boolean hasError = type = = null & & ! canSkipTypeAnnotation ; <nl> - if ( ! hasError ) { <nl> - / / Record types for @ type . <nl> - / / If the @ private , @ protected , or @ public annotations <nl> - / / have a type attached , pretend that they actually wrote : <nl> - / / @ type { type } \ n @ private <nl> - / / This will have some weird behavior in some cases <nl> - / / ( for example , @ private can now be used as a type - cast ) , <nl> - / / but should be mostly OK . <nl> - if ( ( type ! = null & & isAlternateTypeAnnotation ) <nl> - | | annotation = = Annotation . TYPE ) { <nl> - if ( ! jsdocBuilder . recordType ( type ) ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . incompat . type " , lineno , charno ) ; <nl> - } <nl> - } <nl> - <nl> - switch ( annotation ) { <nl> - case CONSTANT : <nl> - if ( ! jsdocBuilder . recordConstancy ( ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . const " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - break ; <nl> - <nl> - case DEFINE : <nl> - if ( ! jsdocBuilder . recordDefineType ( type ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . define " , <nl> - lineno , charno ) ; <nl> - } <nl> - break ; <nl> - <nl> - case PRIVATE : <nl> - if ( ! jsdocBuilder . recordVisibility ( Visibility . PRIVATE ) ) { <nl> - parser . addParserWarning ( <nl> - " msg . jsdoc . visibility . private " , <nl> - lineno , charno ) ; <nl> - } <nl> - break ; <nl> - <nl> - case PROTECTED : <nl> - if ( ! jsdocBuilder . recordVisibility ( Visibility . PROTECTED ) ) { <nl> - parser . addParserWarning ( <nl> - " msg . jsdoc . visibility . protected " , <nl> - lineno , charno ) ; <nl> - } <nl> - break ; <nl> - <nl> - case PUBLIC : <nl> - if ( ! jsdocBuilder . recordVisibility ( Visibility . PUBLIC ) ) { <nl> - parser . addParserWarning ( <nl> - " msg . jsdoc . visibility . public " , <nl> - lineno , charno ) ; <nl> - } <nl> - break ; <nl> - <nl> - case RETURN : <nl> - if ( type = = null ) { <nl> - type = createJSTypeExpression ( newNode ( Token . QMARK ) ) ; <nl> - } <nl> - <nl> - if ( ! jsdocBuilder . recordReturnType ( type ) ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . incompat . type " , lineno , charno ) ; <nl> - break ; <nl> - } <nl> - <nl> - / / Find the return ' s description ( if applicable ) . <nl> - if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> - ExtractionInfo returnDescriptionInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> - <nl> - String returnDescription = <nl> - returnDescriptionInfo . string ; <nl> - <nl> - if ( returnDescription . length ( ) > 0 ) { <nl> - jsdocBuilder . recordReturnDescription ( <nl> - returnDescription ) ; <nl> - } <nl> - <nl> - token = returnDescriptionInfo . token ; <nl> - } else { <nl> - token = eatTokensUntilEOL ( token ) ; <nl> - } <nl> - continue retry ; <nl> - <nl> - case THIS : <nl> - if ( ! jsdocBuilder . recordThisType ( type ) ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . incompat . type " , lineno , charno ) ; <nl> - } <nl> - break ; <nl> - <nl> - case TYPEDEF : <nl> - if ( ! jsdocBuilder . recordTypedef ( type ) ) { <nl> - parser . addTypeWarning ( <nl> - " msg . jsdoc . incompat . type " , lineno , charno ) ; <nl> - } <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - } <nl> - } <nl> - } <nl> - break ; <nl> - <nl> - case EOC : <nl> - if ( hasParsedFileOverviewDocInfo ( ) ) { <nl> - fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo ( ) ; <nl> - } <nl> - checkExtendedTypes ( extendedTypes ) ; <nl> - return true ; <nl> - <nl> - case EOF : <nl> - / / discard any accumulated information <nl> - jsdocBuilder . build ( null ) ; <nl> - parser . addParserWarning ( " msg . unexpected . eof " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - checkExtendedTypes ( extendedTypes ) ; <nl> - return false ; <nl> - <nl> - case EOL : <nl> - if ( state = = State . SEARCHING_NEWLINE ) { <nl> - state = State . SEARCHING_ANNOTATION ; <nl> - } <nl> - token = next ( ) ; <nl> - continue retry ; <nl> - <nl> - default : <nl> - if ( token = = JsDocToken . STAR & & state = = State . SEARCHING_ANNOTATION ) { <nl> - token = next ( ) ; <nl> - continue retry ; <nl> - } else { <nl> - state = State . SEARCHING_NEWLINE ; <nl> - token = eatTokensUntilEOL ( ) ; <nl> - continue retry ; <nl> - } <nl> - } <nl> - <nl> - / / next token <nl> - token = next ( ) ; <nl> - } <nl> - } <nl> - <nl> - private void checkExtendedTypes ( List < ExtendedTypeInfo > extendedTypes ) { <nl> - for ( ExtendedTypeInfo typeInfo : extendedTypes ) { <nl> - / / If interface , record the multiple extended interfaces <nl> - if ( jsdocBuilder . isInterfaceRecorded ( ) ) { <nl> - if ( ! jsdocBuilder . recordExtendedInterface ( typeInfo . type ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . extends . duplicate " , <nl> - typeInfo . lineno , typeInfo . charno ) ; <nl> - } <nl> - } else { <nl> - if ( ! jsdocBuilder . recordBaseType ( typeInfo . type ) ) { <nl> - parser . addTypeWarning ( " msg . jsdoc . incompat . type " , <nl> - typeInfo . lineno , typeInfo . charno ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Parse a { @ code @ suppress } tag of the form <nl> - * { @ code @ suppress & # 123 ; warning1 | warning2 & # 125 ; } . <nl> - * <nl> - * @ param token The current token . <nl> - * / <nl> - private JsDocToken parseSuppressTag ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . LC ) { <nl> - Set < String > suppressions = new HashSet < String > ( ) ; <nl> - while ( true ) { <nl> - if ( match ( JsDocToken . STRING ) ) { <nl> - String name = stream . getString ( ) ; <nl> - if ( ! suppressionNames . contains ( name ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . suppress . unknown " , name , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - suppressions . add ( stream . getString ( ) ) ; <nl> - token = next ( ) ; <nl> - } else { <nl> - parser . addParserWarning ( " msg . jsdoc . suppress " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - return token ; <nl> - } <nl> - <nl> - if ( match ( JsDocToken . PIPE ) ) { <nl> - token = next ( ) ; <nl> - } else { <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - if ( ! match ( JsDocToken . RC ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . suppress " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - token = next ( ) ; <nl> - if ( ! jsdocBuilder . recordSuppressions ( suppressions ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . suppress . duplicate " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - return token ; <nl> - } <nl> - <nl> - / * * <nl> - * Parse a { @ code @ modifies } tag of the form <nl> - * { @ code @ modifies & # 123 ; this | arguments | param & # 125 ; } . <nl> - * <nl> - * @ param token The current token . <nl> - * / <nl> - private JsDocToken parseModifiesTag ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . LC ) { <nl> - Set < String > modifies = new HashSet < String > ( ) ; <nl> - while ( true ) { <nl> - if ( match ( JsDocToken . STRING ) ) { <nl> - String name = stream . getString ( ) ; <nl> - if ( ! modifiesAnnotationKeywords . contains ( name ) <nl> - & & ! jsdocBuilder . hasParameter ( name ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . modifies . unknown " , name , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - modifies . add ( stream . getString ( ) ) ; <nl> - token = next ( ) ; <nl> - } else { <nl> - parser . addParserWarning ( " msg . jsdoc . modifies " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - return token ; <nl> - } <nl> - <nl> - if ( match ( JsDocToken . PIPE ) ) { <nl> - token = next ( ) ; <nl> - } else { <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - if ( ! match ( JsDocToken . RC ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . modifies " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } else { <nl> - token = next ( ) ; <nl> - if ( ! jsdocBuilder . recordModifies ( modifies ) ) { <nl> - parser . addParserWarning ( " msg . jsdoc . modifies . duplicate " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - return token ; <nl> - } <nl> - <nl> - / * * <nl> - * Looks for a type expression at the current token and if found , <nl> - * returns it . Note that this method consumes input . <nl> - * <nl> - * @ param token The current token . <nl> - * @ return The type expression found or null if none . <nl> - * / <nl> - Node parseAndRecordTypeNode ( JsDocToken token ) { <nl> - return parseAndRecordTypeNode ( token , token = = JsDocToken . LC ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Looks for a type expression at the current token and if found , <nl> - * returns it . Note that this method consumes input . <nl> - * <nl> - * @ param token The current token . <nl> - * @ param matchingLC Whether the type expression starts with a " { " . <nl> - * @ return The type expression found or null if none . <nl> - * / <nl> - private Node parseAndRecordTypeNode ( JsDocToken token , boolean matchingLC ) { <nl> - return parseAndRecordTypeNode ( token , stream . getLineno ( ) , stream . getCharno ( ) , <nl> - matchingLC , false ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Looks for a type expression at the current token and if found , <nl> - * returns it . Note that this method consumes input . <nl> - * <nl> - * @ param token The current token . <nl> - * @ param lineno The line of the type expression . <nl> - * @ param startCharno The starting character position of the type expression . <nl> - * @ param matchingLC Whether the type expression starts with a " { " . <nl> - * @ return The type expression found or null if none . <nl> - * / <nl> - private Node parseAndRecordTypeNameNode ( JsDocToken token , int lineno , <nl> - int startCharno , boolean matchingLC ) { <nl> - return parseAndRecordTypeNode ( token , lineno , startCharno , matchingLC , true ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Looks for a type expression at the current token and if found , <nl> - * returns it . Note that this method consumes input . <nl> - * <nl> - * Parameter type expressions are special for two reasons : <nl> - * < ol > <nl> - * < li > They must begin with ' { ' , to distinguish type names from param names . <nl> - * < li > They may end in ' = ' , to denote optionality . <nl> - * < / ol > <nl> - * <nl> - * @ param token The current token . <nl> - * @ return The type expression found or null if none . <nl> - * / <nl> - private Node parseAndRecordParamTypeNode ( JsDocToken token ) { <nl> - Preconditions . checkArgument ( token = = JsDocToken . LC ) ; <nl> - int lineno = stream . getLineno ( ) ; <nl> - int startCharno = stream . getCharno ( ) ; <nl> - <nl> - Node typeNode = parseParamTypeExpressionAnnotation ( token ) ; <nl> - if ( typeNode ! = null ) { <nl> - int endLineno = stream . getLineno ( ) ; <nl> - int endCharno = stream . getCharno ( ) ; <nl> - <nl> - jsdocBuilder . markTypeNode ( typeNode , lineno , startCharno , <nl> - endLineno , endCharno , true ) ; <nl> - } <nl> - return typeNode ; <nl> - } <nl> - <nl> - / * * <nl> - * Looks for a parameter type expression at the current token and if found , <nl> - * returns it . Note that this method consumes input . <nl> - * <nl> - * @ param token The current token . <nl> - * @ param lineno The line of the type expression . <nl> - * @ param startCharno The starting character position of the type expression . <nl> - * @ param matchingLC Whether the type expression starts with a " { " . <nl> - * @ param onlyParseSimpleNames If true , only simple type names are parsed <nl> - * ( via a call to parseTypeNameAnnotation instead of <nl> - * parseTypeExpressionAnnotation ) . <nl> - * @ return The type expression found or null if none . <nl> - * / <nl> - private Node parseAndRecordTypeNode ( JsDocToken token , int lineno , <nl> - int startCharno , <nl> - boolean matchingLC , <nl> - boolean onlyParseSimpleNames ) { <nl> - Node typeNode = null ; <nl> - <nl> - if ( onlyParseSimpleNames ) { <nl> - typeNode = parseTypeNameAnnotation ( token ) ; <nl> - } else { <nl> - typeNode = parseTypeExpressionAnnotation ( token ) ; <nl> - } <nl> - <nl> - if ( typeNode ! = null ) { <nl> - int endLineno = stream . getLineno ( ) ; <nl> - int endCharno = stream . getCharno ( ) ; <nl> - <nl> - jsdocBuilder . markTypeNode ( <nl> - typeNode , lineno , startCharno , endLineno , endCharno , matchingLC ) ; <nl> - } <nl> - <nl> - return typeNode ; <nl> - } <nl> - <nl> - / * * <nl> - * Converts a JSDoc token to its string representation . <nl> - * / <nl> - private String toString ( JsDocToken token ) { <nl> - switch ( token ) { <nl> - case ANNOTATION : <nl> - return " @ " + stream . getString ( ) ; <nl> - <nl> - case BANG : <nl> - return " ! " ; <nl> - <nl> - case COMMA : <nl> - return " , " ; <nl> - <nl> - case COLON : <nl> - return " : " ; <nl> - <nl> - case GT : <nl> - return " > " ; <nl> - <nl> - case LB : <nl> - return " [ " ; <nl> - <nl> - case LC : <nl> - return " { " ; <nl> - <nl> - case LP : <nl> - return " ( " ; <nl> - <nl> - case LT : <nl> - return " . < " ; <nl> - <nl> - case QMARK : <nl> - return " ? " ; <nl> - <nl> - case PIPE : <nl> - return " | " ; <nl> - <nl> - case RB : <nl> - return " ] " ; <nl> - <nl> - case RC : <nl> - return " } " ; <nl> - <nl> - case RP : <nl> - return " ) " ; <nl> - <nl> - case STAR : <nl> - return " * " ; <nl> - <nl> - case ELLIPSIS : <nl> - return " . . . " ; <nl> - <nl> - case EQUALS : <nl> - return " = " ; <nl> - <nl> - case STRING : <nl> - return stream . getString ( ) ; <nl> - <nl> - default : <nl> - throw new IllegalStateException ( token . toString ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Constructs a new { @ code JSTypeExpression } . <nl> - * @ param n A node . May be null . <nl> - * / <nl> - JSTypeExpression createJSTypeExpression ( Node n ) { <nl> - return n = = null ? null : <nl> - new JSTypeExpression ( n , getSourceName ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Tuple for returning both the string extracted and the <nl> - * new token following a call to any of the extract * Block <nl> - * methods . <nl> - * / <nl> - private static class ExtractionInfo { <nl> - private final String string ; <nl> - private final JsDocToken token ; <nl> - <nl> - public ExtractionInfo ( String string , JsDocToken token ) { <nl> - this . string = string ; <nl> - this . token = token ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Tuple for recording extended types <nl> - * / <nl> - private static class ExtendedTypeInfo { <nl> - final JSTypeExpression type ; <nl> - final int lineno ; <nl> - final int charno ; <nl> - <nl> - public ExtendedTypeInfo ( JSTypeExpression type , int lineno , int charno ) { <nl> - this . type = type ; <nl> - this . lineno = lineno ; <nl> - this . charno = charno ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Extracts the text found on the current line starting at token . Note that <nl> - * token = token . info ; should be called after this method is used to update <nl> - * the token properly in the parser . <nl> - * <nl> - * @ return The extraction information . <nl> - * / <nl> - private ExtractionInfo extractSingleLineBlock ( ) { <nl> - <nl> - / / Get the current starting point . <nl> - stream . update ( ) ; <nl> - int lineno = stream . getLineno ( ) ; <nl> - int charno = stream . getCharno ( ) + 1 ; <nl> - <nl> - String line = getRemainingJSDocLine ( ) . trim ( ) ; <nl> - <nl> - / / Record the textual description . <nl> - if ( line . length ( ) > 0 ) { <nl> - jsdocBuilder . markText ( line , lineno , charno , lineno , <nl> - charno + line . length ( ) ) ; <nl> - } <nl> - <nl> - return new ExtractionInfo ( line , next ( ) ) ; <nl> - } <nl> - <nl> - private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token ) { <nl> - return extractMultilineTextualBlock ( token , WhitespaceOption . SINGLE_LINE ) ; <nl> - } <nl> - <nl> - private enum WhitespaceOption { <nl> - / * * <nl> - * Preserves all whitespace and formatting . Needed for licenses and <nl> - * purposely formatted text . <nl> - * / <nl> - PRESERVE , <nl> - <nl> - / * * Preserves newlines but trims the output . * / <nl> - TRIM , <nl> - <nl> - / * * Removes newlines and turns the output into a single line string . * / <nl> - SINGLE_LINE <nl> - } <nl> - <nl> - / * * <nl> - * Extracts the text found on the current line and all subsequent <nl> - * until either an annotation , end of comment or end of file is reached . <nl> - * Note that if this method detects an end of line as the first token , it <nl> - * will quit immediately ( indicating that there is no text where it was <nl> - * expected ) . Note that token = info . token ; should be called after this <nl> - * method is used to update the token properly in the parser . <nl> - * <nl> - * @ param token The start token . <nl> - * @ param option How to handle whitespace . <nl> - * <nl> - * @ return The extraction information . <nl> - * / <nl> - @ SuppressWarnings ( " fallthrough " ) <nl> - private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , <nl> - WhitespaceOption option ) { <nl> - <nl> - if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOL | | <nl> - token = = JsDocToken . EOF ) { <nl> - return new ExtractionInfo ( " " , token ) ; <nl> - } <nl> - <nl> - stream . update ( ) ; <nl> - int startLineno = stream . getLineno ( ) ; <nl> - int startCharno = stream . getCharno ( ) + 1 ; <nl> - <nl> - / / Read the content from the first line . <nl> - String line = getRemainingJSDocLine ( ) ; <nl> - if ( option ! = WhitespaceOption . PRESERVE ) { <nl> - line = line . trim ( ) ; <nl> - } <nl> - <nl> - StringBuilder builder = new StringBuilder ( ) ; <nl> - builder . append ( line ) ; <nl> - <nl> - state = State . SEARCHING_ANNOTATION ; <nl> - token = next ( ) ; <nl> - <nl> - boolean ignoreStar = false ; <nl> - <nl> - / / Track the start of the line to count whitespace that <nl> - / / the tokenizer skipped . Because this case is rare , it ' s easier <nl> - / / to do this here than in the tokenizer . <nl> - int lineStartChar = - 1 ; <nl> - <nl> - do { <nl> - switch ( token ) { <nl> - case STAR : <nl> - if ( ignoreStar ) { <nl> - / / Mark the position after the star as the new start of the line . <nl> - lineStartChar = stream . getCharno ( ) + 1 ; <nl> - } else { <nl> - / / The star is part of the comment . <nl> - if ( builder . length ( ) > 0 ) { <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - <nl> - builder . append ( ' * ' ) ; <nl> - } <nl> - <nl> - token = next ( ) ; <nl> - continue ; <nl> - <nl> - case EOL : <nl> - if ( option ! = WhitespaceOption . SINGLE_LINE ) { <nl> - builder . append ( " \ n " ) ; <nl> - } <nl> - <nl> - ignoreStar = true ; <nl> - lineStartChar = 0 ; <nl> - token = next ( ) ; <nl> - continue ; <nl> - <nl> - default : <nl> - ignoreStar = false ; <nl> - state = State . SEARCHING_ANNOTATION ; <nl> - <nl> - boolean isEOC = token = = JsDocToken . EOC ; <nl> - if ( ! isEOC ) { <nl> - if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { <nl> - int numSpaces = stream . getCharno ( ) - lineStartChar ; <nl> - for ( int i = 0 ; i < numSpaces ; i + + ) { <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - lineStartChar = - 1 ; <nl> - } else if ( builder . length ( ) > 0 ) { <nl> - / / All tokens must be separated by a space . <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - } <nl> - <nl> - if ( token = = JsDocToken . EOC | | <nl> - token = = JsDocToken . EOF | | <nl> - / / When we ' re capturing a license block , annotations <nl> - / / in the block are OK . <nl> - ( token = = JsDocToken . ANNOTATION & & <nl> - option ! = WhitespaceOption . PRESERVE ) ) { <nl> - String multilineText = builder . toString ( ) ; <nl> - <nl> - if ( option ! = WhitespaceOption . PRESERVE ) { <nl> - multilineText = multilineText . trim ( ) ; <nl> - } <nl> - <nl> - int endLineno = stream . getLineno ( ) ; <nl> - int endCharno = stream . getCharno ( ) ; <nl> - <nl> - if ( multilineText . length ( ) > 0 ) { <nl> - jsdocBuilder . markText ( multilineText , startLineno , startCharno , <nl> - endLineno , endCharno ) ; <nl> - } <nl> - <nl> - return new ExtractionInfo ( multilineText , token ) ; <nl> - } <nl> - <nl> - builder . append ( toString ( token ) ) ; <nl> - <nl> - line = getRemainingJSDocLine ( ) ; <nl> - <nl> - if ( option ! = WhitespaceOption . PRESERVE ) { <nl> - line = trimEnd ( line ) ; <nl> - } <nl> - <nl> - builder . append ( line ) ; <nl> - token = next ( ) ; <nl> - } <nl> - } while ( true ) ; <nl> - } <nl> - <nl> - <nl> - / * * <nl> - * Extracts the top - level block comment from the JsDoc comment , if any . <nl> - * This method differs from the extractMultilineTextualBlock in that it <nl> - * terminates under different conditions ( it doesn ' t have the same <nl> - * prechecks ) , it does not first read in the remaining of the current <nl> - * line and its conditions for ignoring the " * " ( STAR ) are different . <nl> - * <nl> - * @ param token The starting token . <nl> - * <nl> - * @ return The extraction information . <nl> - * / <nl> - private ExtractionInfo extractBlockComment ( JsDocToken token ) { <nl> - StringBuilder builder = new StringBuilder ( ) ; <nl> - <nl> - boolean ignoreStar = true ; <nl> - <nl> - do { <nl> - switch ( token ) { <nl> - case ANNOTATION : <nl> - case EOC : <nl> - case EOF : <nl> - return new ExtractionInfo ( builder . toString ( ) . trim ( ) , token ) ; <nl> - <nl> - case STAR : <nl> - if ( ! ignoreStar ) { <nl> - if ( builder . length ( ) > 0 ) { <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - <nl> - builder . append ( ' * ' ) ; <nl> - } <nl> - <nl> - token = next ( ) ; <nl> - continue ; <nl> - <nl> - case EOL : <nl> - ignoreStar = true ; <nl> - builder . append ( ' \ n ' ) ; <nl> - token = next ( ) ; <nl> - continue ; <nl> - <nl> - default : <nl> - if ( ! ignoreStar & & builder . length ( ) > 0 ) { <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - <nl> - ignoreStar = false ; <nl> - <nl> - builder . append ( toString ( token ) ) ; <nl> - <nl> - String line = getRemainingJSDocLine ( ) ; <nl> - line = trimEnd ( line ) ; <nl> - builder . append ( line ) ; <nl> - token = next ( ) ; <nl> - } <nl> - } while ( true ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Trim characters from only the end of a string . <nl> - * This method will remove all whitespace characters <nl> - * ( defined by Character . isWhitespace ( char ) , in addition to the characters <nl> - * provided , from the end of the provided string . <nl> - * <nl> - * @ param s String to be trimmed <nl> - * @ return String with whitespace and characters in extraChars removed <nl> - * from the end . <nl> - * / <nl> - private static String trimEnd ( String s ) { <nl> - int trimCount = 0 ; <nl> - while ( trimCount < s . length ( ) ) { <nl> - char ch = s . charAt ( s . length ( ) - trimCount - 1 ) ; <nl> - if ( Character . isWhitespace ( ch ) ) { <nl> - trimCount + + ; <nl> - } else { <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - if ( trimCount = = 0 ) { <nl> - return s ; <nl> - } <nl> - return s . substring ( 0 , s . length ( ) - trimCount ) ; <nl> - } <nl> - <nl> - / / Based on ES4 grammar proposed on July 10 , 2008 . <nl> - / / http : / / wiki . ecmascript . org / doku . php ? id = spec : spec <nl> - / / Deliberately written to line up with the actual grammar rules , <nl> - / / for maximum flexibility . <nl> - <nl> - / / TODO ( nicksantos ) : The current implementation tries to maintain backwards <nl> - / / compatibility with previous versions of the spec whenever we can . <nl> - / / We should try to gradually withdraw support for these . <nl> - <nl> - / * * <nl> - * TypeExpressionAnnotation : = TypeExpression | <nl> - * ' { ' TopLevelTypeExpression ' } ' <nl> - * / <nl> - private Node parseTypeExpressionAnnotation ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . LC ) { <nl> - skipEOLs ( ) ; <nl> - Node typeNode = parseTopLevelTypeExpression ( next ( ) ) ; <nl> - if ( typeNode ! = null ) { <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RC ) ) { <nl> - reportTypeSyntaxWarning ( " msg . jsdoc . missing . rc " ) ; <nl> - } else { <nl> - next ( ) ; <nl> - } <nl> - } <nl> - <nl> - return typeNode ; <nl> - } else { <nl> - return parseTypeExpression ( token ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * ParamTypeExpressionAnnotation : = <nl> - * ' { ' OptionalParameterType ' } ' | <nl> - * ' { ' TopLevelTypeExpression ' } ' | <nl> - * ' { ' ' . . . ' TopLevelTypeExpression ' } ' <nl> - * <nl> - * OptionalParameterType : = <nl> - * TopLevelTypeExpression ' = ' <nl> - * / <nl> - private Node parseParamTypeExpressionAnnotation ( JsDocToken token ) { <nl> - Preconditions . checkArgument ( token = = JsDocToken . LC ) ; <nl> - <nl> - skipEOLs ( ) ; <nl> - <nl> - boolean restArg = false ; <nl> - token = next ( ) ; <nl> - if ( token = = JsDocToken . ELLIPSIS ) { <nl> - token = next ( ) ; <nl> - if ( token = = JsDocToken . RC ) { <nl> - / / EMPTY represents the UNKNOWN type in the Type AST . <nl> - return wrapNode ( Token . ELLIPSIS , IR . empty ( ) ) ; <nl> - } <nl> - restArg = true ; <nl> - } <nl> - <nl> - Node typeNode = parseTopLevelTypeExpression ( token ) ; <nl> - if ( typeNode ! = null ) { <nl> - skipEOLs ( ) ; <nl> - if ( restArg ) { <nl> - typeNode = wrapNode ( Token . ELLIPSIS , typeNode ) ; <nl> - } else if ( match ( JsDocToken . EQUALS ) ) { <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - typeNode = wrapNode ( Token . EQUALS , typeNode ) ; <nl> - } <nl> - <nl> - if ( ! match ( JsDocToken . RC ) ) { <nl> - reportTypeSyntaxWarning ( " msg . jsdoc . missing . rc " ) ; <nl> - } else { <nl> - next ( ) ; <nl> - } <nl> - } <nl> - <nl> - return typeNode ; <nl> - } <nl> - <nl> - / * * <nl> - * TypeNameAnnotation : = TypeName | ' { ' TypeName ' } ' <nl> - * / <nl> - private Node parseTypeNameAnnotation ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . LC ) { <nl> - skipEOLs ( ) ; <nl> - Node typeNode = parseTypeName ( next ( ) ) ; <nl> - if ( typeNode ! = null ) { <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RC ) ) { <nl> - reportTypeSyntaxWarning ( " msg . jsdoc . missing . rc " ) ; <nl> - } else { <nl> - next ( ) ; <nl> - } <nl> - } <nl> - <nl> - return typeNode ; <nl> - } else { <nl> - return parseTypeName ( token ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * TopLevelTypeExpression : = TypeExpression <nl> - * | TypeUnionList <nl> - * <nl> - * We made this rule up , for the sake of backwards compatibility . <nl> - * / <nl> - private Node parseTopLevelTypeExpression ( JsDocToken token ) { <nl> - Node typeExpr = parseTypeExpression ( token ) ; <nl> - if ( typeExpr ! = null ) { <nl> - / / top - level unions are allowed <nl> - if ( match ( JsDocToken . PIPE ) ) { <nl> - next ( ) ; <nl> - if ( match ( JsDocToken . PIPE ) ) { <nl> - / / We support double pipes for backwards - compatibility . <nl> - next ( ) ; <nl> - } <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - return parseUnionTypeWithAlternate ( token , typeExpr ) ; <nl> - } <nl> - } <nl> - return typeExpr ; <nl> - } <nl> - <nl> - / * * <nl> - * TypeExpressionList : = TopLevelTypeExpression <nl> - * | TopLevelTypeExpression ' , ' TypeExpressionList <nl> - * / <nl> - private Node parseTypeExpressionList ( JsDocToken token ) { <nl> - Node typeExpr = parseTopLevelTypeExpression ( token ) ; <nl> - if ( typeExpr = = null ) { <nl> - return null ; <nl> - } <nl> - Node typeList = IR . block ( ) ; <nl> - typeList . addChildToBack ( typeExpr ) ; <nl> - while ( match ( JsDocToken . COMMA ) ) { <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - typeExpr = parseTopLevelTypeExpression ( next ( ) ) ; <nl> - if ( typeExpr = = null ) { <nl> - return null ; <nl> - } <nl> - typeList . addChildToBack ( typeExpr ) ; <nl> - } <nl> - return typeList ; <nl> - } <nl> - <nl> - / * * <nl> - * TypeExpression : = BasicTypeExpression <nl> - * | ' ? ' BasicTypeExpression <nl> - * | ' ! ' BasicTypeExpression <nl> - * | BasicTypeExpression ' ? ' <nl> - * | BasicTypeExpression ' ! ' <nl> - * | ' ? ' <nl> - * / <nl> - private Node parseTypeExpression ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . QMARK ) { <nl> - / / A QMARK could mean that a type is nullable , or that it ' s unknown . <nl> - / / We use look - ahead 1 to determine whether it ' s unknown . Otherwise , <nl> - / / we assume it means nullable . There are 5 cases : <nl> - / / { ? } - right curly <nl> - / / { ? = } - equals <nl> - / / { function ( ? , number ) } - comma <nl> - / / { function ( number , ? ) } - right paren <nl> - / / { function ( number , . . . [ ? ] ) } - right bracket <nl> - / / { function ( ) : ? | number } - pipe <nl> - / / { Array . < ? > } - greater than <nl> - / / I ' m not a big fan of using look - ahead for this , but it makes <nl> - / / the type language a lot nicer . <nl> - token = next ( ) ; <nl> - if ( token = = JsDocToken . COMMA | | <nl> - token = = JsDocToken . EQUALS | | <nl> - token = = JsDocToken . RB | | <nl> - token = = JsDocToken . RC | | <nl> - token = = JsDocToken . RP | | <nl> - token = = JsDocToken . PIPE | | <nl> - token = = JsDocToken . GT ) { <nl> - restoreLookAhead ( token ) ; <nl> - return newNode ( Token . QMARK ) ; <nl> - } <nl> - <nl> - return wrapNode ( Token . QMARK , parseBasicTypeExpression ( token ) ) ; <nl> - } else if ( token = = JsDocToken . BANG ) { <nl> - return wrapNode ( Token . BANG , parseBasicTypeExpression ( next ( ) ) ) ; <nl> - } else { <nl> - Node basicTypeExpr = parseBasicTypeExpression ( token ) ; <nl> - if ( basicTypeExpr ! = null ) { <nl> - if ( match ( JsDocToken . QMARK ) ) { <nl> - next ( ) ; <nl> - return wrapNode ( Token . QMARK , basicTypeExpr ) ; <nl> - } else if ( match ( JsDocToken . BANG ) ) { <nl> - next ( ) ; <nl> - return wrapNode ( Token . BANG , basicTypeExpr ) ; <nl> - } <nl> - } <nl> - <nl> - return basicTypeExpr ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * BasicTypeExpression : = ' * ' | ' null ' | ' undefined ' | TypeName <nl> - * | FunctionType | UnionType | RecordType | ArrayType <nl> - * / <nl> - private Node parseBasicTypeExpression ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . STAR ) { <nl> - return newNode ( Token . STAR ) ; <nl> - } else if ( token = = JsDocToken . LB ) { <nl> - skipEOLs ( ) ; <nl> - return parseArrayType ( next ( ) ) ; <nl> - } else if ( token = = JsDocToken . LC ) { <nl> - skipEOLs ( ) ; <nl> - return parseRecordType ( next ( ) ) ; <nl> - } else if ( token = = JsDocToken . LP ) { <nl> - skipEOLs ( ) ; <nl> - return parseUnionType ( next ( ) ) ; <nl> - } else if ( token = = JsDocToken . STRING ) { <nl> - String string = stream . getString ( ) ; <nl> - if ( " function " . equals ( string ) ) { <nl> - skipEOLs ( ) ; <nl> - return parseFunctionType ( next ( ) ) ; <nl> - } else if ( " null " . equals ( string ) | | " undefined " . equals ( string ) ) { <nl> - return newStringNode ( string ) ; <nl> - } else { <nl> - return parseTypeName ( token ) ; <nl> - } <nl> - } <nl> - <nl> - restoreLookAhead ( token ) ; <nl> - return reportGenericTypeSyntaxWarning ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * TypeName : = NameExpression | NameExpression TypeApplication <nl> - * TypeApplication : = ' . < ' TypeExpressionList ' > ' <nl> - * / <nl> - private Node parseTypeName ( JsDocToken token ) { <nl> - if ( token ! = JsDocToken . STRING ) { <nl> - return reportGenericTypeSyntaxWarning ( ) ; <nl> - } <nl> - <nl> - String typeName = stream . getString ( ) ; <nl> - int lineno = stream . getLineno ( ) ; <nl> - int charno = stream . getCharno ( ) ; <nl> - while ( match ( JsDocToken . EOL ) & & <nl> - typeName . charAt ( typeName . length ( ) - 1 ) = = ' . ' ) { <nl> - skipEOLs ( ) ; <nl> - if ( match ( JsDocToken . STRING ) ) { <nl> - next ( ) ; <nl> - typeName + = stream . getString ( ) ; <nl> - } <nl> - } <nl> - <nl> - Node typeNameNode = newStringNode ( typeName , lineno , charno ) ; <nl> - <nl> - if ( match ( JsDocToken . LT ) ) { <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - Node memberType = parseTypeExpressionList ( next ( ) ) ; <nl> - if ( memberType ! = null ) { <nl> - typeNameNode . addChildToFront ( memberType ) ; <nl> - <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . GT ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . gt " ) ; <nl> - } <nl> - <nl> - next ( ) ; <nl> - } <nl> - } <nl> - return typeNameNode ; <nl> - } <nl> - <nl> - / * * <nl> - * FunctionType : = ' function ' FunctionSignatureType <nl> - * FunctionSignatureType : = <nl> - * TypeParameters ' ( ' ' this ' ' : ' TypeName , ParametersType ' ) ' ResultType <nl> - * / <nl> - private Node parseFunctionType ( JsDocToken token ) { <nl> - / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so <nl> - / / just throw out TypeParameters . <nl> - if ( token ! = JsDocToken . LP ) { <nl> - restoreLookAhead ( token ) ; <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . lp " ) ; <nl> - } <nl> - <nl> - Node functionType = newNode ( Token . FUNCTION ) ; <nl> - Node parameters = null ; <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RP ) ) { <nl> - token = next ( ) ; <nl> - <nl> - boolean hasParams = true ; <nl> - if ( token = = JsDocToken . STRING ) { <nl> - String tokenStr = stream . getString ( ) ; <nl> - boolean isThis = " this " . equals ( tokenStr ) ; <nl> - boolean isNew = " new " . equals ( tokenStr ) ; <nl> - if ( isThis | | isNew ) { <nl> - if ( match ( JsDocToken . COLON ) ) { <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - Node contextType = wrapNode ( <nl> - isThis ? Token . THIS : Token . NEW , <nl> - parseTypeName ( next ( ) ) ) ; <nl> - if ( contextType = = null ) { <nl> - return null ; <nl> - } <nl> - <nl> - functionType . addChildToFront ( contextType ) ; <nl> - } else { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . colon " ) ; <nl> - } <nl> - <nl> - if ( match ( JsDocToken . COMMA ) ) { <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - } else { <nl> - hasParams = false ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( hasParams ) { <nl> - parameters = parseParametersType ( token ) ; <nl> - if ( parameters = = null ) { <nl> - return null ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( parameters ! = null ) { <nl> - functionType . addChildToBack ( parameters ) ; <nl> - } <nl> - <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RP ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . rp " ) ; <nl> - } <nl> - <nl> - skipEOLs ( ) ; <nl> - Node resultType = parseResultType ( next ( ) ) ; <nl> - if ( resultType = = null ) { <nl> - return null ; <nl> - } else { <nl> - functionType . addChildToBack ( resultType ) ; <nl> - } <nl> - return functionType ; <nl> - } <nl> - <nl> - / * * <nl> - * ParametersType : = RestParameterType | NonRestParametersType <nl> - * | NonRestParametersType ' , ' RestParameterType <nl> - * RestParameterType : = ' . . . ' Identifier <nl> - * NonRestParametersType : = ParameterType ' , ' NonRestParametersType <nl> - * | ParameterType <nl> - * | OptionalParametersType <nl> - * OptionalParametersType : = OptionalParameterType <nl> - * | OptionalParameterType , OptionalParametersType <nl> - * OptionalParameterType : = ParameterType = <nl> - * ParameterType : = TypeExpression | Identifier ' : ' TypeExpression <nl> - * / <nl> - / / NOTE ( nicksantos ) : The official ES4 grammar forces optional and rest <nl> - / / arguments to come after the required arguments . Our parser does not <nl> - / / enforce this . Instead we allow them anywhere in the function at parse - time , <nl> - / / and then warn about them during type resolution . <nl> - / / <nl> - / / In theory , it might be mathematically nicer to do the order - checking here . <nl> - / / But in practice , the order - checking for structural functions is exactly <nl> - / / the same as the order - checking for @ param annotations . And the latter <nl> - / / has to happen during type resolution . Rather than duplicate the <nl> - / / order - checking in two places , we just do all of it in type resolution . <nl> - private Node parseParametersType ( JsDocToken token ) { <nl> - Node paramsType = newNode ( Token . PARAM_LIST ) ; <nl> - boolean isVarArgs = false ; <nl> - Node paramType = null ; <nl> - if ( token ! = JsDocToken . RP ) { <nl> - do { <nl> - if ( paramType ! = null ) { <nl> - / / skip past the comma <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - } <nl> - <nl> - if ( token = = JsDocToken . ELLIPSIS ) { <nl> - / / In the latest ES4 proposal , there are no type constraints allowed <nl> - / / on variable arguments . We support the old syntax for backwards <nl> - / / compatibility , but we should gradually tear it out . <nl> - skipEOLs ( ) ; <nl> - if ( match ( JsDocToken . RP ) ) { <nl> - paramType = newNode ( Token . ELLIPSIS ) ; <nl> - } else { <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . LB ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . lb " ) ; <nl> - } <nl> - <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - paramType = wrapNode ( Token . ELLIPSIS , parseTypeExpression ( next ( ) ) ) ; <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RB ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . rb " ) ; <nl> - } <nl> - skipEOLs ( ) ; <nl> - next ( ) ; <nl> - } <nl> - <nl> - isVarArgs = true ; <nl> - } else { <nl> - paramType = parseTypeExpression ( token ) ; <nl> - if ( match ( JsDocToken . EQUALS ) ) { <nl> - skipEOLs ( ) ; <nl> - next ( ) ; <nl> - paramType = wrapNode ( Token . EQUALS , paramType ) ; <nl> - } <nl> - } <nl> - <nl> - if ( paramType = = null ) { <nl> - return null ; <nl> - } <nl> - paramsType . addChildToBack ( paramType ) ; <nl> - if ( isVarArgs ) { <nl> - break ; <nl> - } <nl> - } while ( match ( JsDocToken . COMMA ) ) ; <nl> - } <nl> - <nl> - if ( isVarArgs & & match ( JsDocToken . COMMA ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . function . varargs " ) ; <nl> - } <nl> - <nl> - / / The right paren will be checked by parseFunctionType <nl> - <nl> - return paramsType ; <nl> - } <nl> - <nl> - / * * <nl> - * ResultType : = < empty > | ' : ' void | ' : ' TypeExpression <nl> - * / <nl> - private Node parseResultType ( JsDocToken token ) { <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . COLON ) ) { <nl> - return newNode ( Token . EMPTY ) ; <nl> - } <nl> - <nl> - token = next ( ) ; <nl> - skipEOLs ( ) ; <nl> - if ( match ( JsDocToken . STRING ) & & " void " . equals ( stream . getString ( ) ) ) { <nl> - next ( ) ; <nl> - return newNode ( Token . VOID ) ; <nl> - } else { <nl> - return parseTypeExpression ( next ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * UnionType : = ' ( ' TypeUnionList ' ) ' <nl> - * TypeUnionList : = TypeExpression | TypeExpression ' | ' TypeUnionList <nl> - * <nl> - * We ' ve removed the empty union type . <nl> - * / <nl> - private Node parseUnionType ( JsDocToken token ) { <nl> - return parseUnionTypeWithAlternate ( token , null ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Create a new union type , with an alternate that has already been <nl> - * parsed . The alternate may be null . <nl> - * / <nl> - private Node parseUnionTypeWithAlternate ( JsDocToken token , Node alternate ) { <nl> - Node union = newNode ( Token . PIPE ) ; <nl> - if ( alternate ! = null ) { <nl> - union . addChildToBack ( alternate ) ; <nl> - } <nl> - <nl> - Node expr = null ; <nl> - do { <nl> - if ( expr ! = null ) { <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - Preconditions . checkState ( <nl> - token = = JsDocToken . PIPE | | token = = JsDocToken . COMMA ) ; <nl> - <nl> - boolean isPipe = token = = JsDocToken . PIPE ; <nl> - if ( isPipe & & match ( JsDocToken . PIPE ) ) { <nl> - / / We support double pipes for backwards compatibility . <nl> - next ( ) ; <nl> - } <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - } <nl> - expr = parseTypeExpression ( token ) ; <nl> - if ( expr = = null ) { <nl> - return null ; <nl> - } <nl> - <nl> - union . addChildToBack ( expr ) ; <nl> - / / We support commas for backwards compatibility . <nl> - } while ( match ( JsDocToken . PIPE , JsDocToken . COMMA ) ) ; <nl> - <nl> - if ( alternate = = null ) { <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RP ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . rp " ) ; <nl> - } <nl> - next ( ) ; <nl> - } <nl> - return union ; <nl> - } <nl> - <nl> - / * * <nl> - * ArrayType : = ' [ ' ElementTypeList ' ] ' <nl> - * ElementTypeList : = < empty > | TypeExpression | ' . . . ' TypeExpression <nl> - * | TypeExpression ' , ' ElementTypeList <nl> - * / <nl> - private Node parseArrayType ( JsDocToken token ) { <nl> - Node array = newNode ( Token . LB ) ; <nl> - Node arg = null ; <nl> - boolean hasVarArgs = false ; <nl> - <nl> - do { <nl> - if ( arg ! = null ) { <nl> - next ( ) ; <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - } <nl> - if ( token = = JsDocToken . ELLIPSIS ) { <nl> - arg = wrapNode ( Token . ELLIPSIS , parseTypeExpression ( next ( ) ) ) ; <nl> - hasVarArgs = true ; <nl> - } else { <nl> - arg = parseTypeExpression ( token ) ; <nl> - } <nl> - <nl> - if ( arg = = null ) { <nl> - return null ; <nl> - } <nl> - <nl> - array . addChildToBack ( arg ) ; <nl> - if ( hasVarArgs ) { <nl> - break ; <nl> - } <nl> - skipEOLs ( ) ; <nl> - } while ( match ( JsDocToken . COMMA ) ) ; <nl> - <nl> - if ( ! match ( JsDocToken . RB ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . rb " ) ; <nl> - } <nl> - next ( ) ; <nl> - return array ; <nl> - } <nl> - <nl> - / * * <nl> - * RecordType : = ' { ' FieldTypeList ' } ' <nl> - * / <nl> - private Node parseRecordType ( JsDocToken token ) { <nl> - Node recordType = newNode ( Token . LC ) ; <nl> - Node fieldTypeList = parseFieldTypeList ( token ) ; <nl> - <nl> - if ( fieldTypeList = = null ) { <nl> - return reportGenericTypeSyntaxWarning ( ) ; <nl> - } <nl> - <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . RC ) ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . missing . rc " ) ; <nl> - } <nl> - <nl> - next ( ) ; <nl> - <nl> - recordType . addChildToBack ( fieldTypeList ) ; <nl> - return recordType ; <nl> - } <nl> - <nl> - / * * <nl> - * FieldTypeList : = FieldType | FieldType ' , ' FieldTypeList <nl> - * / <nl> - private Node parseFieldTypeList ( JsDocToken token ) { <nl> - Node fieldTypeList = newNode ( Token . LB ) ; <nl> - <nl> - do { <nl> - Node fieldType = parseFieldType ( token ) ; <nl> - <nl> - if ( fieldType = = null ) { <nl> - return null ; <nl> - } <nl> - <nl> - fieldTypeList . addChildToBack ( fieldType ) ; <nl> - <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . COMMA ) ) { <nl> - break ; <nl> - } <nl> - <nl> - / / Move to the comma token . <nl> - next ( ) ; <nl> - <nl> - / / Move to the token passed the comma . <nl> - skipEOLs ( ) ; <nl> - token = next ( ) ; <nl> - } while ( true ) ; <nl> - <nl> - return fieldTypeList ; <nl> - } <nl> - <nl> - / * * <nl> - * FieldType : = FieldName | FieldName ' : ' TypeExpression <nl> - * / <nl> - private Node parseFieldType ( JsDocToken token ) { <nl> - Node fieldName = parseFieldName ( token ) ; <nl> - <nl> - if ( fieldName = = null ) { <nl> - return null ; <nl> - } <nl> - <nl> - skipEOLs ( ) ; <nl> - if ( ! match ( JsDocToken . COLON ) ) { <nl> - return fieldName ; <nl> - } <nl> - <nl> - / / Move to the colon . <nl> - next ( ) ; <nl> - <nl> - / / Move to the token after the colon and parse <nl> - / / the type expression . <nl> - skipEOLs ( ) ; <nl> - Node typeExpression = parseTypeExpression ( next ( ) ) ; <nl> - <nl> - if ( typeExpression = = null ) { <nl> - return null ; <nl> - } <nl> - <nl> - Node fieldType = newNode ( Token . COLON ) ; <nl> - fieldType . addChildToBack ( fieldName ) ; <nl> - fieldType . addChildToBack ( typeExpression ) ; <nl> - return fieldType ; <nl> - } <nl> - <nl> - / * * <nl> - * FieldName : = NameExpression | StringLiteral | NumberLiteral | <nl> - * ReservedIdentifier <nl> - * / <nl> - private Node parseFieldName ( JsDocToken token ) { <nl> - switch ( token ) { <nl> - case STRING : <nl> - String string = stream . getString ( ) ; <nl> - return newStringNode ( string ) ; <nl> - <nl> - default : <nl> - return null ; <nl> - } <nl> - } <nl> - <nl> - private Node wrapNode ( int type , Node n ) { <nl> - return n = = null ? null : <nl> - new Node ( type , n , stream . getLineno ( ) , <nl> - stream . getCharno ( ) ) . clonePropsFrom ( templateNode ) ; <nl> - } <nl> - <nl> - private Node newNode ( int type ) { <nl> - return new Node ( type , stream . getLineno ( ) , <nl> - stream . getCharno ( ) ) . clonePropsFrom ( templateNode ) ; <nl> - } <nl> - <nl> - private Node newStringNode ( String s ) { <nl> - return newStringNode ( s , stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - } <nl> - <nl> - private Node newStringNode ( String s , int lineno , int charno ) { <nl> - Node n = Node . newString ( s , lineno , charno ) . clonePropsFrom ( templateNode ) ; <nl> - n . setLength ( s . length ( ) ) ; <nl> - return n ; <nl> - } <nl> - <nl> - / / This is similar to IRFactory . createTemplateNode to share common props <nl> - / / e . g . , source - name , between all nodes . <nl> - private Node createTemplateNode ( ) { <nl> - / / The Node type choice is arbitrary . <nl> - Node templateNode = IR . script ( ) ; <nl> - templateNode . setStaticSourceFile ( <nl> - this . associatedNode ! = null ? <nl> - this . associatedNode . getStaticSourceFile ( ) : <nl> - null ) ; <nl> - return templateNode ; <nl> - } <nl> - <nl> - private Node reportTypeSyntaxWarning ( String warning ) { <nl> - parser . addTypeWarning ( warning , stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> - return null ; <nl> - } <nl> - <nl> - private Node reportGenericTypeSyntaxWarning ( ) { <nl> - return reportTypeSyntaxWarning ( " msg . jsdoc . type . syntax " ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Eats tokens until { @ link JsDocToken # EOL } included , and switches back the <nl> - * state to { @ link State # SEARCHING_ANNOTATION } . <nl> - * / <nl> - private JsDocToken eatTokensUntilEOL ( ) { <nl> - return eatTokensUntilEOL ( next ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Eats tokens until { @ link JsDocToken # EOL } included , and switches back the <nl> - * state to { @ link State # SEARCHING_ANNOTATION } . <nl> - * / <nl> - private JsDocToken eatTokensUntilEOL ( JsDocToken token ) { <nl> - do { <nl> - if ( token = = JsDocToken . EOL | | token = = JsDocToken . EOC | | <nl> - token = = JsDocToken . EOF ) { <nl> - state = State . SEARCHING_ANNOTATION ; <nl> - return token ; <nl> - } <nl> - token = next ( ) ; <nl> - } while ( true ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Specific value indicating that the { @ link # unreadToken } contains no token . <nl> - * / <nl> - private static final JsDocToken NO_UNREAD_TOKEN = null ; <nl> - <nl> - / * * <nl> - * One token buffer . <nl> - * / <nl> - private JsDocToken unreadToken = NO_UNREAD_TOKEN ; <nl> - <nl> - / * * Restores the lookahead token to the token stream * / <nl> - private void restoreLookAhead ( JsDocToken token ) { <nl> - unreadToken = token ; <nl> - } <nl> - <nl> - / * * <nl> - * Tests whether the next symbol of the token stream matches the specific <nl> - * token . <nl> - * / <nl> - private boolean match ( JsDocToken token ) { <nl> - unreadToken = next ( ) ; <nl> - return unreadToken = = token ; <nl> - } <nl> - <nl> - / * * <nl> - * Tests that the next symbol of the token stream matches one of the specified <nl> - * tokens . <nl> - * / <nl> - private boolean match ( JsDocToken token1 , JsDocToken token2 ) { <nl> - unreadToken = next ( ) ; <nl> - return unreadToken = = token1 | | unreadToken = = token2 ; <nl> - } <nl> - <nl> - / * * <nl> - * Gets the next token of the token stream or the buffered token if a matching <nl> - * was previously made . <nl> - * / <nl> - private JsDocToken next ( ) { <nl> - if ( unreadToken = = NO_UNREAD_TOKEN ) { <nl> - return stream . getJsDocToken ( ) ; <nl> - } else { <nl> - return current ( ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Gets the current token , invalidating it in the process . <nl> - * / <nl> - private JsDocToken current ( ) { <nl> - JsDocToken t = unreadToken ; <nl> - unreadToken = NO_UNREAD_TOKEN ; <nl> - return t ; <nl> - } <nl> - <nl> - / * * <nl> - * Skips all EOLs and all empty lines in the JSDoc . Call this method if you <nl> - * want the JSDoc entry to span multiple lines . <nl> - * / <nl> - private void skipEOLs ( ) { <nl> - while ( match ( JsDocToken . EOL ) ) { <nl> - next ( ) ; <nl> - if ( match ( JsDocToken . STAR ) ) { <nl> - next ( ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Returns the remainder of the line . <nl> - * / <nl> - private String getRemainingJSDocLine ( ) { <nl> - String result = stream . getRemainingJSDocLine ( ) ; <nl> - return result ; <nl> - } <nl> - <nl> - / * * <nl> - * Determines whether the parser has been populated with docinfo with a <nl> - * fileoverview tag . <nl> - * / <nl> - private boolean hasParsedFileOverviewDocInfo ( ) { <nl> - return jsdocBuilder . isPopulatedWithFileOverview ( ) ; <nl> - } <nl> - <nl> - boolean hasParsedJSDocInfo ( ) { <nl> - return jsdocBuilder . isPopulated ( ) ; <nl> - } <nl> - <nl> - JSDocInfo retrieveAndResetParsedJSDocInfo ( ) { <nl> - return jsdocBuilder . build ( associatedNode ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Gets the fileoverview JSDocInfo , if any . <nl> - * / <nl> - JSDocInfo getFileOverviewJSDocInfo ( ) { <nl> - return fileOverviewJSDocInfo ; <nl> - } <nl> - <nl> - / * * <nl> - * Look ahead for a type annotation by advancing the character stream . <nl> - * Does not modify the token stream . <nl> - * This is kind of a hack , and is only necessary because we use the token <nl> - * stream to parse types , but need the underlying character stream to get <nl> - * JsDoc descriptions . <nl> - * @ return Whether we found a type annotation . <nl> - * / <nl> - private boolean lookAheadForTypeAnnotation ( ) { <nl> - boolean matchedLc = false ; <nl> - int c ; <nl> - while ( true ) { <nl> - c = stream . getChar ( ) ; <nl> - if ( c = = ' ' ) { <nl> - continue ; <nl> - } else if ( c = = ' { ' ) { <nl> - matchedLc = true ; <nl> - break ; <nl> - } else { <nl> - break ; <nl> - } <nl> - } <nl> - stream . ungetChar ( c ) ; <nl> - return matchedLc ; <nl> - } <nl> - } <nl> 
0<ml>Kali-A_Closure-75_P_Patch_5_5.txt<ml>Kali-A_Closure-75_P_Patch_5_5.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_75 / src / com / google / javascript / jscomp / NodeUtil . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_75 / patches_l9sy / Patch_3 / patched / tmp / Kali_Defects4J_Closure_75 / src / com / google / javascript / jscomp / NodeUtil . java 	 2018 - 12 - 01 <nl> } <nl> } <nl> - if ( s . length ( ) > 3 <nl> - & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) <nl> - & & s . charAt ( 1 ) = = ' 0 ' <nl> - & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { <nl> + if ( true ) { <nl> / / hex numbers with explicit signs vary between browsers . <nl> return null ; <nl> } <nl> 
0<ml>Kali-A_Closure-10_P_Patch_19_17.txt<ml>Kali-A_Closure-10_P_Patch_19_17.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_10 / src / com / google / javascript / jscomp / NodeUtil . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_10 / patches_7aq0 / Patch_17 / patched / tmp / Kali_Defects4J_Closure_10 / src / com / google / javascript / jscomp / NodeUtil . java 	 2018 - 12 - 01 <nl> return allResultsMatch ( n . getFirstChild ( ) , p ) <nl> & & allResultsMatch ( n . getLastChild ( ) , p ) ; <nl> case Token . HOOK : <nl> - return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) <nl> - & & allResultsMatch ( n . getLastChild ( ) , p ) ; <nl> + { <nl> + if ( true ) <nl> + return true ; <nl> + return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) <nl> + & & allResultsMatch ( n . getLastChild ( ) , p ) ; <nl> + } <nl> default : <nl> return p . apply ( n ) ; <nl> } <nl> 
0<ml>Kali-A_Closure-112_P_Patch_12_12.txt<ml>Kali-A_Closure-112_P_Patch_12_12.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_112 / src / com / google / javascript / jscomp / TypeInference . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_112 / patches_if4a / Patch_8 / patched / tmp / Kali_Defects4J_Closure_112 / src / com / google / javascript / jscomp / TypeInference . java 	 2018 - 12 - 01 <nl> private static void resolvedTemplateType ( <nl> Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { <nl> JSType previous = map . get ( template ) ; <nl> - if ( ! resolved . isUnknownType ( ) ) { <nl> + if ( false ) { <nl> if ( previous = = null ) { <nl> map . put ( template , resolved ) ; <nl> } else { <nl> 
0<ml>Kali-A_Math-2_P_Patch_6_6.txt<ml>Kali-A_Math-2_P_Patch_6_6.txt<ml>mmm  / tmp / Kali_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Math_2 / patches_jbci / Patch_6 / patched / tmp / Kali_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2018 - 12 - 01 <nl> } <nl> k = 1 . 0 / k ; <nl> tmp = mu + k * sigma ; <nl> - if ( tmp < upper ) { <nl> + if ( false ) { <nl> upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> } <nl> } <nl> 
0<ml>Kali-A_Closure-127_P_Patch_17_13.txt<ml>Kali-A_Closure-127_P_Patch_17_13.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_127 / src / com / google / javascript / jscomp / UnreachableCodeElimination . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_127 / patches_dqjd / Patch_2 / patched / tmp / Kali_Defects4J_Closure_127 / src / com / google / javascript / jscomp / UnreachableCodeElimination . java 	 2018 - 12 - 01 <nl> outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; <nl> Node fallThrough = computeFollowing ( n ) ; <nl> Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; <nl> - if ( nextCfgNode = = fallThrough ) { <nl> + if ( false ) { <nl> removeNode ( n ) ; <nl> } <nl> } <nl> 
0<ml>Kali-A_Closure-21_P_Patch_2_2.txt<ml>Kali-A_Closure-21_P_Patch_2_2.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_21 / patches_k7vg / Patch_1 / patched / tmp / Kali_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2018 - 12 - 01 <nl> if ( n = = parent . getLastChild ( ) ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = Token . COMMA ) continue ; <nl> + if ( true ) continue ; <nl> if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> else break ; <nl> } <nl> 
0<ml>Kali-A_Chart-12_P_Patch_17_17.txt<ml>Kali-A_Chart-12_P_Patch_17_17.txt<ml>mmm  / tmp / Kali_Defects4J_Chart_12 / source / org / jfree / data / general / AbstractDataset . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Chart_12 / patches_kb09 / Patch_19 / patched / tmp / Kali_Defects4J_Chart_12 / source / org / jfree / data / general / AbstractDataset . java 	 2018 - 12 - 01 <nl> * @ see # removeChangeListener ( DatasetChangeListener ) <nl> * / <nl> public boolean hasListener ( EventListener listener ) { <nl> - List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; <nl> + if ( true ) <nl> + return true ; <nl> + List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; <nl> return list . contains ( listener ) ; <nl> } <nl> 
0<ml>Kali-A_Closure-129_P_Patch_21_21.txt<ml>Kali-A_Closure-129_P_Patch_21_21.txt<ml>mmm  / tmp / Kali_Defects4J_Closure_129 / src / com / google / javascript / rhino / Node . java 	 2018 - 12 - 01 <nl> ppp  / tmp / Kali_Defects4J_Closure_129 / patches_f5gl / Patch_7 / patched / tmp / Kali_Defects4J_Closure_129 / src / com / google / javascript / rhino / Node . java 	 2018 - 12 - 01 <nl> } <nl> } else if ( type = = Token . CALL ) { <nl> if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { <nl> - return false ; <nl> + if ( true ) <nl> + return true ; <nl> + return false ; <nl> } <nl> } <nl> 
0<ml>DynaMoth_Math-82_P_Patch_1_1.txt<ml>DynaMoth_Math-82_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> - minValue = tableau . getEntry ( 0 , i ) ; <nl> + if ( false ) { <nl> + minValue = tableau . getEntry ( 0 , i ) ; <nl> + } <nl> minPos = i ; <nl> 
0<ml>DynaMoth_Lang-63_P_Patch_1_1.txt<ml>DynaMoth_Lang-63_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> int newdiff = startValue - endValue ; <nl> - end . add ( field , newdiff ) ; <nl> + if ( false ) { <nl> + end . add ( field , newdiff ) ; <nl> + } <nl> return newdiff ; <nl> 
0<ml>DynaMoth_Math-71_P_Patch_1_1.txt<ml>DynaMoth_Math-71_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java <nl> public void setInitialStepSize ( final double initialStepSize ) { <nl> - if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { <nl> - initialStep = - 1 . 0 ; <nl> - } else { <nl> - initialStep = initialStepSize ; <nl> + if ( false ) { <nl> + if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { <nl> + initialStep = - 1 . 0 ; <nl> + } else { <nl> + initialStep = initialStepSize ; <nl> + } <nl> } <nl> 
1<ml>DynaMoth_Math-50_C_Patch_1_1.txt<ml>DynaMoth_Math-50_C_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + if ( false ) { <nl> + x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + } <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> 
0<ml>DynaMoth_Chart-13_P_Patch_1_1.txt<ml>DynaMoth_Chart-13_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / chart / block / BorderArrangement . java <nl> ppp b / source / org / jfree / chart / block / BorderArrangement . java <nl> h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; <nl> - if ( this . leftBlock ! = null ) { <nl> - RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> - new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> - LengthConstraintType . RANGE , h [ 2 ] , null , <nl> - LengthConstraintType . FIXED ) ; <nl> - Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> - w [ 2 ] = size . width ; <nl> + if ( false ) { <nl> + if ( this . leftBlock ! = null ) { <nl> + RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> + new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> + LengthConstraintType . RANGE , h [ 2 ] , null , <nl> + LengthConstraintType . FIXED ) ; <nl> + Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; <nl> + w [ 2 ] = size . width ; <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Chart-25_P_Patch_1_1.txt<ml>DynaMoth_Chart-25_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> PlotOrientation orientation = plot . getOrientation ( ) ; <nl> - if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> - drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> - rangeAxis , statData , row , column ) ; <nl> + if ( false ) { <nl> + if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> + drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> + rangeAxis , statData , row , column ) ; <nl> + } <nl> + else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> + drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> + statData , row , column ) ; <nl> + } <nl> } <nl> - else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> - drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> - statData , row , column ) ; <nl> - } <nl> } <nl> 
0<ml>DynaMoth_Math-81_P_Patch_1_1.txt<ml>DynaMoth_Math-81_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> final double gam = dN2 ; <nl> - if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { <nl> + if ( true ) { <nl> return ; <nl> 
0<ml>DynaMoth_Math-49_P_Patch_1_1.txt<ml>DynaMoth_Math-49_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> entries . put ( index , value ) ; <nl> - } else if ( entries . containsKey ( index ) ) { <nl> - entries . remove ( index ) ; <nl> + } else { <nl> + if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { <nl> + if ( entries . containsKey ( index ) ) { <nl> + entries . remove ( index ) ; <nl> + } <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Time-11_P_Patch_15_15.txt<ml>DynaMoth_Time-11_P_Patch_15_15.txt<ml>a / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java <nl> ppp b / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java <nl> { <nl> - if ( fromYear < = toYear ) { <nl> - OfYear ofYear = new OfYear <nl> + if ( nameKey . length ( ) ! = 0 ) { <nl> + if ( fromYear < = toYear ) { <nl> + OfYear ofYear = new OfYear <nl> ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; <nl> - Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; <nl> - Rule rule = new Rule ( recurrence , fromYear , toYear ) ; <nl> - getLastRuleSet ( ) . addRule ( rule ) ; <nl> + Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; <nl> + Rule rule = new Rule ( recurrence , fromYear , toYear ) ; <nl> + getLastRuleSet ( ) . addRule ( rule ) ; <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Math-85_P_Patch_1_1.txt<ml>DynaMoth_Math-85_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> ppp b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> if ( fa * fb > = 0 . 0 ) { <nl> - throw new ConvergenceException ( <nl> - " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> - " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> - " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> - numIterations , maximumIterations , initial , <nl> - lowerBound , upperBound , a , b , fa , fb ) ; <nl> + if ( false ) { <nl> + throw new ConvergenceException ( <nl> + " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> + " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> + " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> + numIterations , maximumIterations , initial , <nl> + lowerBound , upperBound , a , b , fa , fb ) ; <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Chart-1_P_Patch_1_1.txt<ml>DynaMoth_Chart-1_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> - return result ; <nl> + if ( false ) { <nl> + if ( dataset ! = null ) { <nl> + return result ; <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Lang-51_P_Patch_1_1.txt<ml>DynaMoth_Lang-51_P_Patch_1_1.txt<ml>mmm a / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ppp b / src / java / org / apache / commons / lang / BooleanUtils . java <nl> char ch = str . charAt ( 0 ) ; <nl> - if ( ch = = ' y ' ) { <nl> - return <nl> - ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> - ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> + if ( true ) { <nl> + return <nl> + ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> + ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> } <nl> 
0<ml>DynaMoth_Chart-5_P_Patch_1_1.txt<ml>DynaMoth_Chart-5_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / data / xy / XYSeries . java <nl> ppp b / source / org / jfree / data / xy / XYSeries . java <nl> / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> + if ( false ) { <nl> this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> 
0<ml>DynaMoth_Math-32_P_Patch_1_1.txt<ml>DynaMoth_Math-32_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java <nl> final BSPTree < Euclidean2D > tree = getTree ( false ) ; <nl> - if ( ( Boolean ) tree . getAttribute ( ) ) { <nl> + if ( false ) { <nl> 
0<ml>DynaMoth_Math-80_P_Patch_1_1.txt<ml>DynaMoth_Math-80_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> int j = 4 * n - 1 ; <nl> - for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> - work [ i + k ] = work [ j - k ] ; <nl> - work [ j - k ] = tmp ; <nl> + if ( false ) { <nl> + for ( int i = 0 ; i < j ; i + = 4 ) { <nl> + for ( int k = 0 ; k < 4 ; k + = step ) { <nl> + final double tmp = work [ i + k ] ; <nl> + work [ i + k ] = work [ j - k ] ; <nl> + work [ j - k ] = tmp ; <nl> + } <nl> + j - = 4 ; <nl> } <nl> - j - = 4 ; <nl> } <nl> 
0<ml>DynaMoth_Math-105_P_Patch_1_1.txt<ml>DynaMoth_Math-105_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java <nl> ppp b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java <nl> if ( n = = 0 ) { <nl> - xbar = x ; <nl> + if ( ( x < = 1 ) | | ( y < = x ) ) { <nl> + xbar = x ; <nl> + } <nl> ybar = y ; <nl> 
0<ml>DynaMoth_Chart-15_P_Patch_1_1.txt<ml>DynaMoth_Chart-15_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / chart / JFreeChart . java <nl> ppp b / source / org / jfree / chart / JFreeChart . java <nl> } <nl> - this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; <nl> + if ( false ) { <nl> + this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; <nl> + } <nl> 
0<ml>DynaMoth_Math-58_P_Patch_1_1.txt<ml>DynaMoth_Math-58_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> } <nl> - sum2 = 0 ; <nl> + if ( this . costRelativeTolerance ! = this . orthoTolerance ) { <nl> + sum2 = 0 ; <nl> + } <nl> for ( int j = 0 ; j < solvedCols ; + + j ) { <nl> 
0<ml>DynaMoth_Math-20_P_Patch_1_1.txt<ml>DynaMoth_Math-20_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> } <nl> - if ( max ( diagD ) > 1e14 * min ( diagD ) ) { <nl> + if ( this . dimension = = 1 ) { <nl> double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; <nl> 
0<ml>DynaMoth_Math-41_P_Patch_1_1.txt<ml>DynaMoth_Math-41_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java <nl> - if ( test ( values , weights , begin , length ) ) { <nl> - clear ( ) ; <nl> - if ( length = = 1 ) { <nl> - var = 0 . 0 ; <nl> - } else if ( length > 1 ) { <nl> - Mean mean = new Mean ( ) ; <nl> - double m = mean . evaluate ( values , weights , begin , length ) ; <nl> - var = evaluate ( values , weights , m , begin , length ) ; <nl> + if ( values [ 0 ] < = length ) { <nl> + if ( test ( values , weights , begin , length ) ) { <nl> + clear ( ) ; <nl> + if ( length = = 1 ) { <nl> + var = 0 . 0 ; <nl> + } else if ( length > 1 ) { <nl> + Mean mean = new Mean ( ) ; <nl> + double m = mean . evaluate ( values , weights , begin , length ) ; <nl> + var = evaluate ( values , weights , m , begin , length ) ; <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Math-8_P_Patch_1_1.txt<ml>DynaMoth_Math-8_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> - for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> - out [ i ] = sample ( ) ; <nl> + if ( false ) { <nl> + for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> + out [ i ] = sample ( ) ; <nl> + } <nl> } <nl> 
0<ml>DynaMoth_Chart-18_P_Patch_1_1.txt<ml>DynaMoth_Chart-18_P_Patch_1_1.txt<ml>a / source / org / jfree / data / category / DefaultCategoryDataset . java <nl> ppp b / source / org / jfree / data / category / DefaultCategoryDataset . java <nl> public void removeColumn ( Comparable columnKey ) { <nl> - this . data . removeColumn ( columnKey ) ; <nl> + if ( false ) { <nl> + this . data . removeColumn ( columnKey ) ; <nl> + } <nl> fireDatasetChanged ( ) ; <nl> 
0<ml>TBar_Math-82_P_Patch_1326_709.txt<ml>TBar_Math-82_P_Patch_1326_709.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> double minValue = 0 ; <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> - if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> + if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { <nl> minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> 
0<ml>TBar_Chart-26_P_Patch_5751_2399.txt<ml>TBar_Chart-26_P_Patch_5751_2399.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> PlotRenderingInfo state ) { <nl> / / if the plot area is too small , just return . . . <nl> - boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; <nl> + boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; <nl> boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; <nl> if ( b1 | | b2 ) { <nl> return ; <nl> 
0<ml>TBar_Math-88_P_Patch_593_301.txt<ml>TBar_Math-88_P_Patch_593_301.txt<ml>mmm a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ( restrictToNonNegative ? 0 : mostNegative ) ; <nl> if ( basicRow ! = null ) { <nl> for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { <nl> - if ( tableau . getEntry ( basicRow , j ) = = 1 ) { <nl> + if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { <nl> coefficients [ i ] = 0 ; <nl> } <nl> } <nl> 
0<ml>TBar_Lang-27_P_Patch_1259_919.txt<ml>TBar_Lang-27_P_Patch_1259_919.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> } <nl> mant = str . substring ( 0 , decPos ) ; <nl> } else { <nl> - if ( expPos > - 1 ) { <nl> + if ( expPos < - 1 ) { <nl> mant = str . substring ( 0 , expPos ) ; <nl> } else { <nl> mant = str ; <nl> 
1<ml>TBar_Math-65_C_Patch_137_80.txt<ml>TBar_Math-65_C_Patch_137_80.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / general / AbstractLeastSquaresOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / general / AbstractLeastSquaresOptimizer . java <nl> double chiSquare = 0 ; <nl> for ( int i = 0 ; i < rows ; + + i ) { <nl> final double residual = residuals [ i ] ; <nl> - chiSquare + = residual * residual / residualsWeights [ i ] ; <nl> + chiSquare + = residual * residual * residualsWeights [ i ] ; <nl> } <nl> return chiSquare ; <nl> } <nl> 
0<ml>TBar_Lang-63_P_Patch_28_21.txt<ml>TBar_Lang-63_P_Patch_28_21.txt<ml>mmm a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> int endValue = end . get ( field ) ; <nl> int startValue = start . get ( field ) ; <nl> if ( endValue < startValue ) { <nl> - int newdiff = startValue - endValue ; <nl> + int newdiff = difference - endValue ; <nl> end . add ( field , newdiff ) ; <nl> return newdiff ; <nl> } else { <nl> 
1<ml>TBar_Math-75_C_Patch_3_1.txt<ml>TBar_Math-75_C_Patch_3_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / Frequency . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / Frequency . java <nl> * / <nl> @ Deprecated <nl> public double getPct ( Object v ) { <nl> - return getCumPct ( ( Comparable < ? > ) v ) ; <nl> + return getPct ( ( Comparable < ? > ) v ) ; <nl> } <nl> / * * <nl> 
0<ml>TBar_Math-96_P_Patch_439_157.txt<ml>TBar_Math-96_P_Patch_439_157.txt<ml>mmm a / src / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / java / org / apache / commons / math / complex / Complex . java <nl> if ( rhs . isNaN ( ) ) { <nl> ret = this . isNaN ( ) ; <nl> } else { <nl> - ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; <nl> + ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; <nl> } <nl> } catch ( ClassCastException ex ) { <nl> / / ignore exception <nl> 
0<ml>TBar_Chart-3_P _Patch_440_242.txt<ml>TBar_Chart-3_P _Patch_440_242.txt<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> * permitted ) . <nl> * / <nl> public void add ( TimeSeriesDataItem item ) { <nl> - add ( item , true ) ; <nl> + updateBoundsForRemovedItem ( item ) ; <nl> + add ( item , true ) ; <nl> } <nl> / * * <nl> 
1<ml>TBar_Lang-33_C_Patch_47_28.txt<ml>TBar_Lang-33_C_Patch_47_28.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / ClassUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / ClassUtils . java <nl> } <nl> Class < ? > [ ] classes = new Class [ array . length ] ; <nl> for ( int i = 0 ; i < array . length ; i + + ) { <nl> - classes [ i ] = array [ i ] . getClass ( ) ; <nl> + if ( classes = = null ) continue ; <nl> + if ( array [ i ] = = null ) continue ; <nl> + classes [ i ] = array [ i ] . getClass ( ) ; <nl> } <nl> return classes ; <nl> } <nl> 
0<ml>TBar_Closure-109_P_Patch_270_73.txt<ml>TBar_Closure-109_P_Patch_270_73.txt<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> * For expressions on the right hand side of a this : or new : <nl> * / <nl> private Node parseContextTypeExpression ( JsDocToken token ) { <nl> - return parseTypeName ( token ) ; <nl> + return parseAndRecordTypeNode ( token ) ; <nl> } <nl> / * * <nl> 
0<ml>TBar_Closure-126_P_Patch_6_3.txt<ml>TBar_Closure-126_P_Patch_6_3.txt<ml>mmm a / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> ppp b / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> * / <nl> if ( NodeUtil . hasFinally ( n ) ) { <nl> Node finallyBlock = n . getLastChild ( ) ; <nl> - tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> + matchingExitNode ( finallyBlock , exitType , labelName ) ; <nl> } <nl> } <nl> 
0<ml>TBar_Lang-18_P_Patch_5849_3524.txt<ml>TBar_Lang-18_P_Patch_5849_3524.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> rule = new TextField ( Calendar . ERA , ERAs ) ; <nl> break ; <nl> case ' y ' : / / year ( number ) <nl> - if ( tokenLen > = 4 ) { <nl> + if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { <nl> rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; <nl> } else { <nl> rule = TwoDigitYearField . INSTANCE ; <nl> 
1<ml>TBar_Chart-19_C_Patch_68_59.txt<ml>TBar_Chart-19_C_Patch_68_59.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> * @ since 1 . 0 . 7 <nl> * / <nl> public int getRangeAxisIndex ( ValueAxis axis ) { <nl> - int result = this . rangeAxes . indexOf ( axis ) ; <nl> + if ( axis = = null ) { <nl> + throw new IllegalArgumentException ( " Null ' axis ' argument . " ) ; <nl> + } <nl> + int result = this . rangeAxes . indexOf ( axis ) ; <nl> if ( result < 0 ) { / / try the parent plot <nl> Plot parent = getParent ( ) ; <nl> if ( parent instanceof CategoryPlot ) { <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> * @ since 1 . 0 . 3 <nl> * / <nl> public int getDomainAxisIndex ( CategoryAxis axis ) { <nl> - return this . domainAxes . indexOf ( axis ) ; <nl> + if ( axis = = null ) { <nl> + throw new IllegalArgumentException ( " Null ' axis ' argument . " ) ; <nl> + } <nl> + return this . domainAxes . indexOf ( axis ) ; <nl> } <nl> / * * <nl> 
0<ml>TBar_Math-50_P_Patch_1_1.txt<ml>TBar_Math-50_P_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> break ; <nl> 
0<ml>TBar_Chart-13_P_Patch_29_18.txt<ml>TBar_Chart-13_P_Patch_29_18.txt<ml>mmm a / source / org / jfree / data / Range . java <nl> ppp b / source / org / jfree / data / Range . java <nl> if ( lower > upper ) { <nl> String msg = " Range ( double , double ) : require lower ( " + lower <nl> + " ) < = upper ( " + upper + " ) . " ; <nl> - throw new IllegalArgumentException ( msg ) ; <nl> + <nl> } <nl> this . lower = lower ; <nl> this . upper = upper ; <nl> 
0<ml>TBar_Lang-39_P_Patch_1350_1039.txt<ml>TBar_Lang-39_P_Patch_1350_1039.txt<ml>mmm a / src / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / java / org / apache / commons / lang3 / StringUtils . java <nl> int increase = 0 ; <nl> / / count the replacement text elements that are larger than their corresponding text being replaced <nl> - for ( int i = 0 ; i < searchList . length ; i + + ) { <nl> + for ( int i = 0 ; i = = searchList . length ; i + + ) { <nl> int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> if ( greater > 0 ) { <nl> increase + = 3 * greater ; / / assume 3 matches <nl> 
0<ml>TBar_Lang-58_P_Patch_1789_1078.txt<ml>TBar_Lang-58_P_Patch_1789_1078.txt<ml>mmm a / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> - if ( dec = = null <nl> + if ( dec ! = numeric | | ( dec = = null <nl> & & exp = = null <nl> & & isDigits ( numeric . substring ( 1 ) ) <nl> - & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { <nl> + & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> } catch ( NumberFormatException nfe ) { <nl> 
0<ml>TBar_Closure-107_P_Patch_356_164.txt<ml>TBar_Closure-107_P_Patch_356_164.txt<ml>mmm a / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> ppp b / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> / / In ADVANCED mode , goog . getMsg is going to be renamed anyway , <nl> / / so we might as well inline it . But shut off the i18n warnings , <nl> / / because the user didn ' t really ask for i18n . <nl> - options . messageBundle = new EmptyMessageBundle ( ) ; <nl> + <nl> } <nl> return options ; <nl> 
0<ml>TBar_Chart-25_P_Patch_12_9.txt<ml>TBar_Chart-25_P_Patch_12_9.txt<ml>mmm a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> notifyListeners ( new RendererChangeEvent ( this ) ) ; <nl> } <nl> - / * * <nl> - * Draws the bar with its standard deviation line range for a single <nl> - * ( series , category ) data item . <nl> - * <nl> - * @ param g2 the graphics device . <nl> - * @ param state the renderer state . <nl> - * @ param dataArea the data area . <nl> - * @ param plot the plot . <nl> - * @ param domainAxis the domain axis . <nl> - * @ param rangeAxis the range axis . <nl> - * @ param data the data . <nl> - * @ param row the row index ( zero - based ) . <nl> - * @ param column the column index ( zero - based ) . <nl> - * @ param pass the pass index . <nl> - * / <nl> - public void drawItem ( Graphics2D g2 , <nl> - CategoryItemRendererState state , <nl> - Rectangle2D dataArea , <nl> - CategoryPlot plot , <nl> - CategoryAxis domainAxis , <nl> - ValueAxis rangeAxis , <nl> - CategoryDataset data , <nl> - int row , <nl> - int column , <nl> - int pass ) { <nl> - <nl> - / / defensive check <nl> - if ( ! ( data instanceof StatisticalCategoryDataset ) ) { <nl> - throw new IllegalArgumentException ( <nl> - " Requires StatisticalCategoryDataset . " ) ; <nl> - } <nl> - StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; <nl> - <nl> - PlotOrientation orientation = plot . getOrientation ( ) ; <nl> - if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> - drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> - rangeAxis , statData , row , column ) ; <nl> - } <nl> - else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> - drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> - statData , row , column ) ; <nl> - } <nl> - } <nl> + <nl> / * * <nl> * Draws an item for a plot with a horizontal orientation . <nl> 
0<ml>TBar_Lang-41_P_Patch_2958_1870.txt<ml>TBar_Lang-41_P_Patch_2958_1870.txt<ml>mmm a / src / java / org / apache / commons / lang / ClassUtils . java <nl> ppp b / src / java / org / apache / commons / lang / ClassUtils . java <nl> if ( cls = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> - return getPackageName ( cls . getName ( ) ) ; <nl> + return getPackageCanonicalName ( cls . getName ( ) ) ; <nl> } <nl> / * * <nl> mmm a / src / java / org / apache / commons / lang / ClassUtils . java <nl> ppp b / src / java / org / apache / commons / lang / ClassUtils . java <nl> if ( cls = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> - return getShortClassName ( cls . getName ( ) ) ; <nl> + return getShortCanonicalName ( cls . getName ( ) ) ; <nl> } <nl> / * * <nl> 
0<ml>TBar_Math-81_P_Patch_75_45.txt<ml>TBar_Math-81_P_Patch_75_45.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> double s = 0 . 25 * dMin ; <nl> / / compute contribution to norm squared from i > nn - 2 . <nl> - final int np = nn - 2 * pingPong ; <nl> + final int np = nn - 2 * this . tType ; <nl> double b1 = work [ np - 2 ] ; <nl> double b2 = work [ np - 6 ] ; <nl> final double gam = dN2 ; <nl> 
0<ml>TBar_Lang-20_P_Patch_1220_617.txt<ml>TBar_Lang-20_P_Patch_1220_617.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; <nl> + StringBuilder buf = new StringBuilder ( ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; <nl> + StringBuilder buf = new StringBuilder ( ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> 
1<ml>TBar_Closure-73_C_Patch_146_58.txt<ml>TBar_Closure-73_C_Patch_146_58.txt<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> / / No charsetEncoder provided - pass straight latin characters <nl> / / through , and escape the rest . Doing the explicit character <nl> / / check is measurably faster than using the CharsetEncoder . <nl> - if ( c > 0x1f & & c < = 0x7f ) { <nl> + if ( c > 0x1f & & c < 0x7f ) { <nl> sb . append ( c ) ; <nl> } else { <nl> / / Other characters can be misinterpreted by some js parsers , <nl> 
0<ml>TBar_Lang-60_P_Patch_3262_1865.txt<ml>TBar_Lang-60_P_Patch_3262_1865.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> * @ throws IndexOutOfBoundsException if any index is invalid <nl> * / <nl> private void deleteImpl ( int startIndex , int endIndex , int len ) { <nl> - System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; <nl> + System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; <nl> size - = len ; <nl> } <nl> 
0<ml>TBar_Lang-24_P_Patch_2414_1931.txt<ml>TBar_Lang-24_P_Patch_2414_1931.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> / / can ' t have an E at the last byte <nl> return false ; <nl> } <nl> - if ( chars [ i ] = = ' . ' ) { <nl> + if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' <nl> + | | chars [ i ] = = ' L ' ) ) { <nl> if ( hasDecPoint | | hasExp ) { <nl> / / two decimal points or dec in exponent <nl> return false ; <nl> 
0<ml>TBar_Closure-12_P_Patch_160_37.txt<ml>TBar_Closure-12_P_Patch_160_37.txt<ml>mmm a / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> ppp b / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> } <nl> for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { <nl> - if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { <nl> + if ( apply ( c ) ) { <nl> return true ; <nl> } <nl> } <nl> 
0<ml>TBar_Lang-45_P_Patch_310_221.txt<ml>TBar_Lang-45_P_Patch_310_221.txt<ml>mmm a / src / java / org / apache / commons / lang / WordUtils . java <nl> ppp b / src / java / org / apache / commons / lang / WordUtils . java <nl> upper = str . length ( ) ; <nl> } <nl> / / if upper is less than lower , raise it to lower <nl> - if ( upper < lower ) { <nl> + if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { <nl> upper = lower ; <nl> } <nl> 
0<ml>TBar_Math-85_P_Patch_3_1.txt<ml>TBar_Math-85_P_Patch_3_1.txt<ml>mmm a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> ppp b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> if ( fa * fb > = 0 . 0 ) { <nl> - throw new ConvergenceException ( <nl> - " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> - " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> - " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> - numIterations , maximumIterations , initial , <nl> - lowerBound , upperBound , a , b , fa , fb ) ; <nl> + <nl> } <nl> return new double [ ] { a , b } ; <nl> 
0<ml>TBar_Math-62_P_Patch_261_142.txt<ml>TBar_Math-62_P_Patch_261_142.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java <nl> try { <nl> final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; <nl> final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; <nl> - optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; <nl> + optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; <nl> } catch ( FunctionEvaluationException fee ) { <nl> optima [ i ] = null ; <nl> } catch ( ConvergenceException ce ) { <nl> 
0<ml>TBar_Chart-14_P_Patch_2631_615.txt<ml>TBar_Chart-14_P_Patch_2631_615.txt<ml>mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + boolean removed = getAnnotations ( ) . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + boolean removed = getAnnotations ( ) . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + boolean removed = getAnnotations ( ) . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> boolean notify ) { <nl> ArrayList markers ; <nl> if ( layer = = Layer . FOREGROUND ) { <nl> - markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( <nl> + markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> else { <nl> 
0<ml>TBar_Math-95_P_Patch_56_20.txt<ml>TBar_Math-95_P_Patch_56_20.txt<ml>mmm a / src / java / org / apache / commons / math / distribution / FDistributionImpl . java <nl> ppp b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java <nl> double ret ; <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> - ret = d / ( d - 2 . 0 ) ; <nl> + ret = d / ( d + 2 . 0 ) ; <nl> return ret ; <nl> } <nl> 
0<ml>TBar_Lang-51_P_Patch_180_129.txt<ml>TBar_Lang-51_P_Patch_180_129.txt<ml>mmm a / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ppp b / src / java / org / apache / commons / lang / BooleanUtils . java <nl> } <nl> case 3 : { <nl> char ch = str . charAt ( 0 ) ; <nl> - if ( ch = = ' y ' ) { <nl> + if ( ch < = ' y ' ) { <nl> return <nl> ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> 
0<ml>TBar_Chart-5_P_Patch_52_1.txt<ml>TBar_Chart-5_P_Patch_52_1.txt<ml>mmm a / source / org / jfree / data / xy / XYSeries . java <nl> ppp b / source / org / jfree / data / xy / XYSeries . java <nl> * @ since 1 . 0 . 10 <nl> * / <nl> public XYDataItem addOrUpdate ( double x , double y ) { <nl> - return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; <nl> + return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; <nl> } <nl> / * * <nl> 
1<ml>TBar_Chart-1_C_Patch_2781_1214.txt<ml>TBar_Chart-1_C_Patch_2781_1214.txt<ml>mmm a / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> + if ( dataset = = null ) { <nl> return result ; <nl> } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> 
1<ml>TBar_Closure-63_C_Patch_43_31.txt<ml>TBar_Closure-63_C_Patch_43_31.txt<ml>mmm a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> ppp b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> / / charno = = sourceExpert . length ( ) means something is missing <nl> / / at the end of the line <nl> if ( excerpt . equals ( LINE ) <nl> - & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { <nl> + & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( Character . isWhitespace ( c ) ) { <nl> 
1<ml>TBar_Math-57_C_Patch_16_7.txt<ml>TBar_Math-57_C_Patch_16_7.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java <nl> while ( resultSet . size ( ) < k ) { <nl> / / For each data point x , compute D ( x ) , the distance between x and <nl> / / the nearest center that has already been chosen . <nl> - int sum = 0 ; <nl> + double sum = 0 ; <nl> for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { <nl> final T p = pointSet . get ( i ) ; <nl> final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ; <nl> 
0<ml>TBar_Closure-115_P_Patch_704_253.txt<ml>TBar_Closure-115_P_Patch_704_253.txt<ml>mmm a / src / com / google / javascript / jscomp / FunctionInjector . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionInjector . java <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> - if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> + if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { <nl> return CanInlineResult . NO ; <nl> } <nl> / / Check for arguments that are evaluated more than once . <nl> 
1<ml>TBar_Chart-20_C_Patch_153_49.txt<ml>TBar_Chart-20_C_Patch_153_49.txt<ml>mmm a / source / org / jfree / chart / plot / ValueMarker . java <nl> ppp b / source / org / jfree / chart / plot / ValueMarker . java <nl> * / <nl> public ValueMarker ( double value , Paint paint , Stroke stroke , <nl> Paint outlinePaint , Stroke outlineStroke , float alpha ) { <nl> - super ( paint , stroke , paint , stroke , alpha ) ; <nl> + super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; <nl> this . value = value ; <nl> } <nl> 
0<ml>TBar_Math-80_P_Patch_931_596.txt<ml>TBar_Math-80_P_Patch_931_596.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> private boolean flipIfWarranted ( final int n , final int step ) { <nl> if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { <nl> / / flip array <nl> - int j = 4 * n - 1 ; <nl> + int j = 4 * this . pingPong - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> for ( int k = 0 ; k < 4 ; k + = step ) { <nl> final double tmp = work [ i + k ] ; <nl> 
1<ml>TBar_Lang-7_C_Patch_1504_1083.txt<ml>TBar_Lang-7_C_Patch_1504_1083.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> if ( str = = null ) { <nl> return null ; <nl> } <nl> - if ( StringUtils . isBlank ( str ) ) { <nl> + if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( " - - " ) ) ) { <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> if ( str . startsWith ( " - - " ) ) { <nl> 
1<ml>TBar_Math-5_C_Patch_2_2.txt<ml>TBar_Math-5_C_Patch_2_2.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math3 / complex / Complex . java <nl> } <nl> if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { <nl> - return NaN ; <nl> + return INF ; <nl> } <nl> if ( isInfinite ) { <nl> 
0<ml>TBar_Math-63_P_Patch_611_159.txt<ml>TBar_Math-63_P_Patch_611_159.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> return false ; <nl> } <nl> for ( int i = 0 ; i < x . length ; + + i ) { <nl> - if ( ! equals ( x [ i ] , y [ i ] ) ) { <nl> + if ( ! equals ( x [ i ] , y [ i ] , i ) ) { <nl> return false ; <nl> } <nl> } <nl> 
0<ml>TBar_Lang-44_P_Patch_4046_2567.txt<ml>TBar_Lang-44_P_Patch_4046_2567.txt<ml>mmm a / src / java / org / apache / commons / lang / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / NumberUtils . java <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> - if ( dec = = null <nl> + if ( dec ! = numeric | | ( dec = = null <nl> & & exp = = null <nl> - & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> + & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> } catch ( NumberFormatException nfe ) { <nl> 
0<ml>TBar_Math-84_P_Patch_114_72.txt<ml>TBar_Math-84_P_Patch_114_72.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( comparator . compare ( contracted , best ) < 0 ) { <nl> + if ( comparator . compare ( contracted , best ) = = 0 ) { <nl> / / accept the contracted simplex <nl> / / check convergence <nl> 
1<ml>TBar_Chart-24_C_Patch_42_20.txt<ml>TBar_Chart-24_C_Patch_42_20.txt<ml>mmm a / source / org / jfree / chart / renderer / GrayPaintScale . java <nl> ppp b / source / org / jfree / chart / renderer / GrayPaintScale . java <nl> public Paint getPaint ( double value ) { <nl> double v = Math . max ( value , this . lowerBound ) ; <nl> v = Math . min ( v , this . upperBound ) ; <nl> - int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound <nl> + int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound <nl> - this . lowerBound ) * 255 . 0 ) ; <nl> return new Color ( g , g , g ) ; <nl> } <nl> 
0<ml>TBar_Chart-15_P_Patch_220_119.txt<ml>TBar_Chart-15_P_Patch_220_119.txt<ml>mmm a / source / org / jfree / chart / plot / PiePlot3D . java <nl> ppp b / source / org / jfree / chart / plot / PiePlot3D . java <nl> notifyListeners ( new PlotChangeEvent ( this ) ) ; <nl> } <nl> - / * * <nl> - * Draws the plot on a Java 2D graphics device ( such as the screen or a <nl> - * printer ) . This method is called by the <nl> - * { @ link org . jfree . chart . JFreeChart } class , you don ' t normally need <nl> - * to call it yourself . <nl> - * <nl> - * @ param g2 the graphics device . <nl> - * @ param plotArea the area within which the plot should be drawn . <nl> - * @ param anchor the anchor point . <nl> - * @ param parentState the state from the parent plot , if there is one . <nl> - * @ param info collects info about the drawing <nl> - * ( < code > null < / code > permitted ) . <nl> - * / <nl> - public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , <nl> - PlotState parentState , <nl> - PlotRenderingInfo info ) { <nl> - <nl> - / / adjust for insets . . . <nl> - RectangleInsets insets = getInsets ( ) ; <nl> - insets . trim ( plotArea ) ; <nl> - <nl> - Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; <nl> - if ( info ! = null ) { <nl> - info . setPlotArea ( plotArea ) ; <nl> - info . setDataArea ( plotArea ) ; <nl> - } <nl> - <nl> - drawBackground ( g2 , plotArea ) ; <nl> - <nl> - Shape savedClip = g2 . getClip ( ) ; <nl> - g2 . clip ( plotArea ) ; <nl> - <nl> - / / adjust the plot area by the interior spacing value <nl> - double gapPercent = getInteriorGap ( ) ; <nl> - double labelPercent = 0 . 0 ; <nl> - if ( getLabelGenerator ( ) ! = null ) { <nl> - labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; <nl> - } <nl> - double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent <nl> - + labelPercent ) * 2 . 0 ; <nl> - double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; <nl> - <nl> - if ( DEBUG_DRAW_INTERIOR ) { <nl> - double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; <nl> - double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; <nl> - double igx1 = plotArea . getX ( ) + hGap ; <nl> - double igx2 = plotArea . getMaxX ( ) - hGap ; <nl> - double igy1 = plotArea . getY ( ) + vGap ; <nl> - double igy2 = plotArea . getMaxY ( ) - vGap ; <nl> - g2 . setPaint ( Color . lightGray ) ; <nl> - g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , <nl> - igy2 - igy1 ) ) ; <nl> - } <nl> - <nl> - double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; <nl> - double linkY = plotArea . getY ( ) + gapVertical / 2 ; <nl> - double linkW = plotArea . getWidth ( ) - gapHorizontal ; <nl> - double linkH = plotArea . getHeight ( ) - gapVertical ; <nl> - <nl> - / / make the link area a square if the pie chart is to be circular . . . <nl> - if ( isCircular ( ) ) { / / is circular ? <nl> - double min = Math . min ( linkW , linkH ) / 2 ; <nl> - linkX = ( linkX + linkX + linkW ) / 2 - min ; <nl> - linkY = ( linkY + linkY + linkH ) / 2 - min ; <nl> - linkW = 2 * min ; <nl> - linkH = 2 * min ; <nl> - } <nl> - <nl> - PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; <nl> - <nl> - / / the link area defines the dog leg points for the linking lines to <nl> - / / the labels <nl> - Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , <nl> - linkH * ( 1 - this . depthFactor ) ) ; <nl> - state . setLinkArea ( linkAreaXX ) ; <nl> - <nl> - if ( DEBUG_DRAW_LINK_AREA ) { <nl> - g2 . setPaint ( Color . blue ) ; <nl> - g2 . draw ( linkAreaXX ) ; <nl> - g2 . setPaint ( Color . yellow ) ; <nl> - g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , <nl> - linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; <nl> - } <nl> - <nl> - / / the explode area defines the max circle / ellipse for the exploded pie <nl> - / / sections . <nl> - / / it is defined by shrinking the linkArea by the linkMargin factor . <nl> - double hh = linkW * getLabelLinkMargin ( ) ; <nl> - double vv = linkH * getLabelLinkMargin ( ) ; <nl> - Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , <nl> - linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ; <nl> - <nl> - state . setExplodedPieArea ( explodeArea ) ; <nl> - <nl> - / / the pie area defines the circle / ellipse for regular pie sections . <nl> - / / it is defined by shrinking the explodeArea by the explodeMargin <nl> - / / factor . <nl> - double maximumExplodePercent = getMaximumExplodePercent ( ) ; <nl> - double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ; <nl> - <nl> - double h1 = explodeArea . getWidth ( ) * percent ; <nl> - double v1 = explodeArea . getHeight ( ) * percent ; <nl> - Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) <nl> - + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , <nl> - explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; <nl> - <nl> - / / the link area defines the dog - leg point for the linking lines to <nl> - / / the labels <nl> - int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; <nl> - Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , <nl> - linkH - depth ) ; <nl> - state . setLinkArea ( linkArea ) ; <nl> - <nl> - state . setPieArea ( pieArea ) ; <nl> - state . setPieCenterX ( pieArea . getCenterX ( ) ) ; <nl> - state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; <nl> - state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; <nl> - state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; <nl> - <nl> - / / get the data source - return if null ; <nl> - PieDataset dataset = getDataset ( ) ; <nl> - if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { <nl> - drawNoDataMessage ( g2 , plotArea ) ; <nl> - g2 . setClip ( savedClip ) ; <nl> - drawOutline ( g2 , plotArea ) ; <nl> - return ; <nl> - } <nl> - <nl> - / / if too any elements <nl> - if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { <nl> - String text = " Too many elements " ; <nl> - Font sfont = new Font ( " dialog " , Font . BOLD , 10 ) ; <nl> - g2 . setFont ( sfont ) ; <nl> - FontMetrics fm = g2 . getFontMetrics ( sfont ) ; <nl> - int stringWidth = fm . stringWidth ( text ) ; <nl> - <nl> - g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) <nl> - - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) <nl> - + ( plotArea . getHeight ( ) / 2 ) ) ) ; <nl> - return ; <nl> - } <nl> - / / if we are drawing a perfect circle , we need to readjust the top left <nl> - / / coordinates of the drawing area for the arcs to arrive at this <nl> - / / effect . <nl> - if ( isCircular ( ) ) { <nl> - double min = Math . min ( plotArea . getWidth ( ) , <nl> - plotArea . getHeight ( ) ) / 2 ; <nl> - plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , <nl> - plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; <nl> - } <nl> - / / get a list of keys . . . <nl> - List sectionKeys = dataset . getKeys ( ) ; <nl> - <nl> - if ( sectionKeys . size ( ) = = 0 ) { <nl> - return ; <nl> - } <nl> - <nl> - / / establish the coordinates of the top left corner of the drawing area <nl> - double arcX = pieArea . getX ( ) ; <nl> - double arcY = pieArea . getY ( ) ; <nl> - <nl> - / / g2 . clip ( clipArea ) ; <nl> - Composite originalComposite = g2 . getComposite ( ) ; <nl> - g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , <nl> - getForegroundAlpha ( ) ) ) ; <nl> - <nl> - double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; <nl> - double runningTotal = 0 ; <nl> - if ( depth < 0 ) { <nl> - return ; / / if depth is negative don ' t draw anything <nl> - } <nl> - <nl> - ArrayList arcList = new ArrayList ( ) ; <nl> - Arc2D . Double arc ; <nl> - Paint paint ; <nl> - Paint outlinePaint ; <nl> - Stroke outlineStroke ; <nl> - <nl> - Iterator iterator = sectionKeys . iterator ( ) ; <nl> - while ( iterator . hasNext ( ) ) { <nl> - <nl> - Comparable currentKey = ( Comparable ) iterator . next ( ) ; <nl> - Number dataValue = dataset . getValue ( currentKey ) ; <nl> - if ( dataValue = = null ) { <nl> - arcList . add ( null ) ; <nl> - continue ; <nl> - } <nl> - double value = dataValue . doubleValue ( ) ; <nl> - if ( value < = 0 ) { <nl> - arcList . add ( null ) ; <nl> - continue ; <nl> - } <nl> - double startAngle = getStartAngle ( ) ; <nl> - double direction = getDirection ( ) . getFactor ( ) ; <nl> - double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) <nl> - / totalValue ; <nl> - double angle2 = startAngle + ( direction * ( runningTotal + value ) <nl> - * 360 ) / totalValue ; <nl> - if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { <nl> - arcList . add ( new Arc2D . Double ( arcX , arcY + depth , <nl> - pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , <nl> - angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; <nl> - } <nl> - else { <nl> - arcList . add ( null ) ; <nl> - } <nl> - runningTotal + = value ; <nl> - } <nl> - <nl> - Shape oldClip = g2 . getClip ( ) ; <nl> - <nl> - Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , <nl> - pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ; <nl> - <nl> - Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) <nl> - + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ; <nl> - <nl> - Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , <nl> - top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) <nl> - - top . getCenterY ( ) ) ; <nl> - <nl> - Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , <nl> - pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ; <nl> - <nl> - Area a = new Area ( top ) ; <nl> - a . add ( new Area ( lower ) ) ; <nl> - Area b = new Area ( bottom ) ; <nl> - b . add ( new Area ( upper ) ) ; <nl> - Area pie = new Area ( a ) ; <nl> - pie . intersect ( b ) ; <nl> - <nl> - Area front = new Area ( pie ) ; <nl> - front . subtract ( new Area ( top ) ) ; <nl> - <nl> - Area back = new Area ( pie ) ; <nl> - back . subtract ( new Area ( bottom ) ) ; <nl> - <nl> - / / draw the bottom circle <nl> - int [ ] xs ; <nl> - int [ ] ys ; <nl> - arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , <nl> - pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; <nl> - <nl> - int categoryCount = arcList . size ( ) ; <nl> - for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; <nl> - categoryIndex + + ) { <nl> - arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; <nl> - if ( arc = = null ) { <nl> - continue ; <nl> - } <nl> - Comparable key = getSectionKey ( categoryIndex ) ; <nl> - paint = lookupSectionPaint ( key , true ) ; <nl> - outlinePaint = lookupSectionOutlinePaint ( key ) ; <nl> - outlineStroke = lookupSectionOutlineStroke ( key ) ; <nl> - g2 . setPaint ( paint ) ; <nl> - g2 . fill ( arc ) ; <nl> - g2 . setPaint ( outlinePaint ) ; <nl> - g2 . setStroke ( outlineStroke ) ; <nl> - g2 . draw ( arc ) ; <nl> - g2 . setPaint ( paint ) ; <nl> - <nl> - Point2D p1 = arc . getStartPoint ( ) ; <nl> - <nl> - / / draw the height <nl> - xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , <nl> - ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; <nl> - ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) <nl> - - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; <nl> - Polygon polygon = new Polygon ( xs , ys , 4 ) ; <nl> - g2 . setPaint ( java . awt . Color . lightGray ) ; <nl> - g2 . fill ( polygon ) ; <nl> - g2 . setPaint ( outlinePaint ) ; <nl> - g2 . setStroke ( outlineStroke ) ; <nl> - g2 . draw ( polygon ) ; <nl> - g2 . setPaint ( paint ) ; <nl> - <nl> - } <nl> - <nl> - g2 . setPaint ( Color . gray ) ; <nl> - g2 . fill ( back ) ; <nl> - g2 . fill ( front ) ; <nl> - <nl> - / / cycle through once drawing only the sides at the back . . . <nl> - int cat = 0 ; <nl> - iterator = arcList . iterator ( ) ; <nl> - while ( iterator . hasNext ( ) ) { <nl> - Arc2D segment = ( Arc2D ) iterator . next ( ) ; <nl> - if ( segment ! = null ) { <nl> - Comparable key = getSectionKey ( cat ) ; <nl> - paint = lookupSectionPaint ( key , true ) ; <nl> - outlinePaint = lookupSectionOutlinePaint ( key ) ; <nl> - outlineStroke = lookupSectionOutlineStroke ( key ) ; <nl> - drawSide ( g2 , pieArea , segment , front , back , paint , <nl> - outlinePaint , outlineStroke , false , true ) ; <nl> - } <nl> - cat + + ; <nl> - } <nl> - <nl> - / / cycle through again drawing only the sides at the front . . . <nl> - cat = 0 ; <nl> - iterator = arcList . iterator ( ) ; <nl> - while ( iterator . hasNext ( ) ) { <nl> - Arc2D segment = ( Arc2D ) iterator . next ( ) ; <nl> - if ( segment ! = null ) { <nl> - Comparable key = getSectionKey ( cat ) ; <nl> - paint = lookupSectionPaint ( key ) ; <nl> - outlinePaint = lookupSectionOutlinePaint ( key ) ; <nl> - outlineStroke = lookupSectionOutlineStroke ( key ) ; <nl> - drawSide ( g2 , pieArea , segment , front , back , paint , <nl> - outlinePaint , outlineStroke , true , false ) ; <nl> - } <nl> - cat + + ; <nl> - } <nl> - <nl> - g2 . setClip ( oldClip ) ; <nl> - <nl> - / / draw the sections at the top of the pie ( and set up tooltips ) . . . <nl> - Arc2D upperArc ; <nl> - for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; <nl> - sectionIndex + + ) { <nl> - arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; <nl> - if ( arc = = null ) { <nl> - continue ; <nl> - } <nl> - upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , <nl> - pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , <nl> - arc . getAngleExtent ( ) , Arc2D . PIE ) ; <nl> - <nl> - Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; <nl> - paint = lookupSectionPaint ( currentKey , true ) ; <nl> - outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; <nl> - outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; <nl> - g2 . setPaint ( paint ) ; <nl> - g2 . fill ( upperArc ) ; <nl> - g2 . setStroke ( outlineStroke ) ; <nl> - g2 . setPaint ( outlinePaint ) ; <nl> - g2 . draw ( upperArc ) ; <nl> - <nl> - / / add a tooltip for the section . . . <nl> - if ( info ! = null ) { <nl> - EntityCollection entities <nl> - = info . getOwner ( ) . getEntityCollection ( ) ; <nl> - if ( entities ! = null ) { <nl> - String tip = null ; <nl> - PieToolTipGenerator tipster = getToolTipGenerator ( ) ; <nl> - if ( tipster ! = null ) { <nl> - / / @ mgs : using the method ' s return value was missing <nl> - tip = tipster . generateToolTip ( dataset , currentKey ) ; <nl> - } <nl> - String url = null ; <nl> - if ( getURLGenerator ( ) ! = null ) { <nl> - url = getURLGenerator ( ) . generateURL ( dataset , currentKey , <nl> - getPieIndex ( ) ) ; <nl> - } <nl> - PieSectionEntity entity = new PieSectionEntity ( <nl> - upperArc , dataset , getPieIndex ( ) , sectionIndex , <nl> - currentKey , tip , url ) ; <nl> - entities . add ( entity ) ; <nl> - } <nl> - } <nl> - List keys = dataset . getKeys ( ) ; <nl> - Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( <nl> - originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , <nl> - originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) <nl> - - depth ) ; <nl> - if ( getSimpleLabels ( ) ) { <nl> - drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , <nl> - linkArea , state ) ; <nl> - } <nl> - else { <nl> - drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , <nl> - state ) ; <nl> - } <nl> - } <nl> - <nl> - g2 . setClip ( savedClip ) ; <nl> - g2 . setComposite ( originalComposite ) ; <nl> - drawOutline ( g2 , originalPlotArea ) ; <nl> - <nl> - } <nl> + <nl> / * * <nl> * Draws the side of a pie section . <nl> 
1<ml>TBar_Chart-11_C_Patch_102_60.txt<ml>TBar_Chart-11_C_Patch_102_60.txt<ml>mmm a / source / org / jfree / chart / util / ShapeUtilities . java <nl> ppp b / source / org / jfree / chart / util / ShapeUtilities . java <nl> if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { <nl> return false ; <nl> } <nl> - PathIterator iterator1 = p1 . getPathIterator ( null ) ; <nl> + PathIterator iterator1 = p2 . getPathIterator ( null ) ; <nl> PathIterator iterator2 = p1 . getPathIterator ( null ) ; <nl> double [ ] d1 = new double [ 6 ] ; <nl> double [ ] d2 = new double [ 6 ] ; <nl> 
1<ml>TBar_Chart-4_C_Patch_2689_1263.txt<ml>TBar_Chart-4_C_Patch_2689_1263.txt<ml>mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> } <nl> } <nl> - Collection c = r . getAnnotations ( ) ; <nl> + if ( r ! = null ) { <nl> + Collection c = r . getAnnotations ( ) ; <nl> Iterator i = c . iterator ( ) ; <nl> while ( i . hasNext ( ) ) { <nl> XYAnnotation a = ( XYAnnotation ) i . next ( ) ; <nl> if ( a instanceof XYAnnotationBoundsInfo ) { <nl> includedAnnotations . add ( a ) ; <nl> } <nl> - } <nl> + } <nl> + } <nl> + <nl> } <nl> } <nl> 
0<ml>TBar_Closure-66_P_Patch_9_6.txt<ml>TBar_Closure-66_P_Patch_9_6.txt<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> * @ return a number between 0 . 0 and 100 . 0 <nl> * / <nl> double getTypedPercent ( ) { <nl> - int total = nullCount + unknownCount + typedCount ; <nl> + int total = this . noTypeCheckSection + unknownCount + typedCount ; <nl> if ( total = = 0 ) { <nl> return 0 . 0 ; <nl> } else { <nl> 
1<ml>TBar_Math-79_C_Patch_293_124.txt<ml>TBar_Math-79_C_Patch_293_124.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> * @ return the L < sub > 2 < / sub > distance between the two points <nl> * / <nl> public static double distance ( int [ ] p1 , int [ ] p2 ) { <nl> - int sum = 0 ; <nl> + double sum = 0 ; <nl> for ( int i = 0 ; i < p1 . length ; i + + ) { <nl> - final int dp = p1 [ i ] - p2 [ i ] ; <nl> + final double dp = p1 [ i ] - p2 [ i ] ; <nl> sum + = dp * dp ; <nl> } <nl> return Math . sqrt ( sum ) ; <nl> 
0<ml>TBar_Closure-22_P_Patch_5_5.txt<ml>TBar_Closure-22_P_Patch_5_5.txt<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> if ( n = = parent . getLastChild ( ) ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = Token . COMMA ) <nl> + if ( ancestorType > = Token . COMMA ) <nl> continue ; <nl> if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) <nl> return ; <nl> 
1<ml>TBar_Lang-10_C_Patch_2435_1012.txt<ml>TBar_Lang-10_C_Patch_2435_1012.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> boolean wasWhite = false ; <nl> for ( int i = 0 ; i < value . length ( ) ; + + i ) { <nl> char c = value . charAt ( i ) ; <nl> - if ( Character . isWhitespace ( c ) ) { <nl> - if ( ! wasWhite ) { <nl> - wasWhite = true ; <nl> - regex . append ( " \ \ s * + " ) ; <nl> - } <nl> - continue ; <nl> - } <nl> + <nl> wasWhite = false ; <nl> switch ( c ) { <nl> case ' \ ' ' : <nl> 
0<ml>TBar_Math-6_P_Patch_5_2.txt<ml>TBar_Math-6_P_Patch_5_2.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java <nl> * @ return the number of evaluations of the objective function . <nl> * / <nl> public int getIterations ( ) { <nl> - return iterations . getCount ( ) ; <nl> + return this . evaluations . getCount ( ) ; <nl> } <nl> / * * <nl> 
0<ml>TBar_Closure-133_P_Patch_433_171.txt<ml>TBar_Closure-133_P_Patch_433_171.txt<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> / / Find the return ' s description ( if applicable ) . <nl> if ( jsdocBuilder . shouldParseDocumentation ( ) ) { <nl> ExtractionInfo returnDescriptionInfo = <nl> - extractMultilineTextualBlock ( token ) ; <nl> + extractMultilineTextualBlock ( current ( ) ) ; <nl> String returnDescription = <nl> returnDescriptionInfo . string ; <nl> 
0<ml>TBar_Lang-22_P_Patch_1806_847.txt<ml>TBar_Lang-22_P_Patch_1806_847.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / Fraction . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / Fraction . java <nl> private static int greatestCommonDivisor ( int u , int v ) { <nl> / / From Commons Math : <nl> / / if either operand is abs 1 , return 1 : <nl> - if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { <nl> + if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { <nl> return 1 ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> 
1<ml>TBar_Lang-47_C_Patch_1732_1023.txt<ml>TBar_Lang-47_C_Patch_1732_1023.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> if ( width > 0 ) { <nl> ensureCapacity ( size + width ) ; <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> - int strLen = str . length ( ) ; <nl> + if ( str = = null ) str = new String ( ) ; <nl> + int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> str . getChars ( strLen - width , strLen , buffer , size ) ; <nl> } else { <nl> mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> if ( width > 0 ) { <nl> ensureCapacity ( size + width ) ; <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> - int strLen = str . length ( ) ; <nl> + if ( str = = null ) str = new String ( ) ; <nl> + int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> str . getChars ( 0 , width , buffer , size ) ; <nl> } else { <nl> 
0<ml>TBar_Lang-43_P_Patch_368_183.txt<ml>TBar_Lang-43_P_Patch_368_183.txt<ml>mmm a / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java <nl> ppp b / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java <nl> while ( pos . getIndex ( ) < pattern . length ( ) ) { <nl> switch ( c [ pos . getIndex ( ) ] ) { <nl> case QUOTE : <nl> - appendQuotedString ( pattern , pos , stripCustom , true ) ; <nl> + appendQuotedString ( pattern , pos , stripCustom , false ) ; <nl> break ; <nl> case START_FE : <nl> fmtCount + + ; <nl> 
1<ml>TBar_Math-89_C_Patch_14_12.txt<ml>TBar_Math-89_C_Patch_14_12.txt<ml>mmm a / src / java / org / apache / commons / math / stat / Frequency . java <nl> ppp b / src / java / org / apache / commons / math / stat / Frequency . java <nl> * / <nl> @ Deprecated <nl> public void addValue ( Object v ) { <nl> - addValue ( ( Comparable < ? > ) v ) ; <nl> + if ( v instanceof Comparable < ? > ) { <nl> + addValue ( ( Comparable < ? > ) v ) ; <nl> + } else { <nl> + throw new IllegalArgumentException ( " Illegal argument : v " ) ; <nl> + } <nl> + <nl> } <nl> / * * <nl> 
0<ml>TBar_Math-8_P_Patch_47_16.txt<ml>TBar_Math-8_P_Patch_47_16.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; <nl> - for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> + for ( int i = 0 ; i = = sampleSize ; i + + ) { <nl> out [ i ] = sample ( ) ; <nl> } <nl> 
0<ml>TBar_Math-2_P_Patch_468_285.txt<ml>TBar_Math-2_P_Patch_468_285.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / HypergeometricDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / HypergeometricDistribution . java <nl> * / <nl> protected double calculateNumericalVariance ( ) { <nl> final double N = getPopulationSize ( ) ; <nl> - final double m = getNumberOfSuccesses ( ) ; <nl> - final double n = getSampleSize ( ) ; <nl> + final int m = getNumberOfSuccesses ( ) ; <nl> + final int n = getSampleSize ( ) ; <nl> return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; <nl> } <nl> 
1<ml>TBar_Lang-59_C_Patch_1657_1032.txt<ml>TBar_Lang-59_C_Patch_1657_1032.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> - str . getChars ( 0 , strLen , buffer , size ) ; <nl> + str . getChars ( 0 , width , buffer , size ) ; <nl> } else { <nl> int padLen = width - strLen ; <nl> str . getChars ( 0 , strLen , buffer , size ) ; <nl> 
0<ml>TBar_Lang-13_P_Patch_18_6.txt<ml>TBar_Lang-13_P_Patch_18_6.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java <nl> } <nl> - / * * <nl> - * Overriden version that uses the parametrized < code > ClassLoader < / code > or the < code > ClassLoader < / code > <nl> - * of the current < code > Thread < / code > to resolve the class . <nl> - * @ param desc An instance of class < code > ObjectStreamClass < / code > . <nl> - * @ return A < code > Class < / code > object corresponding to < code > desc < / code > . <nl> - * @ throws IOException Any of the usual Input / Output exceptions . <nl> - * @ throws ClassNotFoundException If class of a serialized object cannot be found . <nl> - * / <nl> - @ Override <nl> - protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { <nl> - String name = desc . getName ( ) ; <nl> - try { <nl> - return Class . forName ( name , false , classLoader ) ; <nl> - } catch ( ClassNotFoundException ex ) { <nl> - return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> - } <nl> - } <nl> + <nl> } <nl> 
0<ml>TBar_Closure-21_P_Patch_260_40.txt<ml>TBar_Closure-21_P_Patch_260_40.txt<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> if ( n = = parent . getLastChild ( ) ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = Token . COMMA ) continue ; <nl> + if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; <nl> if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> else break ; <nl> } <nl> 
0<ml>TBar_Chart-12_P_Patch_39_22.txt<ml>TBar_Chart-12_P_Patch_39_22.txt<ml>mmm a / source / org / jfree / data / general / AbstractDataset . java <nl> ppp b / source / org / jfree / data / general / AbstractDataset . java <nl> * / <nl> public boolean hasListener ( EventListener listener ) { <nl> List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; <nl> - return list . contains ( listener ) ; <nl> + return list ! = null | | list . contains ( listener ) ; <nl> } <nl> / * * <nl> 
0<ml>TBar_Math-15_P_Patch_1163_932.txt<ml>TBar_Math-15_P_Patch_1163_932.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> / * Handle special case x < 0 * / <nl> if ( x < 0 ) { <nl> / / y is an even integer in this case <nl> - if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { <nl> + if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { <nl> return pow ( - x , y ) ; <nl> } <nl> 
1<ml>TBar_Math-11_C_Patch_31_8.txt<ml>TBar_Math-11_C_Patch_31_8.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / MultivariateNormalDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / MultivariateNormalDistribution . java <nl> throw new DimensionMismatchException ( vals . length , dim ) ; <nl> } <nl> - return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * <nl> + return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * <nl> FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * <nl> getExponentTerm ( vals ) ; <nl> } <nl> 
1<ml>TBar_Chart-9_C_Patch_497_311.txt<ml>TBar_Chart-9_C_Patch_497_311.txt<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period <nl> endIndex = endIndex - 1 ; / / so this is last item BEFORE end <nl> } <nl> - if ( endIndex < 0 ) { <nl> + if ( endIndex < startIndex | | ( endIndex < 0 ) ) { <nl> emptyRange = true ; <nl> } <nl> if ( emptyRange ) { <nl> 
0<ml>TBar_Chart-7_P_Patch_2_2.txt<ml>TBar_Chart-7_P_Patch_2_2.txt<ml>mmm a / source / org / jfree / data / time / TimePeriodValues . java <nl> ppp b / source / org / jfree / data / time / TimePeriodValues . java <nl> * @ return The index . <nl> * / <nl> public int getMaxMiddleIndex ( ) { <nl> - return this . maxMiddleIndex ; <nl> + return this . maxStartIndex ; <nl> + <nl> } <nl> / * * <nl> 
0<ml>FixMiner_Chart-26_P_Patch_2377_1050.txt<ml>FixMiner_Chart-26_P_Patch_2377_1050.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> / / if the plot area is too small , just return . . . <nl> boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; <nl> boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; <nl> - if ( b1 | | b2 ) { <nl> + if ( b1 | | ( getRenderer ( ) ! = null ) ) { <nl> return ; <nl> } <nl> 
0<ml>FixMiner_Lang-63_P_Patch_1_1.txt<ml>FixMiner_Lang-63_P_Patch_1_1.txt<ml>mmm a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> int startValue = start . get ( field ) ; <nl> if ( endValue < startValue ) { <nl> int newdiff = startValue - endValue ; <nl> - end . add ( field , newdiff ) ; <nl> + end . add ( newdiff , newdiff ) ; <nl> return newdiff ; <nl> } else { <nl> return 0 ; <nl> 
0<ml>FixMiner_Chart-17_P_Patch_47_25.txt<ml>FixMiner_Chart-17_P_Patch_47_25.txt<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> if ( start < 0 ) { <nl> throw new IllegalArgumentException ( " Requires start > = 0 . " ) ; <nl> } <nl> - if ( end < start ) { <nl> + if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { <nl> throw new IllegalArgumentException ( " Requires start < = end . " ) ; <nl> } <nl> TimeSeries copy = ( TimeSeries ) super . clone ( ) ; <nl> 
0<ml>FixMiner_Math-50_P_Patch_26_20.txt<ml>FixMiner_Math-50_P_Patch_26_20.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> break ; <nl> 
0<ml>FixMiner_Chart-13_P_Patch_1091_503.txt<ml>FixMiner_Chart-13_P_Patch_1091_503.txt<ml>mmm a / source / org / jfree / chart / block / BorderArrangement . java <nl> ppp b / source / org / jfree / chart / block / BorderArrangement . java <nl> h [ 1 ] = size . height ; <nl> } <nl> h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; <nl> - if ( this . leftBlock ! = null ) { <nl> + if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { <nl> RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> LengthConstraintType . RANGE , h [ 2 ] , null , <nl> 
0<ml>FixMiner_Chart-25_P_Patch_76_13.txt<ml>FixMiner_Chart-25_P_Patch_76_13.txt<ml>mmm a / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java <nl> ppp b / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java <nl> public Number getMeanValue ( int row , int column ) { <nl> Number result = null ; <nl> MeanAndStandardDeviation masd <nl> - = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; <nl> + = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; <nl> if ( masd ! = null ) { <nl> result = masd . getMean ( ) ; <nl> } <nl> 
0<ml>FixMiner_Math-81_P_Patch_19_8.txt<ml>FixMiner_Math-81_P_Patch_19_8.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> double b1 = work [ np - 2 ] ; <nl> double b2 = work [ np - 6 ] ; <nl> final double gam = dN2 ; <nl> - if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { <nl> + if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { <nl> return ; <nl> } <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> 
1<ml>FixMiner_Math-22_C_Patch_1_1.txt<ml>FixMiner_Math-22_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / UniformRealDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / UniformRealDistribution . java <nl> / * * { @ inheritDoc } * / <nl> public boolean isSupportUpperBoundInclusive ( ) { <nl> - return false ; <nl> + return true ; <nl> } <nl> / * * <nl> mmm a / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java <nl> / * * { @ inheritDoc } * / <nl> public boolean isSupportLowerBoundInclusive ( ) { <nl> - return true ; <nl> + return false ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> 
0<ml>FixMiner_Time-11_P_Patch_5839_1807.txt<ml>FixMiner_Time-11_P_Patch_5839_1807.txt<ml>mmm a / src / main / java / org / joda / time / tz / ZoneInfoCompiler . java <nl> ppp b / src / main / java / org / joda / time / tz / ZoneInfoCompiler . java <nl> * @ return true to log verbosely <nl> * / <nl> public static boolean verbose ( ) { <nl> - return cVerbose . get ( ) ; <nl> + return cVerbose ! = null | | cVerbose . get ( ) ; <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
0<ml>FixMiner_Chart-14_P_Patch_1940_564.txt<ml>FixMiner_Chart-14_P_Patch_1940_564.txt<ml>mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { <nl> + return false ; <nl> + } <nl> + boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { <nl> + return false ; <nl> + } <nl> + boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { <nl> + return false ; <nl> + } <nl> + boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> throw new IllegalArgumentException ( " Null ' marker ' argument . " ) ; <nl> } <nl> ArrayList markers ; <nl> - if ( layer = = Layer . FOREGROUND ) { <nl> + if ( layer ! = Layer . FOREGROUND ) { <nl> markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( <nl> } <nl> 
0<ml>FixMiner_Math-80_P_Patch_4341_2826.txt<ml>FixMiner_Math-80_P_Patch_4341_2826.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> } <nl> / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) <nl> - flipIfWarranted ( n , 2 ) ; <nl> + goodStep ( n , 2 ) ; <nl> / / two iterations with Li ' s test for initial splits <nl> initialSplits ( n ) ; <nl> 
0<ml>FixMiner_Closure-19_P_Patch_8_4.txt<ml>FixMiner_Closure-19_P_Patch_8_4.txt<ml>mmm a / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java <nl> ppp b / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java <nl> / / " this " references aren ' t currently modeled in the CFG . <nl> default : <nl> - throw new IllegalArgumentException ( " Node cannot be refined . \ n " + <nl> - node . toStringTree ( ) ) ; <nl> + <nl> } <nl> } <nl> 
0<ml>FixMiner_Math-63_P_Patch_4_4.txt<ml>FixMiner_Math-63_P_Patch_4_4.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> * @ return { @ code true } if the values are equal . <nl> * / <nl> public static boolean equals ( double x , double y ) { <nl> - return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; <nl> + return x = = y ; <nl> } <nl> / * * <nl> 
0<ml>FixMiner_Math-84_P_Patch_93_43.txt<ml>FixMiner_Math-84_P_Patch_93_43.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( comparator . compare ( contracted , best ) < 0 ) { <nl> + if ( comparator . compare ( contracted , best ) < = 0 ) { <nl> / / accept the contracted simplex <nl> / / check convergence <nl> 
1<ml>FixMiner_Chart-24_C_Patch_77_25.txt<ml>FixMiner_Chart-24_C_Patch_77_25.txt<ml>mmm a / source / org / jfree / chart / renderer / GrayPaintScale . java <nl> ppp b / source / org / jfree / chart / renderer / GrayPaintScale . java <nl> * / <nl> public Paint getPaint ( double value ) { <nl> double v = Math . max ( value , this . lowerBound ) ; <nl> - v = Math . min ( v , this . upperBound ) ; <nl> + value = Math . min ( v , this . upperBound ) ; <nl> int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound <nl> - this . lowerBound ) * 255 . 0 ) ; <nl> return new Color ( g , g , g ) ; <nl> 
0<ml>FixMiner_Chart-15_P_Patch_564_218.txt<ml>FixMiner_Chart-15_P_Patch_564_218.txt<ml>mmm a / source / org / jfree / chart / plot / PiePlot3D . java <nl> ppp b / source / org / jfree / chart / plot / PiePlot3D . java <nl> linkH = 2 * min ; <nl> } <nl> - PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; <nl> + if ( info = = null ) { <nl> + return ; <nl> + } <nl> + PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; <nl> / / the link area defines the dog leg points for the linking lines to <nl> / / the labels <nl> 
0<ml>FixMiner_Math-20_P_Patch_1_1.txt<ml>FixMiner_Math-20_P_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> * Default constructor , uses default parameters <nl> * / <nl> public CMAESOptimizer ( ) { <nl> - this ( 0 ) ; <nl> + <nl> } <nl> / * * <nl> 
0<ml>FixMiner_Chart-3_P_Patch_583_267.txt<ml>FixMiner_Chart-3_P_Patch_583_267.txt<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> this . data . remove ( 0 ) ; <nl> removed = true ; <nl> } <nl> - if ( removed ) { <nl> + if ( ( removed ) | | ! ( notify ) ) { <nl> findBoundsByIteration ( ) ; <nl> if ( notify ) { <nl> fireSeriesChanged ( ) ; <nl> 
0<ml>FixMiner_Lang-57_P_Patch_33_11.txt<ml>FixMiner_Lang-57_P_Patch_33_11.txt<ml>mmm a / src / java / org / apache / commons / lang / LocaleUtils . java <nl> ppp b / src / java / org / apache / commons / lang / LocaleUtils . java <nl> * @ return true if the locale is a known locale <nl> * / <nl> public static boolean isAvailableLocale ( Locale locale ) { <nl> - return cAvailableLocaleSet . contains ( locale ) ; <nl> + if ( cAvailableLocaleSet = = null ) { <nl> + return false ; <nl> + } <nl> + return cAvailableLocaleSet . contains ( locale ) ; <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
1<ml>FixMiner_Math-30_C_Patch_322_65.txt<ml>FixMiner_Math-30_C_Patch_322_65.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / stat / inference / MannWhitneyUTest . java <nl> ppp b / src / main / java / org / apache / commons / math3 / stat / inference / MannWhitneyUTest . java <nl> final int n2 ) <nl> throws ConvergenceException , MaxCountExceededException { <nl> - final int n1n2prod = n1 * n2 ; <nl> + final double n1n2prod = n1 * n2 ; <nl> / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation <nl> final double EU = n1n2prod / 2 . 0 ; <nl> 
0<ml>FixMiner_Chart-12_P_Patch_8_5.txt<ml>FixMiner_Chart-12_P_Patch_8_5.txt<ml>mmm a / source / org / jfree / data / general / AbstractDataset . java <nl> ppp b / source / org / jfree / data / general / AbstractDataset . java <nl> * @ see # removeChangeListener ( DatasetChangeListener ) <nl> * / <nl> public boolean hasListener ( EventListener listener ) { <nl> - List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; <nl> + List list = Arrays . asList ( listener ) ; <nl> return list . contains ( listener ) ; <nl> } <nl> 
0<ml>FixMiner_Closure-129_P_Patch_25_21.txt<ml>FixMiner_Closure-129_P_Patch_25_21.txt<ml>mmm a / src / com / google / javascript / rhino / Node . java <nl> ppp b / src / com / google / javascript / rhino / Node . java <nl> } <nl> } else if ( type = = Token . CALL ) { <nl> if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { <nl> - return false ; <nl> + return ( false ) | | ! ( recur ) ; <nl> } <nl> } <nl> 
0<ml>FixMiner_Chart-7_P_Patch_467_238.txt<ml>FixMiner_Chart-7_P_Patch_467_238.txt<ml>mmm a / source / org / jfree / data / time / TimePeriodValues . java <nl> ppp b / source / org / jfree / data / time / TimePeriodValues . java <nl> if ( this . minMiddleIndex > = 0 ) { <nl> long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) <nl> . getTime ( ) ; <nl> - long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) <nl> + long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) <nl> . getTime ( ) ; <nl> long minMiddle = s + ( e - s ) / 2 ; <nl> if ( middle < minMiddle ) { <nl> 
1<ml>ACS_Math-3_C_Patch_1_1.txt<ml>ACS_Math-3_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / util / MathArrays . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / MathArrays . java <nl> final double prodHighCur = prodHigh [ 0 ] ; <nl> - double prodHighNext = prodHigh [ 1 ] ; <nl> + if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; <nl> double sHighPrev = prodHighCur + prodHighNext ; <nl> double sPrime = sHighPrev - prodHighNext ; <nl> double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ; <nl> 
1<ml>ACS_Math-61_C_Patch_1_1.txt<ml>ACS_Math-61_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / distribution / PoissonDistributionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / distribution / PoissonDistributionImpl . java <nl> * See the License for the specific language governing permissions and <nl> * limitations under the License . <nl> * / <nl> - package org . apache . commons . math . distribution ; <nl> + package org . apache . commons . math . distribution ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; <nl> import java . io . Serializable ; <nl> * / <nl> public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { <nl> if ( p < = 0 ) { <nl> - throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; <nl> + if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; <nl> } <nl> mean = p ; <nl> normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ; <nl> 
1<ml>ACS_Math-82_C_Patch_125_18.txt<ml>ACS_Math-82_C_Patch_125_18.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { <nl> final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; <nl> final double entry = tableau . getEntry ( i , col ) ; <nl> - if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { <nl> - final double ratio = rhs / entry ; <nl> + if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; <nl> if ( ratio < minRatio ) { <nl> minRatio = ratio ; <nl> minRatioPos = i ; <nl> 
1<ml>ACS_Chart-19_C_Patch_6_4.txt<ml>ACS_Chart-19_C_Patch_6_4.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> * @ since 1 . 0 . 3 <nl> * / <nl> public int getDomainAxisIndex ( CategoryAxis axis ) { <nl> - return this . domainAxes . indexOf ( axis ) ; <nl> + if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; <nl> } <nl> / * * <nl> result = p . getRangeAxisIndex ( axis ) ; <nl> } <nl> } <nl> - return result ; <nl> + if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; <nl> } <nl> / * * <nl> 
1<ml>ACS_Math-35_C_Patch_11_11.txt<ml>ACS_Math-35_C_Patch_11_11.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java <nl> ppp b / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java <nl> * See the License for the specific language governing permissions and <nl> * limitations under the License . <nl> * / <nl> - package org . apache . commons . math3 . genetics ; <nl> + package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> final int populationLimit , <nl> final double elitismRate ) { <nl> super ( chromosomes , populationLimit ) ; <nl> - this . elitismRate = elitismRate ; <nl> + if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; <nl> } <nl> / * * <nl> * / <nl> public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { <nl> super ( populationLimit ) ; <nl> - this . elitismRate = elitismRate ; <nl> + if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = <nl> } <nl> / * * <nl> 
0<ml>ACS_Math-81_P_Patch_11_1.txt<ml>ACS_Math-81_P_Patch_11_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> / / approximate contribution to norm squared from i < nn - 2 . <nl> - if ( end - start > 2 ) { <nl> - b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> + if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> a2 = a2 + b2 ; <nl> for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <nl> if ( b2 = = 0 . 0 ) { <nl> 
1<ml>ACS_Lang-24_C_Patch_1_1.txt<ml>ACS_Lang-24_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> } <nl> if ( chars [ i ] = = ' l ' <nl> | | chars [ i ] = = ' L ' ) { <nl> - / / not allowing L with an exponent or decimal point <nl> + if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point <nl> return foundDigit & & ! hasExp ; <nl> } <nl> / / last character is illegal <nl> 
1<ml>ACS_Math-85_C_Patch_15_1.txt<ml>ACS_Math-85_C_Patch_15_1.txt<ml>mmm a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> ppp b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> - if ( fa * fb > = 0 . 0 ) { <nl> - throw new ConvergenceException ( <nl> + if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> 
0<ml>ACS_Math-28_P_Patch_2_1.txt<ml>ACS_Math-28_P_Patch_2_1.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java <nl> if ( minRatioPositions . size ( ) = = 0 ) { <nl> return null ; <nl> - } else if ( minRatioPositions . size ( ) > 1 ) { <nl> - / / there ' s a degeneracy as indicated by a tie in the minimum ratio test <nl> + } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test <nl> / / 1 . check if there ' s an artificial variable that can be forced out of the basis <nl> for ( Integer row : minRatioPositions ) { <nl> 
1<ml>ACS_Time-15_C_Patch_1_1.txt<ml>ACS_Time-15_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / joda / time / field / FieldUtils . java <nl> ppp b / src / main / java / org / joda / time / field / FieldUtils . java <nl> public static long safeMultiply ( long val1 , int val2 ) { <nl> switch ( val2 ) { <nl> case - 1 : <nl> - return - val1 ; <nl> + if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; <nl> case 0 : <nl> return 0L ; <nl> case 1 : <nl> 
1<ml>ACS_Math-4_C_Patch_2_2.txt<ml>ACS_Math-4_C_Patch_2_2.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java <nl> / / compute the intersection on infinite line <nl> Vector3D v1D = line . intersection ( subLine . line ) ; <nl> - / / check location of point with respect to first sub - line <nl> + if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line <nl> Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; <nl> / / check location of point with respect to second sub - line <nl> mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java <nl> / / compute the intersection on infinite line <nl> Vector2D v2D = line1 . intersection ( line2 ) ; <nl> - / / check location of point with respect to first sub - line <nl> + if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line <nl> Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; <nl> / / check location of point with respect to second sub - line <nl> 
1<ml>ACS_Chart-14_C_Patch_116_32.txt<ml>ACS_Chart-14_C_Patch_116_32.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> 
1<ml>ACS_Lang-7_C_Patch_1_1.txt<ml>ACS_Lang-7_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> if ( str . startsWith ( " - - " ) ) { <nl> - return null ; <nl> + if ( str . startsWith ( " - - " ) = = true ) { throw new NumberFormatException ( ) ; } return null ; <nl> } <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> int hexDigits = str . length ( ) - 2 ; / / drop 0x <nl> 
1<ml>ACS_Math-5_C_Patch_2_1.txt<ml>ACS_Math-5_C_Patch_2_1.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math3 / complex / Complex . java <nl> } <nl> if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { <nl> - return NaN ; <nl> + if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; <nl> } <nl> if ( isInfinite ) { <nl> 
0<ml>ACS_Math-73_P_Patch_1_1.txt<ml>ACS_Math-73_P_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> } <nl> - / / full Brent algorithm starting with provided initial guess <nl> + if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess <nl> return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> } <nl> 
1<ml>ACS_Math-90_C_Patch_1_1.txt<ml>ACS_Math-90_C_Patch_1_1.txt<ml>mmm a / src / java / org / apache / commons / math / stat / Frequency . java <nl> ppp b / src / java / org / apache / commons / math / stat / Frequency . java <nl> freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; <nl> } <nl> } catch ( ClassCastException ex ) { <nl> - / / TreeMap will throw ClassCastException if v is not comparable <nl> + if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable <nl> throw new IllegalArgumentException ( " Value not comparable to existing values . " ) ; <nl> } <nl> } <nl> 
1<ml>ACS_Lang-35_C_Patch_4_4.txt<ml>ACS_Lang-35_C_Patch_4_4.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / ArrayUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / ArrayUtils . java <nl> @ SuppressWarnings ( " unchecked " ) / / type must be T <nl> T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; <nl> newArray [ newArray . length - 1 ] = element ; <nl> - return newArray ; <nl> + if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; <nl> } <nl> / * * <nl> } else if ( element ! = null ) { <nl> clss = element . getClass ( ) ; <nl> } else { <nl> - return ( T [ ] ) new Object [ ] { null } ; <nl> + if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; <nl> } <nl> @ SuppressWarnings ( " unchecked " ) / / the add method creates an array of type clss , which is type T <nl> final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) <nl> 
0<ml>ACS_Math-97_P_Patch_13_13.txt<ml>ACS_Math-97_P_Patch_13_13.txt<ml>mmm a / src / java / org / apache / commons / math / analysis / BrentSolver . java <nl> ppp b / src / java / org / apache / commons / math / analysis / BrentSolver . java <nl> / / Verify bracketing <nl> double sign = yMin * yMax ; <nl> - if ( sign > = 0 ) { <nl> - / / check if either value is close to a zero <nl> + if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero <nl> / / neither value is close to zero and min and max do not bracket root . <nl> throw new IllegalArgumentException <nl> ( " Function values at endpoints do not have different signs . " + <nl> 
1<ml>ACS_Math-99_C_Patch_3_3.txt<ml>ACS_Math-99_C_Patch_3_3.txt<ml>mmm a / src / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / java / org / apache / commons / math / util / MathUtils . java <nl> int u = p ; <nl> int v = q ; <nl> if ( ( u = = 0 ) | | ( v = = 0 ) ) { <nl> - return ( Math . abs ( u ) + Math . abs ( v ) ) ; <nl> + if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 <nl> return 0 ; <nl> } <nl> int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; <nl> - return lcm ; <nl> + if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; <nl> } <nl> / * * <nl> 
0<ml>ACS_Math-93_P_Patch_5_5.txt<ml>ACS_Math-93_P_Patch_5_5.txt<ml>mmm a / src / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / java / org / apache / commons / math / util / MathUtils . java <nl> * @ version $ Revision $ $ Date $ <nl> * / <nl> public final class MathUtils { <nl> + private static long patch_method ( int n ) { <nl> + long result = 1 ; <nl> + for ( int i = 2 ; i < = n ; i + + ) { <nl> + result * = i ; <nl> + } <nl> + return result ; <nl> + } <nl> / * * Smallest positive number such that 1 - EPSILON is not numerically equal to 1 . * / <nl> public static final double EPSILON = 0x1 . 0p - 53 ; <nl> if ( n < 0 ) { <nl> throw new IllegalArgumentException ( " must have n > = 0 for n ! " ) ; <nl> } <nl> - return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; <nl> + if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; <nl> } <nl> / * * <nl> 
0<ml>kPAR_Math-40_P_Patch_452_264.txt<ml>kPAR_Math-40_P_Patch_452_264.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java <nl> / / the guessed root is either not strictly inside the interval or it <nl> / / is a NaN ( which occurs when some sampling points share the same y ) <nl> / / we try again with a lower interpolation order <nl> - if ( signChangeIndex - start > = end - signChangeIndex ) { <nl> + if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { <nl> / / we have more points before the sign change , drop the lowest point <nl> + + start ; <nl> } else { <nl> 
0<ml>kPAR_Math-7_P_Patch_405_243.txt<ml>kPAR_Math-7_P_Patch_405_243.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java <nl> final double maxCheckInterval , <nl> final double convergence , <nl> final int maxIterationCount ) { <nl> - addEventHandler ( handler , maxCheckInterval , convergence , <nl> + addEventHandler ( handler , maxIterationCount , convergence , <nl> maxIterationCount , <nl> new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; <nl> } <nl> 
0<ml>kPAR_Math-82_P_Patch_646_317.txt<ml>kPAR_Math-82_P_Patch_646_317.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> double minValue = 0 ; <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> - if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> + if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { <nl> minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> 
0<ml>kPAR_Math-88_P_Patch_269_135.txt<ml>kPAR_Math-88_P_Patch_269_135.txt<ml>mmm a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ( restrictToNonNegative ? 0 : mostNegative ) ; <nl> if ( basicRow ! = null ) { <nl> for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { <nl> - if ( tableau . getEntry ( basicRow , j ) = = 1 ) { <nl> + if ( tableau . getEntry ( basicRow , i ) = = 1 ) { <nl> coefficients [ i ] = 0 ; <nl> } <nl> } <nl> 
0<ml>kPAR_Lang-27_P_Patch_621_407.txt<ml>kPAR_Lang-27_P_Patch_621_407.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> mant = str . substring ( 0 , decPos ) ; <nl> } else { <nl> if ( expPos > - 1 ) { <nl> - mant = str . substring ( 0 , expPos ) ; <nl> + mant = str . substring ( 0 , INTEGER_ZERO ) ; <nl> } else { <nl> mant = str ; <nl> } <nl> 
0<ml>kPAR_Closure-126_P_Patch_25_3.txt<ml>kPAR_Closure-126_P_Patch_25_3.txt<ml>mmm a / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> ppp b / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> * block . See ECMA 262 Sections 8 . 9 & 12 . 14 <nl> * / <nl> if ( NodeUtil . hasFinally ( n ) ) { <nl> - Node finallyBlock = n . getLastChild ( ) ; <nl> + Node finallyBlock = n . getFirstChild ( ) ; <nl> tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> } <nl> } <nl> 
0<ml>kPAR_Lang-16_P_Patch_3010_1624.txt<ml>kPAR_Lang-16_P_Patch_3010_1624.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> } <nl> dec = null ; <nl> } <nl> - if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { <nl> + if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { <nl> if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { <nl> exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; <nl> } else { <nl> 
0<ml>kPAR_Lang-58_P_Patch_1889_735.txt<ml>kPAR_Lang-58_P_Patch_1889_735.txt<ml>mmm a / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> - if ( dec = = null <nl> - & & exp = = null <nl> + if ( dec = = null | | exp = = null <nl> & & isDigits ( numeric . substring ( 1 ) ) <nl> & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { <nl> try { <nl> 
0<ml>kPAR_Lang-41_P_Patch_223_61.txt<ml>kPAR_Lang-41_P_Patch_223_61.txt<ml>mmm a / src / java / org / apache / commons / lang / ClassUtils . java <nl> ppp b / src / java / org / apache / commons / lang / ClassUtils . java <nl> if ( cls = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> - return getShortClassName ( cls . getName ( ) ) ; <nl> + return getShortCanonicalName ( cls . getName ( ) ) ; <nl> } <nl> / * * <nl> mmm a / src / java / org / apache / commons / lang / ClassUtils . java <nl> ppp b / src / java / org / apache / commons / lang / ClassUtils . java <nl> if ( cls = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> - return getPackageName ( cls . getName ( ) ) ; <nl> + return getPackageCanonicalName ( cls . getName ( ) ) ; <nl> } <nl> / * * <nl> 
0<ml>kPAR_Lang-20_P_Patch_282_124.txt<ml>kPAR_Lang-20_P_Patch_282_124.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; <nl> + StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; <nl> + StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> 
0<ml>kPAR_Math-43_P_Patch_115_106.txt<ml>kPAR_Math-43_P_Patch_115_106.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> if ( ! ( varianceImpl instanceof Variance ) ) { <nl> varianceImpl . increment ( value ) ; <nl> } <nl> - if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { <nl> + if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { <nl> geoMeanImpl . increment ( value ) ; <nl> } <nl> n + + ; <nl> mmm a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> if ( ! ( meanImpl instanceof Mean ) ) { <nl> meanImpl . increment ( value ) ; <nl> } <nl> - if ( ! ( varianceImpl instanceof Variance ) ) { <nl> + if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { <nl> varianceImpl . increment ( value ) ; <nl> } <nl> if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { <nl> mmm a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> secondMoment . increment ( value ) ; <nl> / / If mean , variance or geomean have been overridden , <nl> / / need to increment these <nl> - if ( ! ( meanImpl instanceof Mean ) ) { <nl> + if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { <nl> meanImpl . increment ( value ) ; <nl> } <nl> if ( ! ( varianceImpl instanceof Variance ) ) { <nl> 
0<ml>kPAR_Math-49_P_Patch_2_1.txt<ml>kPAR_Math-49_P_Patch_2_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / MathRuntimeException . java <nl> ppp b / src / main / java / org / apache / commons / math / MathRuntimeException . java <nl> * / <nl> private static String buildMessage ( final Locale locale , final Localizable pattern , <nl> final Object . . . arguments ) { <nl> - return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; <nl> + return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; <nl> } <nl> / * * Gets the message in a specified locale . <nl> 
0<ml>kPAR_Math-104_P_Patch_485_406.txt<ml>kPAR_Math-104_P_Patch_485_406.txt<ml>mmm a / src / java / org / apache / commons / math / special / Gamma . java <nl> ppp b / src / java / org / apache / commons / math / special / Gamma . java <nl> ret = Double . NaN ; <nl> } else if ( x = = 0 . 0 ) { <nl> ret = 0 . 0 ; <nl> - } else if ( a > = 1 . 0 & & x > a ) { <nl> + } else if ( a > = 1 . 0 & & x > = a ) { <nl> / / use regularizedGammaQ because it should converge faster in this <nl> / / case . <nl> ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ; <nl> 
0<ml>kPAR_Math-62_P_Patch_118_71.txt<ml>kPAR_Math-62_P_Patch_118_71.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java <nl> try { <nl> final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; <nl> final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; <nl> - optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; <nl> + optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; <nl> } catch ( FunctionEvaluationException fee ) { <nl> optima [ i ] = null ; <nl> } catch ( ConvergenceException ce ) { <nl> 
0<ml>kPAR_Closure-46_P_Patch_223_30.txt<ml>kPAR_Closure-46_P_Patch_223_30.txt<ml>old mode 100755 <nl> new mode 100644 <nl> mmm a / src / com / google / javascript / rhino / jstype / RecordType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / RecordType . java <nl> @ Override <nl> public JSType getLeastSupertype ( JSType that ) { <nl> - if ( ! that . isRecordType ( ) ) { <nl> + if ( ! that . isNumberObjectType ( ) ) { <nl> return super . getLeastSupertype ( that ) ; <nl> } <nl> RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; <nl> 
0<ml>kPAR_Closure-63_P_Patch_22_19.txt<ml>kPAR_Closure-63_P_Patch_22_19.txt<ml>mmm a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> ppp b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> / / padding equal to the excerpt and arrow at the end <nl> / / charno = = sourceExpert . length ( ) means something is missing <nl> / / at the end of the line <nl> - if ( excerpt . equals ( LINE ) <nl> - & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { <nl> + if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( Character . isWhitespace ( c ) ) { <nl> 
0<ml>kPAR_Lang-51_P_Patch_83_75.txt<ml>kPAR_Lang-51_P_Patch_83_75.txt<ml>mmm a / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ppp b / src / java / org / apache / commons / lang / BooleanUtils . java <nl> } <nl> case 3 : { <nl> char ch = str . charAt ( 0 ) ; <nl> - if ( ch = = ' y ' ) { <nl> + if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { <nl> return <nl> ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> 
0<ml>kPAR_Chart-5_P_Patch_100_32.txt<ml>kPAR_Chart-5_P_Patch_100_32.txt<ml>mmm a / source / org / jfree / data / xy / XYSeries . java <nl> ppp b / source / org / jfree / data / xy / XYSeries . java <nl> / / Collections . binarySearch ( ) and tells us where to insert the <nl> / / new item . . . otherwise it will be just - 1 and we should just <nl> / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> + if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { <nl> this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> } <nl> else { <nl> 
0<ml>kPAR_Closure-115_P_Patch_232_166.txt<ml>kPAR_Closure-115_P_Patch_232_166.txt<ml>mmm a / src / com / google / javascript / jscomp / FunctionInjector . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionInjector . java <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> - if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> + if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> return CanInlineResult . NO ; <nl> } <nl> / / Check for arguments that are evaluated more than once . <nl> 
0<ml>kPAR_Lang-21_P_Patch_154_93.txt<ml>kPAR_Lang-21_P_Patch_154_93.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / DateUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / DateUtils . java <nl> return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & <nl> cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & <nl> cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & <nl> - cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & <nl> + cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & <nl> cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & <nl> cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & <nl> cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & <nl> 
0<ml>kPAR_Math-42_P_Patch_3449_1703.txt<ml>kPAR_Math-42_P_Patch_3449_1703.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; <nl> copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; <nl> matrix . setEntry ( zIndex , width - 1 , <nl> - maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; <nl> + maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; <nl> if ( ! restrictToNonNegative ) { <nl> matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 , <nl> 
0<ml>kPAR_Lang-44_P_Patch_3382_1595.txt<ml>kPAR_Lang-44_P_Patch_3382_1595.txt<ml>mmm a / src / java / org / apache / commons / lang / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / NumberUtils . java <nl> case ' l ' : <nl> case ' L ' : <nl> if ( dec = = null <nl> - & & exp = = null <nl> - & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> + & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> } catch ( NumberFormatException nfe ) { <nl> 
1<ml>kPAR_Math-58_C_Patch_130_85.txt<ml>kPAR_Math-58_C_Patch_130_85.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / fitting / GaussianFitter . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / fitting / GaussianFitter . java <nl> * / <nl> public double [ ] fit ( ) { <nl> final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; <nl> - return fit ( new Gaussian . Parametric ( ) , guess ) ; <nl> + return fit ( guess ) ; <nl> } <nl> / * * <nl> 
0<ml>kPAR_Lang-10_P_Patch_1577_529.txt<ml>kPAR_Lang-10_P_Patch_1577_529.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> boolean wasWhite = false ; <nl> for ( int i = 0 ; i < value . length ( ) ; + + i ) { <nl> char c = value . charAt ( i ) ; <nl> - if ( Character . isWhitespace ( c ) ) { <nl> + if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { <nl> if ( ! wasWhite ) { <nl> wasWhite = true ; <nl> regex . append ( " \ \ s * + " ) ; <nl> 
0<ml>kPAR_Time-17_P_Patch_5075_2912.txt<ml>kPAR_Time-17_P_Patch_5075_2912.txt<ml>mmm a / src / main / java / org / joda / time / DateTimeZone . java <nl> ppp b / src / main / java / org / joda / time / DateTimeZone . java <nl> / / evaluate 3 hours before and after to work out if anything is happening <nl> long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; <nl> - long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; <nl> + long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; <nl> if ( instantBefore = = instantAfter ) { <nl> return instant ; / / not an overlap ( less than is a gap , equal is normal case ) <nl> } <nl> 
0<ml>kPAR_Math-8_P_Patch_41_6.txt<ml>kPAR_Math-8_P_Patch_41_6.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> sampleSize ) ; <nl> } <nl> - final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; <nl> + final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; <nl> for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> out [ i ] = sample ( ) ; <nl> 
0<ml>kPAR_Math-2_P_Patch_155_56.txt<ml>kPAR_Math-2_P_Patch_155_56.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java <nl> final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | <nl> Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; <nl> if ( chebyshevApplies ) { <nl> - double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; <nl> + double k = FastMath . sqrt ( serialVersionUID ) ; <nl> double tmp = mu - k * sigma ; <nl> if ( tmp > lower ) { <nl> lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> 
0<ml>kPAR_Closure-35_P_Patch_27_13.txt<ml>kPAR_Closure-35_P_Patch_27_13.txt<ml>mmm a / src / com / google / javascript / jscomp / TypeInference . java <nl> ppp b / src / com / google / javascript / jscomp / TypeInference . java <nl> ObjectType constraintObj = <nl> ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; <nl> if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { <nl> - ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; <nl> + ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; <nl> if ( objType ! = null ) { <nl> for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { <nl> JSType propType = constraintObj . getPropertyType ( prop ) ; <nl> 
1<ml>kPAR_Closure-40_C_Patch_329_204.txt<ml>kPAR_Closure-40_C_Patch_329_204.txt<ml>mmm a / src / com / google / javascript / jscomp / NameAnalyzer . java <nl> ppp b / src / com / google / javascript / jscomp / NameAnalyzer . java <nl> Node nameNode = n . getFirstChild ( ) ; <nl> NameInformation ns = createNameInformation ( t , nameNode , n ) ; <nl> if ( ns ! = null & & ns . onlyAffectsClassDef ) { <nl> - JsName name = getName ( ns . name , false ) ; <nl> + JsName name = getName ( ns . name , true ) ; <nl> if ( name ! = null ) { <nl> refNodes . add ( new ClassDefiningFunctionNode ( <nl> name , n , parent , parent . getParent ( ) ) ) ; <nl> 
0<ml>kPAR_Math-15_P_Patch_524_360.txt<ml>kPAR_Math-15_P_Patch_524_360.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> / * Handle special case x < 0 * / <nl> if ( x < 0 ) { <nl> / / y is an even integer in this case <nl> - if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { <nl> + if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { <nl> return pow ( - x , y ) ; <nl> } <nl> 
0<ml>kPAR_Lang-59_P_Patch_382_208.txt<ml>kPAR_Lang-59_P_Patch_382_208.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> * / <nl> public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { <nl> if ( width > 0 ) { <nl> - ensureCapacity ( size + width ) ; <nl> + ensureCapacity ( padChar ) ; <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> 
0<ml>kPAR_Lang-53_P_Patch_1593_845.txt<ml>kPAR_Lang-53_P_Patch_1593_845.txt<ml>mmm a / src / java / org / apache / commons / lang / time / DateUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DateUtils . java <nl> } <nl> / / reset time <nl> - if ( date . getTime ( ) ! = time ) { <nl> + if ( ( ! round | | millisecs < 500 ) ) { <nl> date . setTime ( time ) ; <nl> val . setTime ( date ) ; <nl> } <nl> 
0<ml>RSRepair-A_Math-40_P_Patch_146_63.txt<ml>RSRepair-A_Math-40_P_Patch_146_63.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_40 / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2019 - 08 - 01 <nl> ppp  / tmp / RSRepair_Defects4J_Math_40 / patches_t4v6 / Patch_63 / patched / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2019 - 08 - 01 <nl> if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { <nl> / / the guessed root is not strictly inside of the tightest bracketing interval <nl> - / / the guessed root is either not strictly inside the interval or it <nl> + signChangeIndex = 2 ; <nl> + / / the guessed root is either not strictly inside the interval or it <nl> / / is a NaN ( which occurs when some sampling points share the same y ) <nl> / / we try again with a lower interpolation order <nl> if ( signChangeIndex - start > = end - signChangeIndex ) { <nl> 
0<ml>RSRepair-A_Math-103_P_Patch_1758_558.txt<ml>RSRepair-A_Math-103_P_Patch_1758_558.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_103 / src / java / org / apache / commons / math / special / Gamma . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_103 / patches_3693 / Patch_558 / patched / org / apache / commons / math / special / Gamma . java 	 2019 - 08 - 03 <nl> / / calculate series <nl> double n = 0 . 0 ; / / current element index <nl> double an = 1 . 0 / a ; / / n - th element in the series <nl> - double sum = an ; / / partial sum <nl> + if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { <nl> + ret = Double . NaN ; <nl> + } else { <nl> + double g = 607 . 0 / 128 . 0 ; <nl> + double sum = 0 . 0 ; <nl> + for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { <nl> + sum = sum + ( lanczos [ i ] / ( x + i ) ) ; <nl> + } <nl> + sum = sum + lanczos [ 0 ] ; <nl> + double tmp = x + g + . 5 ; <nl> + ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; <nl> + } <nl> + double sum = an ; / / partial sum <nl> while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { <nl> / / compute next element in the series <nl> n = n + 1 . 0 ; <nl> sum = sum + an ; <nl> } <nl> if ( n > = maxIterations ) { <nl> - throw new MaxIterationsExceededException ( maxIterations ) ; <nl> } else { <nl> ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; <nl> } <nl> 
0<ml>RSRepair-A_Closure-55_P_Patch_32_6.txt<ml>RSRepair-A_Closure-55_P_Patch_32_6.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_55 / src / com / google / javascript / jscomp / FunctionRewriter . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_55 / patches_83p1 / Patch_6 / patched / com / google / javascript / jscomp / FunctionRewriter . java 	 2019 - 08 - 12 <nl> for ( Reduction reduction : reductions ) { <nl> savings + = reduction . estimateSavings ( ) ; <nl> } <nl> - <nl> - / / Compare estimated savings against the helper cost . Apply <nl> - / / reductions if doing so will result in some savings . <nl> - if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { <nl> - for ( Reduction reduction : reductions ) { <nl> - reduction . apply ( ) ; <nl> - } <nl> - <nl> - Node addingRoot = compiler . getNodeForCodeInsertion ( null ) ; <nl> - addingRoot . addChildrenToFront ( helperCode ) ; <nl> - compiler . reportCodeChange ( ) ; <nl> - } <nl> } <nl> } <nl> 
0<ml>RSRepair-A_Closure-45_P_Patch_77_27.txt<ml>RSRepair-A_Closure-45_P_Patch_77_27.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_45 / src / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_45 / patches_t9am / Patch_27 / patched / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 12 <nl> return false ; <nl> } <nl> } <nl> - return true ; <nl> + return false ; <nl> case Token . REGEXP : <nl> / / Return true only if all children are const . <nl> 
1<ml>RSRepair-A_Closure-126_C_Patch_103_27.txt<ml>RSRepair-A_Closure-126_C_Patch_103_27.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPoints . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_126 / patches_qzki / Patch_27 / patched / com / google / javascript / jscomp / MinimizeExitPoints . java 	 2019 - 08 - 12 <nl> Node catchCodeBlock = catchNode . getLastChild ( ) ; <nl> tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; <nl> } <nl> - / * Don ' t try to minimize the exits of finally blocks , as this <nl> - * can cause problems if it changes the completion type of the finally <nl> - * block . See ECMA 262 Sections 8 . 9 & 12 . 14 <nl> - * / <nl> - if ( NodeUtil . hasFinally ( n ) ) { <nl> - Node finallyBlock = n . getLastChild ( ) ; <nl> - tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> - } <nl> } <nl> / / Just a ' label ' . <nl> 
0<ml>RSRepair-A_Chart-13_P_Patch_146_30.txt<ml>RSRepair-A_Chart-13_P_Patch_146_30.txt<ml>mmm  / tmp / RSRepair_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangement . java 	 2019 - 07 - 30 <nl> ppp  / tmp / RSRepair_Defects4J_Chart_13 / patches_wk3b / Patch_30 / patched / org / jfree / chart / block / BorderArrangement . java 	 2019 - 07 - 30 <nl> LengthConstraintType . RANGE , 0 . 0 , null , <nl> LengthConstraintType . NONE ) ; <nl> Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; <nl> - w [ 3 ] = size . width ; <nl> h [ 3 ] = size . height ; <nl> } <nl> mmm  / tmp / RSRepair_Defects4J_Chart_13 / source / org / jfree / data / Range . java 	 2019 - 07 - 30 <nl> ppp  / tmp / RSRepair_Defects4J_Chart_13 / patches_wk3b / Patch_30 / patched / org / jfree / data / Range . java 	 2019 - 07 - 30 <nl> if ( lower > upper ) { <nl> String msg = " Range ( double , double ) : require lower ( " + lower <nl> + " ) < = upper ( " + upper + " ) . " ; <nl> - throw new IllegalArgumentException ( msg ) ; <nl> + Comparable result = null ; <nl> } <nl> this . lower = lower ; <nl> this . upper = upper ; <nl> 
0<ml>RSRepair-A_Lang-16_P_Patch_983_418.txt<ml>RSRepair-A_Lang-16_P_Patch_983_418.txt<ml>mmm  / tmp / RSRepair_Defects4J_Lang_16 / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 31 <nl> ppp  / tmp / RSRepair_Defects4J_Lang_16 / patches_cukh / Patch_418 / patched / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 31 <nl> } <nl> / / $ FALL - THROUGH $ <nl> default : <nl> - throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> + return createInteger ( str ) ; <nl> } <nl> } else { <nl> 
0<ml>RSRepair-A_Chart-25_P_Patch_44_6.txt<ml>RSRepair-A_Chart-25_P_Patch_44_6.txt<ml>mmm  / tmp / RSRepair_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2019 - 07 - 30 <nl> ppp  / tmp / RSRepair_Defects4J_Chart_25 / patches_f34f / Patch_6 / patched / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2019 - 07 - 30 <nl> Number result = null ; <nl> MeanAndStandardDeviation masd <nl> = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; <nl> - if ( masd ! = null ) { <nl> - result = masd . getMean ( ) ; <nl> - } <nl> return result ; <nl> } <nl> mmm  / tmp / RSRepair_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2019 - 07 - 30 <nl> ppp  / tmp / RSRepair_Defects4J_Chart_25 / patches_f34f / Patch_6 / patched / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2019 - 07 - 30 <nl> rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; <nl> } <nl> else { <nl> - rectY = rectY + row * state . getBarWidth ( ) ; <nl> + RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; <nl> + rectY = rectY + row * state . getBarWidth ( ) ; <nl> } <nl> / / BAR X <nl> 
0<ml>RSRepair-A_Math-81_P_Patch_2_1.txt<ml>RSRepair-A_Math-81_P_Patch_2_1.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_81 / patches_73am / Patch_1 / patched / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 03 <nl> final int np = nn - 2 * pingPong ; <nl> double b1 = work [ np - 2 ] ; <nl> double b2 = work [ np - 6 ] ; <nl> - final double gam = dN2 ; <nl> + b2 = work [ nn - 5 ] / work [ nn - 7 ] ; <nl> + final double gam = dN2 ; <nl> if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { <nl> return ; <nl> } <nl> 
0<ml>RSRepair-A_Closure-114_P_Patch_34_13.txt<ml>RSRepair-A_Closure-114_P_Patch_34_13.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_114 / src / com / google / javascript / jscomp / AstChangeProxy . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_114 / patches_cw6o / Patch_13 / patched / com / google / javascript / jscomp / AstChangeProxy . java 	 2019 - 08 - 12 <nl> parent . replaceChild ( node , block ) ; <nl> } else { <nl> for ( Node newChild : replacements ) { <nl> - newChild . copyInformationFrom ( node ) ; <nl> parent . addChildBefore ( newChild , node ) ; <nl> } <nl> parent . removeChild ( node ) ; <nl> mmm  / tmp / RSRepair_Defects4J_Closure_114 / src / com / google / javascript / jscomp / NameAnalyzer . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_114 / patches_cw6o / Patch_13 / patched / com / google / javascript / jscomp / NameAnalyzer . java 	 2019 - 08 - 12 <nl> } <nl> if ( parent . isAssign ( ) ) { <nl> - return scopes . get ( parent ) ; <nl> } <nl> } <nl> 
0<ml>RSRepair-A_Math-28_P_Patch_28_11.txt<ml>RSRepair-A_Math-28_P_Patch_28_11.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2019 - 08 - 01 <nl> ppp  / tmp / RSRepair_Defects4J_Math_28 / patches_l2ve / Patch_11 / patched / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2019 - 08 - 01 <nl> } <nl> } <nl> } <nl> - return minRow ; <nl> } <nl> return minRatioPositions . get ( 0 ) ; <nl> } <nl> 
0<ml>RSRepair-A_Closure-33_P_Patch_1_1.txt<ml>RSRepair-A_Closure-33_P_Patch_1_1.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_33 / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_33 / patches_vf8d / Patch_1 / patched / com / google / javascript / rhino / jstype / PrototypeObjectType . java 	 2019 - 08 - 12 <nl> typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) <nl> . getLeastSupertype ( propType ) ; <nl> } <nl> - defineInferredProperty ( prop , typeToInfer , null ) ; <nl> } <nl> } <nl> } <nl> 
0<ml>RSRepair-A_Math-85_P_Patch_26_4.txt<ml>RSRepair-A_Math-85_P_Patch_26_4.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_85 / patches_86fl / Patch_4 / patched / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 08 - 03 <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> if ( fa * fb > = 0 . 0 ) { <nl> - throw new ConvergenceException ( <nl> - " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> - " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> - " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> - numIterations , maximumIterations , initial , <nl> - lowerBound , upperBound , a , b , fa , fb ) ; <nl> } <nl> return new double [ ] { a , b } ; <nl> mmm  / tmp / RSRepair_Defects4J_Math_85 / src / java / org / apache / commons / math / distribution / AbstractContinuousDistribution . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_85 / patches_86fl / Patch_4 / patched / org / apache / commons / math / distribution / AbstractContinuousDistribution . java 	 2019 - 08 - 03 <nl> if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { <nl> return lowerBound ; <nl> } <nl> - if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { <nl> - return upperBound ; <nl> - } <nl> / / Failed bracket convergence was not because of corner solution <nl> throw new MathException ( ex ) ; <nl> } <nl> 
0<ml>RSRepair-A_Math-95_P_Patch_167_36.txt<ml>RSRepair-A_Math-95_P_Patch_167_36.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_95 / patches_qui7 / Patch_36 / patched / org / apache / commons / math / distribution / FDistributionImpl . java 	 2019 - 08 - 03 <nl> protected double getInitialDomain ( double p ) { <nl> double ret ; <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> - / / use mean <nl> - ret = d / ( d - 2 . 0 ) ; <nl> + ret = 1 . 0 ; <nl> return ret ; <nl> } <nl> 
0<ml>RSRepair-A_Chart-5_P_Patch_440_130.txt<ml>RSRepair-A_Chart-5_P_Patch_440_130.txt<ml>mmm  / tmp / RSRepair_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeries . java 	 2019 - 07 - 29 <nl> ppp  / tmp / RSRepair_Defects4J_Chart_5 / patches_1jzm / Patch_130 / patched / org / jfree / data / xy / XYSeries . java 	 2019 - 07 - 30 <nl> existing . setY ( y ) ; <nl> } <nl> else { <nl> - / / if the series is sorted , the negative index is a result from <nl> - / / Collections . binarySearch ( ) and tells us where to insert the <nl> - / / new item . . . otherwise it will be just - 1 and we should just <nl> - / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> - this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> - } <nl> - else { <nl> - this . data . add ( new XYDataItem ( x , y ) ) ; <nl> - } <nl> + this . data . add ( new XYDataItem ( x , y ) ) ; <nl> / / check if this addition will exceed the maximum item count . . . <nl> if ( getItemCount ( ) > this . maximumItemCount ) { <nl> this . data . remove ( 0 ) ; <nl> 
0<ml>RSRepair-A_Closure-67_P_Patch_3_1.txt<ml>RSRepair-A_Closure-67_P_Patch_3_1.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_67 / src / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_67 / patches_6xe5 / Patch_1 / patched / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2019 - 08 - 12 <nl> boolean canRemove = false ; <nl> if ( specializationState = = null ) { <nl> - canRemove = true ; <nl> } else { <nl> Node specializableFunction = <nl> getSpecializableFunctionFromSymbol ( declaration ) ; <nl> 
0<ml>RSRepair-A_Closure-121_P_Patch_9_2.txt<ml>RSRepair-A_Closure-121_P_Patch_9_2.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_121 / src / com / google / javascript / jscomp / InlineVariables . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_121 / patches_jcct / Patch_2 / patched / com / google / javascript / jscomp / InlineVariables . java 	 2019 - 08 - 12 <nl> public void process ( Node externs , Node root ) { <nl> ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( <nl> compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; <nl> - callback . process ( externs , root ) ; <nl> } <nl> private Predicate < Var > getFilterForMode ( ) { <nl> 
0<ml>RSRepair-A_Math-80_P_Patch_9_7.txt<ml>RSRepair-A_Math-80_P_Patch_9_7.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 02 <nl> ppp  / tmp / RSRepair_Defects4J_Math_80 / patches_p656 / Patch_7 / patched / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 03 <nl> if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { <nl> / / flip array <nl> int j = 4 * n - 1 ; <nl> - for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> - work [ i + k ] = work [ j - k ] ; <nl> - work [ j - k ] = tmp ; <nl> - } <nl> - j - = 4 ; <nl> - } <nl> + int mBlockIndex = 0 ; <nl> return true ; <nl> } <nl> return false ; <nl> 
0<ml>RSRepair-A_Closure-130_P_Patch_10_2.txt<ml>RSRepair-A_Closure-130_P_Patch_10_2.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_130 / src / com / google / javascript / jscomp / CollapseProperties . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_130 / patches_ej0i / Patch_2 / patched / com / google / javascript / jscomp / CollapseProperties . java 	 2019 - 08 - 12 <nl> List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; <nl> for ( Ref ref : refs ) { <nl> if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { <nl> - / / { @ code name } meets condition ( c ) . Try to inline it . <nl> - if ( inlineAliasIfPossible ( ref , namespace ) ) { <nl> - name . removeRef ( ref ) ; <nl> - } <nl> } <nl> } <nl> } <nl> 
0<ml>RSRepair-A_Closure-59_P_Patch_64_27.txt<ml>RSRepair-A_Closure-59_P_Patch_64_27.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_59 / src / com / google / javascript / jscomp / WarningLevel . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_59 / patches_1gmg / Patch_27 / patched / com / google / javascript / jscomp / WarningLevel . java 	 2019 - 08 - 12 <nl> / / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . <nl> options . checkSuspiciousCode = true ; <nl> - options . checkGlobalThisLevel = CheckLevel . WARNING ; <nl> options . checkSymbols = true ; <nl> options . checkMissingReturn = CheckLevel . WARNING ; <nl> 
0<ml>RSRepair-A_Lang-7_P_Patch_208_103.txt<ml>RSRepair-A_Lang-7_P_Patch_208_103.txt<ml>mmm  / tmp / RSRepair_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 31 <nl> ppp  / tmp / RSRepair_Defects4J_Lang_7 / patches_q0u3 / Patch_103 / patched / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 31 <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> if ( str . startsWith ( " - - " ) ) { <nl> - return null ; <nl> + return Short . parseShort ( str ) ; <nl> } <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> int hexDigits = str . length ( ) - 2 ; / / drop 0x <nl> 
1<ml>RSRepair-A_Closure-115_C_Patch_20_8.txt<ml>RSRepair-A_Closure-115_C_Patch_20_8.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_115 / src / com / google / javascript / jscomp / FunctionInjector . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_115 / patches_v7z9 / Patch_8 / patched / com / google / javascript / jscomp / FunctionInjector . java 	 2019 - 08 - 12 <nl> Preconditions . checkState ( block . hasOneChild ( ) ) ; <nl> Node stmt = block . getFirstChild ( ) ; <nl> if ( stmt . isReturn ( ) ) { <nl> - hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; <nl> + int start = 0 ; <nl> } <nl> } <nl> / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] <nl> 
0<ml>RSRepair-A_Math-84_P_Patch_867_312.txt<ml>RSRepair-A_Math-84_P_Patch_867_312.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_84 / patches_d1k6 / Patch_312 / patched / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2019 - 08 - 03 <nl> while ( true ) { <nl> - incrementIterationsCounter ( ) ; <nl> + final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; <nl> + incrementIterationsCounter ( ) ; <nl> / / save the original vertex <nl> final RealPointValuePair [ ] original = simplex ; <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( comparator . compare ( contracted , best ) < 0 ) { <nl> - / / accept the contracted simplex <nl> - <nl> - / / check convergence <nl> - return ; <nl> - } <nl> + return ; <nl> } <nl> 
0<ml>RSRepair-A_Closure-78_P_Patch_53_25.txt<ml>RSRepair-A_Closure-78_P_Patch_53_25.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_78 / src / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_78 / patches_2wim / Patch_25 / patched / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2019 - 08 - 12 <nl> * / <nl> protected void error ( DiagnosticType diagnostic , Node n ) { <nl> JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; <nl> - currentTraversal . getCompiler ( ) . report ( error ) ; <nl> } <nl> / * * <nl> 
0<ml>RSRepair-A_Closure-124_P_Patch_10_3.txt<ml>RSRepair-A_Closure-124_P_Patch_10_3.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_124 / src / com / google / javascript / jscomp / ExploitAssigns . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_124 / patches_onp5 / Patch_3 / patched / com / google / javascript / jscomp / ExploitAssigns . java 	 2019 - 08 - 12 <nl> / / To protect against this , we simply only inline when the left side <nl> / / is guaranteed to evaluate to the same L - value no matter what . <nl> Node leftSide = next . getFirstChild ( ) ; <nl> - if ( leftSide . isName ( ) | | <nl> - leftSide . isGetProp ( ) & & <nl> - leftSide . getFirstChild ( ) . isThis ( ) ) { <nl> - / / Dive down the right side of the assign . <nl> - parent = next ; <nl> - next = leftSide . getNext ( ) ; <nl> - break ; <nl> - } else { <nl> - return false ; <nl> - } <nl> + ; <nl> default : <nl> if ( NodeUtil . isImmutableValue ( next ) <nl> 
0<ml>RSRepair-A_Closure-120_P_Patch_13_5.txt<ml>RSRepair-A_Closure-120_P_Patch_13_5.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_120 / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_120 / patches_gmns / Patch_5 / patched / com / google / javascript / jscomp / ReferenceCollectingCallback . java 	 2019 - 08 - 12 <nl> if ( t . getScope ( ) . isGlobal ( ) ) { <nl> / / Update global scope reference lists when we are done with it . <nl> compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; <nl> - behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; <nl> } else { <nl> behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; <nl> } <nl> 
0<ml>RSRepair-A_Math-58_P_Patch_4_3.txt<ml>RSRepair-A_Math-58_P_Patch_4_3.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_58 / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java 	 2019 - 08 - 03 <nl> ppp  / tmp / RSRepair_Defects4J_Math_58 / patches_vk2l / Patch_3 / patched / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java 	 2019 - 08 - 03 <nl> return ; <nl> } <nl> - / / compute the Newton correction <nl> - for ( int j = 0 ; j < solvedCols ; + + j ) { <nl> - int pj = permutation [ j ] ; <nl> - work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; <nl> - } <nl> for ( int j = 0 ; j < solvedCols ; + + j ) { <nl> int pj = permutation [ j ] ; <nl> work1 [ pj ] / = work2 [ j ] ; <nl> / / depending on the sign of the function , update parl or paru . <nl> if ( fp > 0 ) { <nl> parl = FastMath . max ( parl , lmPar ) ; <nl> - } else if ( fp < 0 ) { <nl> - paru = FastMath . min ( paru , lmPar ) ; <nl> - } <nl> + } else { <nl> + for ( int j = rank ; j < cols ; + + j ) { <nl> + lmDir [ permutation [ j ] ] = 0 ; <nl> + } <nl> + if ( fp < 0 ) { <nl> + paru = FastMath . min ( paru , lmPar ) ; <nl> + } <nl> + } <nl> / / compute an improved estimate for lmPar <nl> lmPar = FastMath . max ( parl , lmPar + correction ) ; <nl> 
0<ml>RSRepair-A_Math-33_P_Patch_8_3.txt<ml>RSRepair-A_Math-33_P_Patch_8_3.txt<ml>mmm  / tmp / RSRepair_Defects4J_Math_33 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java 	 2019 - 08 - 01 <nl> ppp  / tmp / RSRepair_Defects4J_Math_33 / patches_myeo / Patch_3 / patched / org / apache / commons / math3 / optimization / linear / SimplexTableau . java 	 2019 - 08 - 01 <nl> / / positive cost non - artificial variables <nl> for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { <nl> final double entry = tableau . getEntry ( 0 , i ) ; <nl> - if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { <nl> - columnsToDrop . add ( i ) ; <nl> - } <nl> } <nl> / / non - basic artificial variables <nl> 
0<ml>RSRepair-A_Closure-22_P_Patch_15_7.txt<ml>RSRepair-A_Closure-22_P_Patch_15_7.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_22 / patches_geao / Patch_7 / patched / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 12 <nl> / / This no - op statement was there so that JSDoc information could <nl> / / be attached to the name . This check should not complain about it . <nl> if ( n = = parent . getLastChild ( ) ) { <nl> - for ( Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = Token . COMMA ) <nl> - continue ; <nl> - if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) <nl> - return ; <nl> - else <nl> - break ; <nl> - } <nl> } <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | <nl> 
0<ml>RSRepair-A_Closure-31_P_Patch_1435_524.txt<ml>RSRepair-A_Closure-31_P_Patch_1435_524.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_31 / src / com / google / javascript / rhino / Node . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_31 / patches_0qcr / Patch_524 / patched / com / google / javascript / rhino / Node . java 	 2019 - 08 - 12 <nl> } <nl> res = n . checkTreeEqualsImpl ( n2 ) ; <nl> if ( res ! = null ) { <nl> - return res ; <nl> + return null ; <nl> } <nl> } <nl> return res ; <nl> 
0<ml>RSRepair-A_Closure-75_P_Patch_1277_304.txt<ml>RSRepair-A_Closure-75_P_Patch_1277_304.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_75 / src / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_75 / patches_i3i2 / Patch_304 / patched / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 12 <nl> break ; <nl> case Token . STRING : <nl> - return getStringNumberValue ( n . getString ( ) ) ; <nl> + break ; <nl> case Token . ARRAYLIT : <nl> case Token . OBJECTLIT : <nl> 
0<ml>RSRepair-A_Closure-10_P_Patch_27_2.txt<ml>RSRepair-A_Closure-10_P_Patch_27_2.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_10 / src / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_10 / patches_vwhx / Patch_2 / patched / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 12 <nl> return allResultsMatch ( n . getFirstChild ( ) , p ) <nl> & & allResultsMatch ( n . getLastChild ( ) , p ) ; <nl> case Token . HOOK : <nl> - return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) <nl> - & & allResultsMatch ( n . getLastChild ( ) , p ) ; <nl> + int type = n . getType ( ) ; <nl> default : <nl> return p . apply ( n ) ; <nl> } <nl> 
0<ml>RSRepair-A_Closure-112_P_Patch_15_4.txt<ml>RSRepair-A_Closure-112_P_Patch_15_4.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_112 / src / com / google / javascript / jscomp / TypeInference . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_112 / patches_oujc / Patch_4 / patched / com / google / javascript / jscomp / TypeInference . java 	 2019 - 08 - 12 <nl> Iterable < Node > declParams , <nl> Iterable < Node > callParams , <nl> Map < TemplateType , JSType > resolvedTypes ) { <nl> - maybeResolveTemplateTypeFromNodes ( <nl> - declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; <nl> } <nl> private void maybeResolveTemplateTypeFromNodes ( <nl> 
0<ml>RSRepair-A_Lang-13_P_Patch_165_66.txt<ml>RSRepair-A_Lang-13_P_Patch_165_66.txt<ml>mmm  / tmp / RSRepair_Defects4J_Lang_13 / src / main / java / org / apache / commons / lang3 / SerializationUtils . java 	 2019 - 07 - 31 <nl> ppp  / tmp / RSRepair_Defects4J_Lang_13 / patches_c9x2 / Patch_66 / patched / org / apache / commons / lang3 / SerializationUtils . java 	 2019 - 07 - 31 <nl> return readObject ; <nl> } catch ( ClassNotFoundException ex ) { <nl> - throw new SerializationException ( " ClassNotFoundException while reading cloned object data " , ex ) ; <nl> + return object ; <nl> } catch ( IOException ex ) { <nl> throw new SerializationException ( " IOException while reading cloned object data " , ex ) ; <nl> } finally { <nl> 
0<ml>RSRepair-A_Closure-21_P_Patch_1_1.txt<ml>RSRepair-A_Closure-21_P_Patch_1_1.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_21 / patches_voof / Patch_1 / patched / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 12 <nl> return ; <nl> } <nl> if ( n = = parent . getLastChild ( ) ) { <nl> - for ( Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = Token . COMMA ) continue ; <nl> - if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> - else break ; <nl> - } <nl> + int index = - 1 ; <nl> } <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { <nl> 
0<ml>RSRepair-A_Chart-12_P_Patch_95_28.txt<ml>RSRepair-A_Chart-12_P_Patch_95_28.txt<ml>mmm  / tmp / RSRepair_Defects4J_Chart_12 / source / org / jfree / chart / plot / MultiplePiePlot . java 	 2019 - 07 - 30 <nl> ppp  / tmp / RSRepair_Defects4J_Chart_12 / patches_4a74 / Patch_28 / patched / org / jfree / chart / plot / MultiplePiePlot . java 	 2019 - 07 - 30 <nl> new Font ( " SansSerif " , Font . BOLD , 12 ) ) ; <nl> seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; <nl> this . pieChart . setTitle ( seriesTitle ) ; <nl> - this . aggregatedItemsKey = " Other " ; <nl> + if ( dataset ! = null ) { <nl> + dataset . addChangeListener ( this ) ; <nl> + } <nl> + this . aggregatedItemsKey = " Other " ; <nl> this . aggregatedItemsPaint = Color . lightGray ; <nl> this . sectionPaints = new HashMap ( ) ; <nl> } <nl> 
0<ml>RSRepair-A_Closure-129_P_Patch_3_2.txt<ml>RSRepair-A_Closure-129_P_Patch_3_2.txt<ml>mmm  / tmp / RSRepair_Defects4J_Closure_129 / src / com / google / javascript / rhino / Node . java 	 2019 - 08 - 12 <nl> ppp  / tmp / RSRepair_Defects4J_Closure_129 / patches_kk16 / Patch_2 / patched / com / google / javascript / rhino / Node . java 	 2019 - 08 - 12 <nl> } <nl> } else if ( type = = Token . CALL ) { <nl> if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { <nl> - return false ; <nl> } <nl> } <nl> 
0<ml>AVATAR_Math-82_P_Patch_600_284.txt<ml>AVATAR_Math-82_P_Patch_600_284.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> double minValue = 0 ; <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> - if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> + if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { <nl> minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> 
0<ml>AVATAR_Chart-26_P_Patch_4159_891.txt<ml>AVATAR_Chart-26_P_Patch_4159_891.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> / / if the plot area is too small , just return . . . <nl> boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; <nl> boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; <nl> - if ( b1 | | b2 ) { <nl> + if ( this . rangeGridlinesVisible | | b2 ) { <nl> return ; <nl> } <nl> 
0<ml>AVATAR_Lang-63_P_Patch_22_1.txt<ml>AVATAR_Lang-63_P_Patch_22_1.txt<ml>mmm a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> int endValue = end . get ( field ) ; <nl> int startValue = start . get ( field ) ; <nl> if ( endValue < startValue ) { <nl> - int newdiff = startValue - endValue ; <nl> + int newdiff = endValue - endValue ; <nl> end . add ( field , newdiff ) ; <nl> return newdiff ; <nl> } else { <nl> 
0<ml>AVATAR_Closure-126_P_Patch_4_3.txt<ml>AVATAR_Closure-126_P_Patch_4_3.txt<ml>mmm a / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> ppp b / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> * / <nl> if ( NodeUtil . hasFinally ( n ) ) { <nl> Node finallyBlock = n . getLastChild ( ) ; <nl> - tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> + tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; <nl> } <nl> } <nl> 
0<ml>AVATAR_Closure-45_P_Patch_281_95.txt<ml>AVATAR_Closure-45_P_Patch_281_95.txt<ml>mmm a / src / com / google / javascript / jscomp / RemoveUnusedVars . java <nl> ppp b / src / com / google / javascript / jscomp / RemoveUnusedVars . java <nl> for ( Assign assign : assignsByVar . get ( var ) ) { <nl> if ( assign . isPropertyAssign ) { <nl> hasPropertyAssign = true ; <nl> - } else if ( ! NodeUtil . isLiteralValue ( <nl> - assign . assignNode . getLastChild ( ) , true ) ) { <nl> - assignedToUnknownValue = true ; <nl> - } <nl> + } else assignedToUnknownValue = true ; <nl> } <nl> if ( assignedToUnknownValue & & hasPropertyAssign ) { <nl> 
1<ml>AVATAR_Chart-19_C_Patch_164_98.txt<ml>AVATAR_Chart-19_C_Patch_164_98.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> * @ since 1 . 0 . 3 <nl> * / <nl> public int getDomainAxisIndex ( CategoryAxis axis ) { <nl> - return this . domainAxes . indexOf ( axis ) ; <nl> + if ( axis = = null ) { <nl> + throw new IllegalArgumentException ( " Null ' axis ' argument . " ) ; <nl> + } <nl> + return this . domainAxes . indexOf ( axis ) ; <nl> } <nl> / * * <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> * @ since 1 . 0 . 7 <nl> * / <nl> public int getRangeAxisIndex ( ValueAxis axis ) { <nl> - int result = this . rangeAxes . indexOf ( axis ) ; <nl> + if ( axis = = null ) { <nl> + throw new IllegalArgumentException ( " Null ' axis ' argument . " ) ; <nl> + } <nl> + int result = this . rangeAxes . indexOf ( axis ) ; <nl> if ( result < 0 ) { / / try the parent plot <nl> Plot parent = getParent ( ) ; <nl> if ( parent instanceof CategoryPlot ) { <nl> 
0<ml>AVATAR_Math-50_P_Patch_8_7.txt<ml>AVATAR_Math-50_P_Patch_8_7.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> break ; <nl> 
0<ml>AVATAR_Chart-13_P_Patch_9_7.txt<ml>AVATAR_Chart-13_P_Patch_9_7.txt<ml>mmm a / source / org / jfree / data / Range . java <nl> ppp b / source / org / jfree / data / Range . java <nl> * / <nl> public Range ( double lower , double upper ) { <nl> if ( lower > upper ) { <nl> - String msg = " Range ( double , double ) : require lower ( " + lower <nl> - + " ) < = upper ( " + upper + " ) . " ; <nl> - throw new IllegalArgumentException ( msg ) ; <nl> + <nl> } <nl> this . lower = lower ; <nl> this . upper = upper ; <nl> 
0<ml>AVATAR_Lang-39_P_Patch_525_180.txt<ml>AVATAR_Lang-39_P_Patch_525_180.txt<ml>mmm a / src / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / java / org / apache / commons / lang3 / StringUtils . java <nl> / / count the replacement text elements that are larger than their corresponding text being replaced <nl> for ( int i = 0 ; i < searchList . length ; i + + ) { <nl> - int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> + int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> if ( greater > 0 ) { <nl> increase + = 3 * greater ; / / assume 3 matches <nl> } <nl> 
0<ml>AVATAR_Lang-58_P_Patch_999_513.txt<ml>AVATAR_Lang-58_P_Patch_999_513.txt<ml>mmm a / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> case ' L ' : <nl> if ( dec = = null <nl> & & exp = = null <nl> - & & isDigits ( numeric . substring ( 1 ) ) <nl> & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> 
0<ml>AVATAR_Math-81_P_Patch_108_32.txt<ml>AVATAR_Math-81_P_Patch_108_32.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> double s = 0 . 25 * dMin ; <nl> / / compute contribution to norm squared from i > nn - 2 . <nl> - final int np = nn - 2 * pingPong ; <nl> + final int np = nn - 2 * start ; <nl> double b1 = work [ np - 2 ] ; <nl> double b2 = work [ np - 6 ] ; <nl> final double gam = dN2 ; <nl> 
0<ml>AVATAR_Lang-20_P_Patch_455_139.txt<ml>AVATAR_Lang-20_P_Patch_455_139.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; <nl> + StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; <nl> + StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> 
1<ml>AVATAR_Lang-6_C_Patch_1150_355.txt<ml>AVATAR_Lang-6_C_Patch_1150_355.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java <nl> / / / / contract with translators is that they have to understand codepoints <nl> / / / / and they just took care of a surrogate pair <nl> for ( int pt = 0 ; pt < consumed ; pt + + ) { <nl> - pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; <nl> + pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; <nl> } <nl> } <nl> } <nl> 
1<ml>AVATAR_Math-4_C_Patch_221_71.txt<ml>AVATAR_Math-4_C_Patch_221_71.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java <nl> Vector3D v1D = line . intersection ( subLine . line ) ; <nl> / / check location of point with respect to first sub - line <nl> - Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; <nl> + if ( v1D = = null ) { <nl> + return null ; <nl> + } <nl> + Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; <nl> / / check location of point with respect to second sub - line <nl> Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ; <nl> mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java <nl> Vector2D v2D = line1 . intersection ( line2 ) ; <nl> / / check location of point with respect to first sub - line <nl> - Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; <nl> + if ( v2D = = null ) { <nl> + return null ; <nl> + } <nl> + Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; <nl> / / check location of point with respect to second sub - line <nl> Location loc2 = subLine . getRemainingRegion ( ) . checkPoint ( line2 . toSubSpace ( v2D ) ) ; <nl> 
0<ml>AVATAR_Math-57_P_Patch_447_97.txt<ml>AVATAR_Math-57_P_Patch_447_97.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java <nl> assignPointsToClusters ( clusters , points ) ; <nl> / / iterate through updating the centers until we ' re done <nl> - final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; <nl> + final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; <nl> for ( int count = 0 ; count < max ; count + + ) { <nl> boolean clusteringChanged = false ; <nl> List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ; <nl> 
1<ml>AVATAR_Math-59_C_Patch_38_34.txt<ml>AVATAR_Math-59_C_Patch_38_34.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math / util / FastMath . java <nl> * For x between 0 and 1 , returns exp ( x ) , uses extended precision <nl> * @ param x argument of exponential <nl> * @ param result placeholder where to place exp ( x ) split in two terms <nl> - * for extra precision ( i . e . exp ( x ) = result [ 0 ] ? ? result [ 1 ] <nl> + * for extra precision ( i . e . exp ( x ) = result [ 0 ] ? ? result [ 1 ] <nl> * @ return exp ( x ) <nl> * / <nl> private static double slowexp ( final double x , final double result [ ] ) { <nl> * @ return b if a is lesser or equal to b , a otherwise <nl> * / <nl> public static float max ( final float a , final float b ) { <nl> - return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; <nl> + return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; <nl> } <nl> / * * Compute the maximum of two values <nl> 
0<ml>AVATAR_Chart-14_P_Patch_560_34.txt<ml>AVATAR_Chart-14_P_Patch_560_34.txt<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + boolean removed = this . annotations . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> boolean notify ) { <nl> ArrayList markers ; <nl> if ( layer = = Layer . FOREGROUND ) { <nl> - markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( <nl> + markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> else { <nl> mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + boolean removed = this . annotations . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> } <nl> - boolean removed = markers . remove ( marker ) ; <nl> + boolean removed = this . annotations . remove ( marker ) ; <nl> if ( removed & & notify ) { <nl> fireChangeEvent ( ) ; <nl> } <nl> 
1<ml>AVATAR_Closure-2_C_Patch_60_13.txt<ml>AVATAR_Closure-2_C_Patch_60_13.txt<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> Set < String > currentPropertyNames ; <nl> / / This can be the case if interfaceType is proxy to a non - existent <nl> / / object ( which is a bad type annotation , but shouldn ' t crash ) . <nl> - currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; <nl> + if ( implicitProto ! = null ) { <nl> + currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; <nl> for ( String name : currentPropertyNames ) { <nl> ObjectType oType = properties . get ( name ) ; <nl> if ( oType ! = null ) { <nl> } <nl> currentProperties . put ( name , interfaceType ) ; <nl> } <nl> + } <nl> + <nl> for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { <nl> checkInterfaceConflictProperties ( t , n , functionName , properties , <nl> currentProperties , iType ) ; <nl> 
0<ml>AVATAR_Math-78_P_Patch_525_329.txt<ml>AVATAR_Math-78_P_Patch_525_329.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> / / Inverse quadratic interpolation . <nl> double r1 = y0 / y2 ; <nl> double r2 = y1 / y2 ; <nl> - p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; <nl> + p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; <nl> p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; <nl> } <nl> if ( p > 0 . 0 ) { <nl> 
0<ml>AVATAR_Math-95_P_Patch_53_25.txt<ml>AVATAR_Math-95_P_Patch_53_25.txt<ml>mmm a / src / java / org / apache / commons / math / distribution / FDistributionImpl . java <nl> ppp b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> - return ret ; <nl> + return d ; <nl> } <nl> / * * <nl> 
0<ml>AVATAR_Lang-51_P_Patch_120_90.txt<ml>AVATAR_Lang-51_P_Patch_120_90.txt<ml>mmm a / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ppp b / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & <nl> ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <nl> } <nl> - if ( ch = = ' Y ' ) { <nl> - return <nl> + return <nl> ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & <nl> ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; <nl> - } <nl> } <nl> case 4 : { <nl> char ch = str . charAt ( 0 ) ; <nl> 
0<ml>AVATAR_Chart-5_P_Patch_1_1.txt<ml>AVATAR_Chart-5_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / data / xy / XYSeries . java <nl> ppp b / source / org / jfree / data / xy / XYSeries . java <nl> * @ since 1 . 0 . 10 <nl> * / <nl> public XYDataItem addOrUpdate ( double x , double y ) { <nl> - return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; <nl> + return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; <nl> } <nl> / * * <nl> 
1<ml>AVATAR_Closure-63_C_Patch_52_19.txt<ml>AVATAR_Closure-63_C_Patch_52_19.txt<ml>Binary files a / build / lib / rhino1_7R3pre / js . jar and b / build / lib / rhino1_7R3pre / js . jar differ <nl> mmm a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> ppp b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> / / charno = = sourceExpert . length ( ) means something is missing <nl> / / at the end of the line <nl> if ( excerpt . equals ( LINE ) <nl> - & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { <nl> + & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( Character . isWhitespace ( c ) ) { <nl> 
0<ml>AVATAR_Closure-48_P_Patch_739_289.txt<ml>AVATAR_Closure-48_P_Patch_739_289.txt<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; <nl> if ( valueType = = null & & rhsValue ! = null ) { <nl> / / Determining type for # 5 <nl> - valueType = rhsValue . getJSType ( ) ; <nl> + valueType = ownerNode . getJSType ( ) ; <nl> } <nl> / / Function prototypes are special . <nl> / / It ' s a common JS idiom to do : <nl> 
1<ml>AVATAR_Closure-46_C_Patch_11_4.txt<ml>AVATAR_Closure-46_C_Patch_11_4.txt<ml>old mode 100755 <nl> new mode 100644 <nl> mmm a / src / com / google / javascript / rhino / jstype / RecordType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / RecordType . java <nl> propertyNode ) ; <nl> } <nl> - @ Override <nl> - public JSType getLeastSupertype ( JSType that ) { <nl> - if ( ! that . isRecordType ( ) ) { <nl> - return super . getLeastSupertype ( that ) ; <nl> - } <nl> - RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; <nl> - for ( String property : properties . keySet ( ) ) { <nl> - if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & <nl> - that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( <nl> - getPropertyType ( property ) ) ) { <nl> - builder . addProperty ( property , getPropertyType ( property ) , <nl> - getPropertyNode ( property ) ) ; <nl> - } <nl> - } <nl> - return builder . build ( ) ; <nl> - } <nl> + <nl> JSType getGreatestSubtypeHelper ( JSType that ) { <nl> if ( that . isRecordType ( ) ) { <nl> RecordType thatRecord = that . toMaybeRecordType ( ) ; <nl> 
1<ml>AVATAR_Lang-7_C_Patch_1065_498.txt<ml>AVATAR_Lang-7_C_Patch_1065_498.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> if ( StringUtils . isBlank ( str ) ) { <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> - if ( str . startsWith ( " - - " ) ) { <nl> - return null ; <nl> - } <nl> + <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> int hexDigits = str . length ( ) - 2 ; / / drop 0x <nl> if ( str . startsWith ( " - " ) ) { / / drop - <nl> 
1<ml>AVATAR_Closure-38_C_Patch_1174_242.txt<ml>AVATAR_Closure-38_C_Patch_1174_242.txt<ml>mmm a / src / com / google / javascript / jscomp / CodeConsumer . java <nl> ppp b / src / com / google / javascript / jscomp / CodeConsumer . java <nl> / / x - - 4 ( which is a syntax error ) . <nl> char prev = getLastChar ( ) ; <nl> boolean negativeZero = isNegativeZero ( x ) ; <nl> - if ( x < 0 & & prev = = ' - ' ) { <nl> + if ( x < = 0 & & prev = = ' - ' ) { <nl> add ( " " ) ; <nl> } <nl> 
1<ml>AVATAR_Closure-115_C_Patch_214_66.txt<ml>AVATAR_Closure-115_C_Patch_214_66.txt<ml>mmm a / src / com / google / javascript / jscomp / FunctionInjector . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionInjector . java <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> - if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> - return CanInlineResult . NO ; <nl> - } <nl> + <nl> / / Check for arguments that are evaluated more than once . <nl> / / Note : Unlike block inlining , there it is not possible that a <nl> / / parameter reference will be in a loop . <nl> 
0<ml>AVATAR_Closure-22_P_Patch_77_31.txt<ml>AVATAR_Closure-22_P_Patch_77_31.txt<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> / / This no - op statement was there so that JSDoc information could <nl> / / be attached to the name . This check should not complain about it . <nl> - if ( n = = parent . getLastChild ( ) ) { <nl> + if ( gramps = = parent . getLastChild ( ) ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) <nl> 
0<ml>AVATAR_Lang-22_P_Patch_694_214.txt<ml>AVATAR_Lang-22_P_Patch_694_214.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / Fraction . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / Fraction . java <nl> private static int greatestCommonDivisor ( int u , int v ) { <nl> / / From Commons Math : <nl> / / if either operand is abs 1 , return 1 : <nl> - if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { <nl> + if ( Math . abs ( v ) < = 1 ) { <nl> return 1 ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> 
0<ml>AVATAR_Math-2_P_Patch_367_117.txt<ml>AVATAR_Math-2_P_Patch_367_117.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java <nl> final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | <nl> Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; <nl> if ( chebyshevApplies ) { <nl> - double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; <nl> + double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; <nl> double tmp = mu - k * sigma ; <nl> if ( tmp > lower ) { <nl> lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> 
0<ml>AVATAR_Closure-108_P_Patch_408_102.txt<ml>AVATAR_Closure-108_P_Patch_408_102.txt<ml>mmm a / src / com / google / javascript / jscomp / ScopedAliases . java <nl> ppp b / src / com / google / javascript / jscomp / ScopedAliases . java <nl> compiler . getCodingConvention ( ) , <nl> globalName , <nl> value , <nl> - v . getJSDocInfo ( ) ) <nl> + grandparent . getJSDocInfo ( ) ) <nl> . useSourceInfoIfMissingFromForTree ( n ) ; <nl> NodeUtil . setDebugInformation ( <nl> newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; <nl> 
0<ml>AVATAR_Closure-21_P_Patch_15_4.txt<ml>AVATAR_Closure-21_P_Patch_15_4.txt<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> } <nl> if ( n = = parent . getLastChild ( ) ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> + int ancestorType = parent . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) continue ; <nl> if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> else break ; <nl> 
0<ml>AVATAR_Lang-59_P_Patch_714_324.txt<ml>AVATAR_Lang-59_P_Patch_714_324.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> * / <nl> public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { <nl> if ( width > 0 ) { <nl> - ensureCapacity ( size + width ) ; <nl> + ensureCapacity ( padChar + width ) ; <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> 
1<ml>AVATAR_Lang-57_C_Patch_38_2.txt<ml>AVATAR_Lang-57_C_Patch_38_2.txt<ml>mmm a / src / java / org / apache / commons / lang / LocaleUtils . java <nl> ppp b / src / java / org / apache / commons / lang / LocaleUtils . java <nl> * @ return true if the locale is a known locale <nl> * / <nl> public static boolean isAvailableLocale ( Locale locale ) { <nl> - return cAvailableLocaleSet . contains ( locale ) ; <nl> + return cAvailableLocaleList . contains ( locale ) ; <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
0<ml>AVATAR_Chart-7_P_Patch_6_2.txt<ml>AVATAR_Chart-7_P_Patch_6_2.txt<ml>mmm a / source / org / jfree / data / time / TimePeriodValues . java <nl> ppp b / source / org / jfree / data / time / TimePeriodValues . java <nl> * @ return The index . <nl> * / <nl> public int getMaxMiddleIndex ( ) { <nl> - return this . maxMiddleIndex ; <nl> + return this . maxStartIndex ; <nl> } <nl> / * * <nl> 
0<ml>ARJA_Math-40_P_Patch_195_167.txt<ml>ARJA_Math-40_P_Patch_195_167.txt<ml>mmm  / tmp / Arja_Defects4J_Math_40 / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2019 - 07 - 29 <nl> ppp  / tmp / Arja_Defects4J_Math_40 / patches_nvej / Patch_167 / patched / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2019 - 07 - 29 <nl> / / we have more points before the sign change , drop the lowest point <nl> + + start ; <nl> } else { <nl> - / / we have more points after sign change , drop the highest point <nl> + + + start ; <nl> + / / we have more points after sign change , drop the highest point <nl> - - end ; <nl> } <nl> 
0<ml>ARJA_Math-82_P_Patch_83_49.txt<ml>ARJA_Math-82_P_Patch_83_49.txt<ml>mmm  / tmp / Arja_Defects4J_Math_82 / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_82 / patches_im6f / Patch_49 / patched / org / apache / commons / math / optimization / linear / SimplexTableau . java 	 2019 - 07 - 31 <nl> coefficients [ i ] = 0 ; <nl> } else { <nl> basicRows . add ( basicRow ) ; <nl> - coefficients [ i ] = <nl> + for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { <nl> + int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; <nl> + subtractRow ( 0 , row , 1 . 0 ) ; <nl> + } <nl> + coefficients [ i ] = <nl> ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - <nl> ( restrictToNonNegative ? 0 : mostNegative ) ; <nl> } <nl> mmm  / tmp / Arja_Defects4J_Math_82 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_82 / patches_im6f / Patch_49 / patched / org / apache / commons / math / optimization / linear / SimplexSolver . java 	 2019 - 07 - 31 <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> - minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> } <nl> 
0<ml>ARJA_Closure-117_P_Patch_5_5.txt<ml>ARJA_Closure-117_P_Patch_5_5.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_117 / src / com / google / javascript / jscomp / TypeValidator . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_117 / patches_rztv / Patch_5 / patched / com / google / javascript / jscomp / TypeValidator . java 	 2019 - 08 - 12 <nl> if ( objectType ! = null & & <nl> ( objectType . getConstructor ( ) ! = null | | <nl> objectType . isFunctionPrototypeType ( ) ) ) { <nl> - return objectType . toString ( ) + " . " + propName ; <nl> } <nl> } <nl> } <nl> 
0<ml>ARJA_Closure-119_P_Patch_30_26.txt<ml>ARJA_Closure-119_P_Patch_30_26.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_119 / src / com / google / javascript / jscomp / SyntacticScopeCreator . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_119 / patches_557l / Patch_26 / patched / com / google / javascript / jscomp / SyntacticScopeCreator . java 	 2019 - 08 - 12 <nl> final Node var = n . getFirstChild ( ) ; <nl> final Node block = var . getNext ( ) ; <nl> - declareVar ( var ) ; <nl> + ; <nl> scanVars ( block ) ; <nl> return ; / / only one child to scan <nl> mmm  / tmp / Arja_Defects4J_Closure_119 / src / com / google / javascript / jscomp / AstValidator . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_119 / patches_557l / Patch_26 / patched / com / google / javascript / jscomp / AstValidator . java 	 2019 - 08 - 12 <nl> private void validateThrow ( Node n ) { <nl> validateNodeType ( Token . THROW , n ) ; <nl> - validateChildCount ( n , 1 ) ; <nl> validateExpression ( n . getFirstChild ( ) ) ; <nl> } <nl> 
0<ml>ARJA_Closure-55_P_Patch_18_8.txt<ml>ARJA_Closure-55_P_Patch_18_8.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_55 / src / com / google / javascript / jscomp / FunctionRewriter . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_55 / patches_e0jo / Patch_8 / patched / com / google / javascript / jscomp / FunctionRewriter . java 	 2019 - 08 - 11 <nl> / / Estimate savings <nl> int savings = 0 ; <nl> for ( Reduction reduction : reductions ) { <nl> - savings + = reduction . estimateSavings ( ) ; <nl> } <nl> / / Compare estimated savings against the helper cost . Apply <nl> } <nl> private static boolean isReduceableFunctionExpression ( Node n ) { <nl> - return NodeUtil . isFunctionExpression ( n ) ; <nl> + return false ; <nl> } <nl> / * * <nl> 
1<ml>ARJA_Math-98_C_Patch_686_649.txt<ml>ARJA_Math-98_C_Patch_686_649.txt<ml>mmm  / tmp / Arja_Defects4J_Math_98 / src / java / org / apache / commons / math / linear / BigMatrixImpl . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_98 / patches_rdo0 / Patch_649 / patched / org / apache / commons / math / linear / BigMatrixImpl . java 	 2019 - 07 - 31 <nl> } <nl> final int nRows = this . getRowDimension ( ) ; <nl> final int nCols = this . getColumnDimension ( ) ; <nl> - final BigDecimal [ ] out = new BigDecimal [ v . length ] ; <nl> + final BigDecimal [ ] out = new BigDecimal [ nRows ] ; <nl> for ( int row = 0 ; row < nRows ; row + + ) { <nl> BigDecimal sum = ZERO ; <nl> for ( int i = 0 ; i < nCols ; i + + ) { <nl> mmm  / tmp / Arja_Defects4J_Math_98 / src / java / org / apache / commons / math / linear / RealMatrixImpl . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_98 / patches_rdo0 / Patch_649 / patched / org / apache / commons / math / linear / RealMatrixImpl . java 	 2019 - 07 - 31 <nl> if ( v . length ! = nCols ) { <nl> throw new IllegalArgumentException ( " vector has wrong length " ) ; <nl> } <nl> - final double [ ] out = new double [ v . length ] ; <nl> + final double [ ] out = new double [ nRows ] ; <nl> for ( int row = 0 ; row < nRows ; row + + ) { <nl> final double [ ] dataRow = data [ row ] ; <nl> double sum = 0 ; <nl> 
1<ml>ARJA_Math-50_C_Patch_7_6.txt<ml>ARJA_Math-50_C_Patch_7_6.txt<ml>mmm  / tmp / Arja_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2019 - 07 - 29 <nl> ppp  / tmp / Arja_Defects4J_Math_50 / patches_jy1t / Patch_6 / patched / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java 	 2019 - 07 - 29 <nl> f0 * = f1 / ( f1 + fx ) ; <nl> break ; <nl> case REGULA_FALSI : <nl> - / / Nothing . <nl> - if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> - f0 = computeObjectiveValue ( x0 ) ; <nl> - } <nl> + ; <nl> break ; <nl> default : <nl> / / Should never happen . <nl> mmm  / tmp / Arja_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 07 - 29 <nl> ppp  / tmp / Arja_Defects4J_Math_50 / patches_jy1t / Patch_6 / patched / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 07 - 29 <nl> public static void verifyBracketing ( UnivariateRealFunction function , <nl> final double lower , <nl> final double upper ) { <nl> - if ( function = = null ) { <nl> - throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; <nl> - } <nl> verifyInterval ( lower , upper ) ; <nl> if ( ! isBracketing ( function , lower , upper ) ) { <nl> throw new NoBracketingException ( lower , upper , <nl> 
1<ml>ARJA_Math-35_C_Patch_303_303.txt<ml>ARJA_Math-35_C_Patch_303_303.txt<ml>mmm  / tmp / Arja_Defects4J_Math_35 / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java 	 2019 - 07 - 28 <nl> ppp  / tmp / Arja_Defects4J_Math_35 / patches_rvo9 / Patch_303 / patched / org / apache / commons / math3 / genetics / ElitisticListPopulation . java 	 2019 - 07 - 28 <nl> final int populationLimit , <nl> final double elitismRate ) { <nl> super ( chromosomes , populationLimit ) ; <nl> - this . elitismRate = elitismRate ; <nl> + if ( elitismRate < 0 | | elitismRate > 1 ) { <nl> + throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; <nl> + } <nl> } <nl> / * * <nl> * / <nl> public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { <nl> super ( populationLimit ) ; <nl> - this . elitismRate = elitismRate ; <nl> + if ( elitismRate < 0 | | elitismRate > 1 ) { <nl> + throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; <nl> + } <nl> + this . elitismRate = elitismRate ; <nl> } <nl> / * * <nl> 
0<ml>ARJA_Chart-13_P_Patch_4_4.txt<ml>ARJA_Chart-13_P_Patch_4_4.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangement . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_13 / patches_et25 / Patch_4 / patched / org / jfree / chart / block / BorderArrangement . java 	 2019 - 07 - 19 <nl> w [ 4 ] = size . width ; <nl> h [ 4 ] = size . height ; <nl> } <nl> - double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; <nl> + this . rightBlock = null ; <nl> + double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; <nl> return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; <nl> } <nl> 
0<ml>ARJA_Chart-19_P_Patch_169_155.txt<ml>ARJA_Chart-19_P_Patch_169_155.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_19 / source / org / jfree / chart / util / AbstractObjectList . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_19 / patches_mg6q / Patch_155 / patched / org / jfree / chart / util / AbstractObjectList . java 	 2019 - 07 - 19 <nl> return ( index ) ; <nl> } <nl> } <nl> - return - 1 ; <nl> + if ( object = = null ) { <nl> + throw new IllegalArgumentException ( " Null ' object ' argument . " ) ; <nl> + } <nl> + return - 1 ; <nl> } <nl> / * * <nl> mmm  / tmp / Arja_Defects4J_Chart_19 / source / org / jfree / chart / plot / CategoryPlot . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_19 / patches_mg6q / Patch_155 / patched / org / jfree / chart / plot / CategoryPlot . java 	 2019 - 07 - 19 <nl> axis . setPlot ( this ) ; <nl> } <nl> this . domainAxes . set ( index , axis ) ; <nl> - if ( axis ! = null ) { <nl> + this . weight = weight ; <nl> + if ( axis ! = null ) { <nl> axis . configure ( ) ; <nl> - axis . addChangeListener ( this ) ; <nl> } <nl> if ( notify ) { <nl> notifyListeners ( new PlotChangeEvent ( this ) ) ; <nl> * / <nl> public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { <nl> ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; <nl> - if ( existing ! = null ) { <nl> + this . orientation = PlotOrientation . VERTICAL ; <nl> + if ( existing ! = null ) { <nl> existing . removeChangeListener ( this ) ; <nl> } <nl> if ( axis ! = null ) { <nl> - axis . setPlot ( this ) ; <nl> + if ( axis ! = null ) { <nl> + axis . setPlot ( this ) ; <nl> + axis . addChangeListener ( this ) ; <nl> + } <nl> + axis . setPlot ( this ) ; <nl> } <nl> this . rangeAxes . set ( index , axis ) ; <nl> if ( axis ! = null ) { <nl> * @ since 1 . 0 . 7 <nl> * / <nl> public int getRangeAxisIndex ( ValueAxis axis ) { <nl> - int result = this . rangeAxes . indexOf ( axis ) ; <nl> + this . rangeGridlinesVisible = true ; <nl> + int result = this . rangeAxes . indexOf ( axis ) ; <nl> if ( result < 0 ) { / / try the parent plot <nl> Plot parent = getParent ( ) ; <nl> if ( parent instanceof CategoryPlot ) { <nl> 
0<ml>ARJA_Closure-1_P_Patch_94_51.txt<ml>ARJA_Closure-1_P_Patch_94_51.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_1 / src / com / google / javascript / rhino / Node . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_1 / patches_a0it / Patch_51 / patched / com / google / javascript / rhino / Node . java 	 2019 - 08 - 11 <nl> public String checkTreeEquals ( Node node2 ) { <nl> NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; <nl> if ( diff ! = null ) { <nl> - return " Node tree inequality : " + <nl> - " \ nTree1 : \ n " + toStringTree ( ) + <nl> - " \ n \ nTree2 : \ n " + node2 . toStringTree ( ) + <nl> - " \ n \ nSubtree1 : " + diff . nodeA . toStringTree ( ) + <nl> - " \ n \ nSubtree2 : " + diff . nodeB . toStringTree ( ) ; <nl> + return toString ( true , true , true ) ; <nl> } <nl> return null ; <nl> } <nl> mmm  / tmp / Arja_Defects4J_Closure_1 / src / com / google / javascript / jscomp / RemoveUnusedVars . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_1 / patches_a0it / Patch_51 / patched / com / google / javascript / jscomp / RemoveUnusedVars . java 	 2019 - 08 - 11 <nl> Node lastArg ; <nl> while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { <nl> Var var = fnScope . getVar ( lastArg . getString ( ) ) ; <nl> - if ( ! referenced . contains ( var ) ) { <nl> - argList . removeChild ( lastArg ) ; <nl> - compiler . reportCodeChange ( ) ; <nl> - } else { <nl> - break ; <nl> - } <nl> + break ; <nl> } <nl> } else { <nl> callSiteOptimizer . optimize ( fnScope , referenced ) ; <nl> 
0<ml>ARJA_Chart-25_P_Patch_4_3.txt<ml>ARJA_Chart-25_P_Patch_4_3.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_25 / patches_bz2o / Patch_3 / patched / org / jfree / chart / renderer / category / StatisticalBarRenderer . java 	 2019 - 07 - 19 <nl> int row , <nl> int column ) { <nl> - RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; <nl> + if ( this . errorIndicatorPaint ! = null ) { <nl> + g2 . setPaint ( this . errorIndicatorPaint ) ; <nl> + } else { <nl> + g2 . setPaint ( getItemPaint ( row , column ) ) ; <nl> + } <nl> + RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; <nl> / / BAR Y <nl> double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , <nl> if ( value < = lclip ) { <nl> value = lclip ; <nl> } <nl> - } <nl> - else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 <nl> - if ( value > = uclip ) { <nl> - value = uclip ; <nl> - } <nl> - else { <nl> - if ( value < = lclip ) { <nl> - value = lclip ; <nl> - } <nl> - } <nl> - } <nl> - else { / / cases 9 , 10 , 11 and 12 <nl> - if ( value < = lclip ) { <nl> - return ; / / bar is not visible <nl> - } <nl> - base = getLowerClip ( ) ; <nl> - if ( value > = uclip ) { <nl> - value = uclip ; <nl> - } <nl> - } <nl> + } else { <nl> + rectY = rectY + row * state . getBarWidth ( ) ; <nl> + if ( lclip < = 0 . 0 ) { <nl> + if ( value > = uclip ) { <nl> + value = uclip ; <nl> + } else { <nl> + if ( value < = lclip ) { <nl> + value = lclip ; <nl> + } <nl> + } <nl> + } else { <nl> + if ( value < = lclip ) { <nl> + return ; <nl> + } <nl> + base = getLowerClip ( ) ; <nl> + if ( value > = uclip ) { <nl> + value = uclip ; <nl> + } <nl> + } <nl> + } <nl> RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; <nl> double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; <nl> mmm  / tmp / Arja_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_25 / patches_bz2o / Patch_3 / patched / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2019 - 07 - 19 <nl> MeanAndStandardDeviation masd <nl> = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; <nl> if ( masd ! = null ) { <nl> - result = masd . getMean ( ) ; <nl> } <nl> return result ; <nl> } <nl> Number result = null ; <nl> MeanAndStandardDeviation masd <nl> = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; <nl> - if ( masd ! = null ) { <nl> - result = masd . getStandardDeviation ( ) ; <nl> - } <nl> + result = masd . getStandardDeviation ( ) ; <nl> return result ; <nl> } <nl> 
0<ml>ARJA_Math-81_P_Patch_6_5.txt<ml>ARJA_Math-81_P_Patch_6_5.txt<ml>mmm  / tmp / Arja_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_81 / patches_tja6 / Patch_5 / patched / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 07 - 31 <nl> } <nl> } else if ( dMin = = dN2 ) { <nl> - / / case 5 . <nl> - tType = - 5 ; <nl> double s = 0 . 25 * dMin ; <nl> / / compute contribution to norm squared from i > nn - 2 . <nl> / / approximate contribution to norm squared from i < nn - 2 . <nl> if ( end - start > 2 ) { <nl> - b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> a2 = a2 + b2 ; <nl> for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <nl> if ( b2 = = 0 . 0 ) { <nl> 
0<ml>ARJA_Lang-20_P_Patch_288_287.txt<ml>ARJA_Lang-20_P_Patch_288_287.txt<ml>mmm  / tmp / Arja_Defects4J_Lang_20 / src / main / java / org / apache / commons / lang3 / StringUtils . java 	 2019 - 07 - 22 <nl> ppp  / tmp / Arja_Defects4J_Lang_20 / patches_bjrb / Patch_287 / patched / org / apache / commons / lang3 / StringUtils . java 	 2019 - 07 - 22 <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; <nl> + StringBuilder buf = new StringBuilder ( 256 ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; <nl> + StringBuilder buf = new StringBuilder ( 256 ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> 
0<ml>ARJA_Closure-114_P_Patch_20_20.txt<ml>ARJA_Closure-114_P_Patch_20_20.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_114 / src / com / google / javascript / jscomp / NameAnalyzer . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_114 / patches_z1u6 / Patch_20 / patched / com / google / javascript / jscomp / NameAnalyzer . java 	 2019 - 08 - 11 <nl> / / Function expression . try to get a name from the parent var <nl> / / declaration or assignment . <nl> Node parent = function . getParent ( ) ; <nl> - if ( parent ! = null ) { <nl> - / / Account for functions defined in the form : <nl> - / / var a = cond ? function a ( ) { } : function b ( ) { } ; <nl> - while ( parent . isHook ( ) ) { <nl> - parent = parent . getParent ( ) ; <nl> - } <nl> - <nl> - if ( parent . isName ( ) ) { <nl> - return scopes . get ( parent ) ; <nl> - } <nl> - <nl> - if ( parent . isAssign ( ) ) { <nl> - return scopes . get ( parent ) ; <nl> - } <nl> - } <nl> - <nl> return Collections . emptyList ( ) ; <nl> } <nl> 
0<ml>ARJA_Math-28_P_Patch_6_6.txt<ml>ARJA_Math-28_P_Patch_6_6.txt<ml>mmm  / tmp / Arja_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2019 - 07 - 27 <nl> ppp  / tmp / Arja_Defects4J_Math_28 / patches_blu4 / Patch_6 / patched / org / apache / commons / math3 / optimization / linear / SimplexSolver . java 	 2019 - 07 - 27 <nl> for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { <nl> if ( row = = tableau . getBasicRow ( i ) ) { <nl> if ( i < minIndex ) { <nl> - minIndex = i ; <nl> minRow = row ; <nl> } <nl> } <nl> 
0<ml>ARJA_Closure-33_P_Patch_1_1.txt<ml>ARJA_Closure-33_P_Patch_1_1.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_33 / src / com / google / javascript / rhino / jstype / RecordType . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_33 / patches_kduf / Patch_1 / patched / com / google / javascript / rhino / jstype / RecordType . java 	 2019 - 08 - 11 <nl> } <nl> } else { <nl> if ( ! propA . isSubtype ( propB ) ) { <nl> - return false ; <nl> } <nl> } <nl> } <nl> 
0<ml>ARJA_Math-85_P_Patch_22_11.txt<ml>ARJA_Math-85_P_Patch_22_11.txt<ml>mmm  / tmp / Arja_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_85 / patches_bgjg / Patch_11 / patched / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 07 - 31 <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> if ( fa * fb > = 0 . 0 ) { <nl> - throw new ConvergenceException ( <nl> - " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> - " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> - " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> - numIterations , maximumIterations , initial , <nl> - lowerBound , upperBound , a , b , fa , fb ) ; <nl> } <nl> return new double [ ] { a , b } ; <nl> 
0<ml>ARJA_Closure-125_P_Patch_3_3.txt<ml>ARJA_Closure-125_P_Patch_3_3.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_125 / src / com / google / javascript / jscomp / type / SemanticReverseAbstractInterpreter . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_125 / patches_l8vm / Patch_3 / patched / com / google / javascript / jscomp / type / SemanticReverseAbstractInterpreter . java 	 2019 - 08 - 12 <nl> case Token . SHEQ : <nl> if ( outcome ) { <nl> - return caseEquality ( condition , blindScope , SHEQ ) ; <nl> } else { <nl> return caseEquality ( condition , blindScope , SHNE ) ; <nl> } <nl> 
0<ml>ARJA_Closure-46_P_Patch_1110_1110.txt<ml>ARJA_Closure-46_P_Patch_1110_1110.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_46 / patches_euvt / Patch_1110 / patched / com / google / javascript / rhino / jstype / PrototypeObjectType . java 	 2019 - 08 - 11 <nl> sb . append ( getPropertyType ( property ) . toString ( ) ) ; <nl> + + i ; <nl> - if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { <nl> - sb . append ( " , . . . " ) ; <nl> - break ; <nl> - } <nl> } <nl> sb . append ( " } " ) ; <nl> mmm  / tmp / Arja_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordTypeBuilder . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_46 / patches_euvt / Patch_1110 / patched / com / google / javascript / rhino / jstype / RecordTypeBuilder . java 	 2019 - 08 - 11 <nl> public JSType build ( ) { <nl> / / If we have an empty record , simply return the object type . <nl> if ( isEmpty ) { <nl> - return registry . getNativeObjectType ( JSTypeNative . OBJECT_TYPE ) ; <nl> } <nl> return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; <nl> mmm  / tmp / Arja_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordType . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_46 / patches_euvt / Patch_1110 / patched / com / google / javascript / rhino / jstype / RecordType . java 	 2019 - 08 - 11 <nl> Set < String > keySet = properties . keySet ( ) ; <nl> Map < String , JSType > otherProps = otherRecord . properties ; <nl> if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { <nl> - return false ; <nl> + return true ; <nl> } <nl> for ( String key : keySet ) { <nl> if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { <nl> getPropertyNode ( property ) ) ; <nl> } <nl> - for ( String property : thatRecord . properties . keySet ( ) ) { <nl> - if ( ! hasProperty ( property ) ) { <nl> - builder . addProperty ( property , thatRecord . getPropertyType ( property ) , <nl> - thatRecord . getPropertyNode ( property ) ) ; <nl> - } <nl> - } <nl> - <nl> return builder . build ( ) ; <nl> } <nl> 
0<ml>ARJA_Chart-14_P_Patch_972_738.txt<ml>ARJA_Chart-14_P_Patch_972_738.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_14 / source / org / jfree / chart / plot / CategoryPlot . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_14 / patches_unzb / Patch_738 / patched / org / jfree / chart / plot / CategoryPlot . java 	 2019 - 07 - 19 <nl> boolean notify ) { <nl> ArrayList markers ; <nl> if ( layer = = Layer . FOREGROUND ) { <nl> - markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( <nl> - index ) ) ; <nl> + return this . rangeCrosshairVisible ; <nl> } <nl> else { <nl> markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( <nl> * @ see # addRangeMarker ( Marker ) <nl> * / <nl> public boolean removeRangeMarker ( Marker marker ) { <nl> - return removeRangeMarker ( marker , Layer . FOREGROUND ) ; <nl> + return this . rangeCrosshairVisible ; <nl> } <nl> / * * <nl> mmm  / tmp / Arja_Defects4J_Chart_14 / source / org / jfree / chart / plot / XYPlot . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_14 / patches_unzb / Patch_738 / patched / org / jfree / chart / plot / XYPlot . java 	 2019 - 07 - 19 <nl> * @ since 1 . 0 . 7 <nl> * / <nl> public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { <nl> - return removeDomainMarker ( index , marker , layer , true ) ; <nl> + return this . domainZeroBaselineVisible ; <nl> } <nl> / * * <nl> * @ since 1 . 0 . 7 <nl> * / <nl> public boolean removeRangeMarker ( Marker marker , Layer layer ) { <nl> - return removeRangeMarker ( 0 , marker , layer ) ; <nl> + return false ; <nl> } <nl> / * * <nl> 
0<ml>ARJA_Math-95_P_Patch_179_153.txt<ml>ARJA_Math-95_P_Patch_179_153.txt<ml>mmm  / tmp / Arja_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_95 / patches_9bcp / Patch_153 / patched / org / apache / commons / math / distribution / FDistributionImpl . java 	 2019 - 07 - 31 <nl> * / <nl> public double inverseCumulativeProbability ( final double p ) <nl> throws MathException { <nl> - if ( p = = 0 ) { <nl> + setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; <nl> + if ( p = = 0 ) { <nl> return 0d ; <nl> } <nl> if ( p = = 1 ) { <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> - return ret ; <nl> + return 0 ; <nl> } <nl> / * * <nl> 
0<ml>ARJA_Chart-1_P_Patch_12_12.txt<ml>ARJA_Chart-1_P_Patch_12_12.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2019 - 07 - 18 <nl> ppp  / tmp / Arja_Defects4J_Chart_1 / patches_hz0m / Patch_12 / patched / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2019 - 07 - 18 <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> - return result ; <nl> - } <nl> + setPlot ( plot ) ; <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { <nl> for ( int i = 0 ; i < seriesCount ; i + + ) { <nl> 
0<ml>ARJA_Chart-5_P_Patch_86_70.txt<ml>ARJA_Chart-5_P_Patch_86_70.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeries . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_5 / patches_clxy / Patch_70 / patched / org / jfree / data / xy / XYSeries . java 	 2019 - 07 - 19 <nl> existing . setY ( y ) ; <nl> } <nl> else { <nl> - / / if the series is sorted , the negative index is a result from <nl> - / / Collections . binarySearch ( ) and tells us where to insert the <nl> - / / new item . . . otherwise it will be just - 1 and we should just <nl> - / / append the value to the list . . . <nl> - if ( this . autoSort ) { <nl> - this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <nl> - } <nl> - else { <nl> - this . data . add ( new XYDataItem ( x , y ) ) ; <nl> - } <nl> - / / check if this addition will exceed the maximum item count . . . <nl> + this . data . add ( new XYDataItem ( x , y ) ) ; <nl> + / / check if this addition will exceed the maximum item count . . . <nl> if ( getItemCount ( ) > this . maximumItemCount ) { <nl> this . data . remove ( 0 ) ; <nl> } <nl> 
0<ml>ARJA_Closure-67_P_Patch_7_1.txt<ml>ARJA_Closure-67_P_Patch_7_1.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_67 / src / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_67 / patches_we9z / Patch_1 / patched / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2019 - 08 - 11 <nl> for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { <nl> boolean canRemove = false ; <nl> - if ( specializationState = = null ) { <nl> - canRemove = true ; <nl> - } else { <nl> - Node specializableFunction = <nl> - getSpecializableFunctionFromSymbol ( declaration ) ; <nl> - <nl> - if ( specializableFunction ! = null ) { <nl> - specializationState . reportRemovedFunction ( <nl> - specializableFunction , null ) ; <nl> - canRemove = true ; <nl> - } <nl> - } <nl> - <nl> if ( canRemove ) { <nl> declaration . remove ( ) ; <nl> changed = true ; <nl> 
0<ml>ARJA_Closure-8_P_Patch_46_19.txt<ml>ARJA_Closure-8_P_Patch_46_19.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_8 / src / com / google / javascript / jscomp / CollapseVariableDeclarations . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_8 / patches_lr4t / Patch_19 / patched / com / google / javascript / jscomp / CollapseVariableDeclarations . java 	 2019 - 08 - 11 <nl> if ( ! collapses . isEmpty ( ) ) { <nl> applyCollapses ( ) ; <nl> - compiler . reportCodeChange ( ) ; <nl> } <nl> } <nl> private void applyCollapses ( ) { <nl> - for ( Collapse collapse : collapses ) { <nl> - <nl> - Node var = new Node ( Token . VAR ) ; <nl> - var . copyInformationFrom ( collapse . startNode ) ; <nl> - collapse . parent . addChildBefore ( var , collapse . startNode ) ; <nl> - <nl> - boolean redeclaration = false ; <nl> - for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { <nl> - Node next = n . getNext ( ) ; <nl> - <nl> - Preconditions . checkState ( var . getNext ( ) = = n ) ; <nl> - collapse . parent . removeChildAfter ( var ) ; <nl> - <nl> - if ( n . isVar ( ) ) { <nl> - while ( n . hasChildren ( ) ) { <nl> - var . addChildToBack ( n . removeFirstChild ( ) ) ; <nl> - } <nl> - } else { <nl> - Node assign = n . getFirstChild ( ) ; <nl> - Node lhs = assign . getFirstChild ( ) ; <nl> - Preconditions . checkState ( lhs . isName ( ) ) ; <nl> - Node rhs = assign . getLastChild ( ) ; <nl> - lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; <nl> - var . addChildToBack ( lhs . detachFromParent ( ) ) ; <nl> - redeclaration = true ; <nl> - } <nl> - n = next ; <nl> - } <nl> - <nl> - if ( redeclaration ) { <nl> - JSDocInfo info = new JSDocInfo ( ) ; <nl> - info . addSuppression ( " duplicate " ) ; <nl> - var . setJSDocInfo ( info ) ; <nl> - } <nl> - } <nl> } <nl> } <nl> 
0<ml>ARJA_Closure-121_P_Patch_4_3.txt<ml>ARJA_Closure-121_P_Patch_4_3.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_121 / src / com / google / javascript / jscomp / GlobalVarReferenceMap . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_121 / patches_me9y / Patch_3 / patched / com / google / javascript / jscomp / GlobalVarReferenceMap . java 	 2019 - 08 - 12 <nl> for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { <nl> Var var = entry . getKey ( ) ; <nl> if ( var . isGlobal ( ) ) { <nl> - refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; <nl> } <nl> } <nl> } <nl> 
0<ml>ARJA_Math-80_P_Patch_12_11.txt<ml>ARJA_Math-80_P_Patch_12_11.txt<ml>mmm  / tmp / Arja_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_80 / patches_kh1g / Patch_11 / patched / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 07 - 31 <nl> work [ l - 2 * pingPong ] = <nl> Math . min ( work [ l - 2 * pingPong ] , <nl> Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; <nl> - qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; <nl> + dMin = 0 . 0 ; <nl> dMin = - 0 . 0 ; <nl> } <nl> } <nl> } else { <nl> / / early failure . Divide by 4 . <nl> tau * = 0 . 25 ; <nl> - tType - = 12 ; <nl> + tType = - 8 ; <nl> } <nl> } else if ( Double . isNaN ( dMin ) ) { <nl> tau = 0 . 0 ; <nl> / / flip array <nl> int j = 4 * n - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> - work [ i + k ] = work [ j - k ] ; <nl> - work [ j - k ] = tmp ; <nl> - } <nl> j - = 4 ; <nl> } <nl> return true ; <nl> 
0<ml>ARJA_Closure-59_P_Patch_81_59.txt<ml>ARJA_Closure-59_P_Patch_81_59.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_59 / src / com / google / javascript / jscomp / WarningLevel . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_59 / patches_m0ey / Patch_59 / patched / com / google / javascript / jscomp / WarningLevel . java 	 2019 - 08 - 11 <nl> addDefaultWarnings ( options ) ; <nl> break ; <nl> case VERBOSE : <nl> - addVerboseWarnings ( options ) ; <nl> + ; <nl> break ; <nl> default : <nl> throw new RuntimeException ( " Unknown warning level . " ) ; <nl> 
0<ml>ARJA_Lang-7_P_Patch_219_193.txt<ml>ARJA_Lang-7_P_Patch_219_193.txt<ml>mmm  / tmp / Arja_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / event / EventListenerSupport . java 	 2019 - 07 - 22 <nl> ppp  / tmp / Arja_Defects4J_Lang_7 / patches_j21g / Patch_193 / patched / org / apache / commons / lang3 / event / EventListenerSupport . java 	 2019 - 07 - 22 <nl> public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { <nl> this ( ) ; <nl> Validate . notNull ( listenerInterface , " Listener interface cannot be null . " ) ; <nl> - Validate . notNull ( classLoader , " ClassLoader cannot be null . " ) ; <nl> + Validate . notNull ( listenerInterface , " Listener interface cannot be null . " ) ; <nl> Validate . isTrue ( listenerInterface . isInterface ( ) , " Class { 0 } is not an interface " , <nl> listenerInterface . getName ( ) ) ; <nl> initializeTransientFields ( listenerInterface , classLoader ) ; <nl> * @ param classLoader the class loader to be used <nl> * / <nl> private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { <nl> - proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , <nl> + Validate . isTrue ( listenerInterface . isInterface ( ) , " Class { 0 } is not an interface " , listenerInterface . getName ( ) ) ; <nl> + proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , <nl> new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; <nl> } <nl> mmm  / tmp / Arja_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 22 <nl> ppp  / tmp / Arja_Defects4J_Lang_7 / patches_j21g / Patch_193 / patched / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 22 <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> if ( str . startsWith ( " - - " ) ) { <nl> - return null ; <nl> } <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> int hexDigits = str . length ( ) - 2 ; / / drop 0x <nl> 
1<ml>ARJA_Closure-115_C_Patch_3_3.txt<ml>ARJA_Closure-115_C_Patch_3_3.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_115 / src / com / google / javascript / jscomp / FunctionInjector . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_115 / patches_9qfg / Patch_3 / patched / com / google / javascript / jscomp / FunctionInjector . java 	 2019 - 08 - 12 <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> - return CanInlineResult . NO ; <nl> } <nl> / / Check for arguments that are evaluated more than once . <nl> / / Note : Unlike block inlining , there it is not possible that a <nl> 
0<ml>ARJA_Math-84_P_Patch_520_355.txt<ml>ARJA_Math-84_P_Patch_520_355.txt<ml>mmm  / tmp / Arja_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2019 - 07 - 31 <nl> ppp  / tmp / Arja_Defects4J_Math_84 / patches_mko5 / Patch_355 / patched / org / apache / commons / math / optimization / direct / MultiDirectional . java 	 2019 - 07 - 31 <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( comparator . compare ( contracted , best ) < 0 ) { <nl> - / / accept the contracted simplex <nl> - <nl> - / / check convergence <nl> - return ; <nl> - } <nl> + break ; <nl> } <nl> 
0<ml>ARJA_Closure-78_P_Patch_7_4.txt<ml>ARJA_Closure-78_P_Patch_7_4.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_78 / src / com / google / javascript / jscomp / PeepholeFoldConstants . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_78 / patches_5i9v / Patch_4 / patched / com / google / javascript / jscomp / PeepholeFoldConstants . java 	 2019 - 08 - 11 <nl> reportCodeChange ( ) ; <nl> return result ; <nl> } <nl> - return n ; <nl> + return null ; <nl> } <nl> / * * <nl> ( NodeUtil . isAssociative ( opType ) & & NodeUtil . isCommutative ( opType ) ) <nl> | | n . getType ( ) = = Token . ADD ) ; <nl> - Preconditions . checkState ( <nl> - n . getType ( ) ! = Token . ADD | | ! NodeUtil . mayBeString ( n ) ) ; <nl> - <nl> / / Use getNumberValue to handle constants like " NaN " and " Infinity " <nl> / / other values are converted to numbers elsewhere . <nl> Double rightValObj = NodeUtil . getNumberValue ( right ) ; <nl> mmm  / tmp / Arja_Defects4J_Closure_78 / src / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_78 / patches_5i9v / Patch_4 / patched / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2019 - 08 - 11 <nl> * / <nl> protected void error ( DiagnosticType diagnostic , Node n ) { <nl> JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; <nl> - currentTraversal . getCompiler ( ) . report ( error ) ; <nl> } <nl> / * * <nl> 
0<ml>ARJA_Chart-15_P_Patch_16_14.txt<ml>ARJA_Chart-15_P_Patch_16_14.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_15 / source / org / jfree / chart / ChartFactory . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_15 / patches_rx8d / Patch_14 / patched / org / jfree / chart / ChartFactory . java 	 2019 - 07 - 19 <nl> boolean tooltips , <nl> boolean urls ) { <nl> - PiePlot3D plot = new PiePlot3D ( dataset ) ; <nl> + PiePlot plot = new PiePlot ( dataset ) ; <nl> plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; <nl> if ( tooltips ) { <nl> plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; <nl> mmm  / tmp / Arja_Defects4J_Chart_15 / source / org / jfree / chart / plot / PiePlot . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_15 / patches_rx8d / Patch_14 / patched / org / jfree / chart / plot / PiePlot . java 	 2019 - 07 - 19 <nl> PiePlot plot , Integer index , PlotRenderingInfo info ) { <nl> PiePlotState state = new PiePlotState ( info ) ; <nl> - state . setPassesRequired ( 2 ) ; <nl> + g2 . setPaint ( Color . gray ) ; <nl> state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( <nl> plot . getDataset ( ) ) ) ; <nl> state . setLatestAngle ( plot . getStartAngle ( ) ) ; <nl> LegendItemCollection result = new LegendItemCollection ( ) ; <nl> if ( this . dataset = = null ) { <nl> - return result ; <nl> + return null ; <nl> } <nl> List keys = this . dataset . getKeys ( ) ; <nl> int section = 0 ; <nl> 
1<ml>ARJA_Math-58_C_Patch_184_149.txt<ml>ARJA_Math-58_C_Patch_184_149.txt<ml>mmm  / tmp / Arja_Defects4J_Math_58 / src / main / java / org / apache / commons / math / optimization / fitting / GaussianFitter . java 	 2019 - 07 - 30 <nl> ppp  / tmp / Arja_Defects4J_Math_58 / patches_vq7e / Patch_149 / patched / org / apache / commons / math / optimization / fitting / GaussianFitter . java 	 2019 - 07 - 30 <nl> * / <nl> public double [ ] fit ( ) { <nl> final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; <nl> - return fit ( new Gaussian . Parametric ( ) , guess ) ; <nl> + return fit ( ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ) ; <nl> } <nl> / * * <nl> 
0<ml>ARJA_Math-56_P_Patch_672_360.txt<ml>ARJA_Math-56_P_Patch_672_360.txt<ml>mmm  / tmp / Arja_Defects4J_Math_56 / src / main / java / org / apache / commons / math / util / MultidimensionalCounter . java 	 2019 - 07 - 30 <nl> ppp  / tmp / Arja_Defects4J_Math_56 / patches_zemo / Patch_360 / patched / org / apache / commons / math / util / MultidimensionalCounter . java 	 2019 - 07 - 30 <nl> int idx = 1 ; <nl> while ( count < index ) { <nl> count + = idx ; <nl> - + + idx ; <nl> + while ( count < index ) { <nl> + count + = idx ; <nl> + + + idx ; <nl> + } <nl> + + + idx ; <nl> } <nl> - - idx ; <nl> indices [ last ] = idx ; <nl> 
0<ml>ARJA_Closure-124_P_Patch_5_5.txt<ml>ARJA_Closure-124_P_Patch_5_5.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_124 / src / com / google / javascript / jscomp / ExploitAssigns . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_124 / patches_6aox / Patch_5 / patched / com / google / javascript / jscomp / ExploitAssigns . java 	 2019 - 08 - 12 <nl> / / Dive down the right side of the assign . <nl> parent = next ; <nl> next = leftSide . getNext ( ) ; <nl> - break ; <nl> } else { <nl> return false ; <nl> } <nl> 
0<ml>ARJA_Closure-7_P_Patch_131_131.txt<ml>ARJA_Closure-7_P_Patch_131_131.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_7 / src / com / google / javascript / rhino / jstype / UnionType . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_7 / patches_4ap9 / Patch_131 / patched / com / google / javascript / rhino / jstype / UnionType . java 	 2019 - 08 - 11 <nl> boolean checkUnionEquivalenceHelper ( <nl> UnionType that , boolean tolerateUnknowns ) { <nl> if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { <nl> - return false ; <nl> + return true ; <nl> } <nl> for ( JSType alternate : that . alternates ) { <nl> if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) { <nl> 
0<ml>ARJA_Closure-68_P_Patch_1_1.txt<ml>ARJA_Closure-68_P_Patch_1_1.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_68 / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_68 / patches_6yhe / Patch_1 / patched / com / google / javascript / jscomp / parsing / JsDocInfoParser . java 	 2019 - 08 - 11 <nl> case EOF : <nl> / / discard any accumulated information <nl> jsdocBuilder . build ( null ) ; <nl> - parser . addParserWarning ( " msg . unexpected . eof " , <nl> - stream . getLineno ( ) , stream . getCharno ( ) ) ; <nl> + ; <nl> checkExtendedTypes ( extendedTypes ) ; <nl> return false ; <nl> 
0<ml>ARJA_Closure-120_P_Patch_17_11.txt<ml>ARJA_Closure-120_P_Patch_17_11.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_120 / src / com / google / javascript / jscomp / GlobalVarReferenceMap . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_120 / patches_ukx3 / Patch_11 / patched / com / google / javascript / jscomp / GlobalVarReferenceMap . java 	 2019 - 08 - 12 <nl> refMap = Maps . newHashMap ( ) ; <nl> for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { <nl> Var var = entry . getKey ( ) ; <nl> - if ( var . isGlobal ( ) ) { <nl> - refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; <nl> - } <nl> } <nl> } <nl> 
0<ml>ARJA_Closure-22_P_Patch_2_2.txt<ml>ARJA_Closure-22_P_Patch_2_2.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_22 / patches_iu5x / Patch_2 / patched / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> / / fix up the tree in more clever ways when these are removed . <nl> if ( parent . getType ( ) = = Token . COMMA ) { <nl> Node gramps = parent . getParent ( ) ; <nl> - if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { <nl> - if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & " eval " . equals ( n . getNext ( ) . getString ( ) ) ) { <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - / / This no - op statement was there so that JSDoc information could <nl> + / / This no - op statement was there so that JSDoc information could <nl> / / be attached to the name . This check should not complain about it . <nl> if ( n = = parent . getLastChild ( ) ) { <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> if ( ancestorType = = Token . COMMA ) <nl> continue ; <nl> if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) <nl> - return ; <nl> - else <nl> + ; <nl> + else <nl> break ; <nl> } <nl> } <nl> 
0<ml>ARJA_Closure-133_P_Patch_3_3.txt<ml>ARJA_Closure-133_P_Patch_3_3.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_133 / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_133 / patches_d8o1 / Patch_3 / patched / com / google / javascript / jscomp / parsing / JsDocInfoParser . java 	 2019 - 08 - 12 <nl> } <nl> } <nl> - restoreLookAhead ( token ) ; <nl> return reportGenericTypeSyntaxWarning ( ) ; <nl> } <nl> 
0<ml>ARJA_Closure-116_P_Patch_125_120.txt<ml>ARJA_Closure-116_P_Patch_125_120.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_116 / src / com / google / javascript / jscomp / FunctionInjector . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_116 / patches_zern / Patch_120 / patched / com / google / javascript / jscomp / FunctionInjector . java 	 2019 - 08 - 12 <nl> / / Only inline functions that return something . <nl> if ( block . getFirstChild ( ) . isReturn ( ) <nl> & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { <nl> - return true ; <nl> + return false ; <nl> } <nl> } <nl> mmm  / tmp / Arja_Defects4J_Closure_116 / src / com / google / javascript / jscomp / ExpressionDecomposer . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_116 / patches_zern / Patch_120 / patched / com / google / javascript / jscomp / ExpressionDecomposer . java 	 2019 - 08 - 12 <nl> & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { <nl> Node functionExpression = parent . getFirstChild ( ) ; <nl> decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; <nl> - / / Now handle the call expression <nl> - if ( isExpressionTreeUnsafe ( functionExpression , state . sideEffects ) <nl> - & & functionExpression . getFirstChild ( ) ! = grandchild ) { <nl> - / / TODO ( johnlenz ) : In Internet Explorer , non - JavaScript objects such <nl> - / / as DOM objects can not be decomposed . <nl> - Preconditions . checkState ( allowObjectCallDecomposing ( ) , <nl> - " Object method calls can not be decomposed . " ) ; <nl> - / / Either there were preexisting side - effects , or this node has <nl> - / / side - effects . <nl> - state . sideEffects = true ; <nl> - <nl> - / / Rewrite the call so " this " is preserved . <nl> - Node replacement = rewriteCallExpression ( parent , state ) ; <nl> - / / Continue from here . <nl> - parent = replacement ; <nl> - } <nl> } else if ( parentType = = Token . OBJECTLIT ) { <nl> decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; <nl> } else { <nl> mmm  / tmp / Arja_Defects4J_Closure_116 / src / com / google / javascript / rhino / Node . java 	 2019 - 08 - 12 <nl> ppp  / tmp / Arja_Defects4J_Closure_116 / patches_zern / Patch_120 / patched / com / google / javascript / rhino / Node . java 	 2019 - 08 - 12 <nl> } <nl> res = n . checkTreeEqualsImpl ( n2 ) ; <nl> if ( res ! = null ) { <nl> - return res ; <nl> + return null ; <nl> } <nl> } <nl> return res ; <nl> 
0<ml>ARJA_Closure-75_P_Patch_135_77.txt<ml>ARJA_Closure-75_P_Patch_135_77.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_75 / src / com / google / javascript / jscomp / CodeGenerator . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_75 / patches_tjoc / Patch_77 / patched / com / google / javascript / jscomp / CodeGenerator . java 	 2019 - 08 - 11 <nl> if ( c > 0x1f & & c < = 0x7f ) { <nl> sb . append ( c ) ; <nl> } else { <nl> - / / Other characters can be misinterpreted by some js parsers , <nl> - / / or perhaps mangled by proxies along the way , <nl> - / / so we play it safe and unicode escape them . <nl> - appendHexJavaScriptRepresentation ( sb , c ) ; <nl> } <nl> } <nl> } <nl> appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; <nl> return ; <nl> } <nl> - out . append ( " \ \ u " ) <nl> - . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) <nl> - . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) <nl> - . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) <nl> - . append ( HEX_CHARS [ codePoint & 0xf ] ) ; <nl> } <nl> } <nl> mmm  / tmp / Arja_Defects4J_Closure_75 / src / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_75 / patches_tjoc / Patch_77 / patched / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 11 <nl> } <nl> try { <nl> - return Double . parseDouble ( s ) ; <nl> + return null ; <nl> } catch ( NumberFormatException e ) { <nl> return Double . NaN ; <nl> } <nl> 
0<ml>ARJA_Closure-10_P_Patch_47_27.txt<ml>ARJA_Closure-10_P_Patch_47_27.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_10 / src / com / google / javascript / rhino / Node . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_10 / patches_uv4f / Patch_27 / patched / com / google / javascript / rhino / Node . java 	 2019 - 08 - 11 <nl> } <nl> res = n . checkTreeEqualsImpl ( n2 ) ; <nl> if ( res ! = null ) { <nl> - return res ; <nl> + return null ; <nl> } <nl> } <nl> return res ; <nl> mmm  / tmp / Arja_Defects4J_Closure_10 / src / com / google / javascript / rhino / Token . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_10 / patches_uv4f / Patch_27 / patched / com / google / javascript / rhino / Token . java 	 2019 - 08 - 11 <nl> case NE : return " NE " ; <nl> case LT : return " LT " ; <nl> case LE : return " LE " ; <nl> - case GT : return " GT " ; <nl> + case GT : ; <nl> case GE : return " GE " ; <nl> case LSH : return " LSH " ; <nl> case RSH : return " RSH " ; <nl> 
0<ml>ARJA_Closure-112_P_Patch_2_2.txt<ml>ARJA_Closure-112_P_Patch_2_2.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_112 / src / com / google / javascript / jscomp / TypeInference . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_112 / patches_f37u / Patch_2 / patched / com / google / javascript / jscomp / TypeInference . java 	 2019 - 08 - 11 <nl> for ( JSType alernative : unionType . getAlternates ( ) ) { <nl> maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; <nl> } <nl> - } else if ( paramType . isFunctionType ( ) ) { <nl> - FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; <nl> - FunctionType argFunctionType = argType <nl> - . restrictByNotNullOrUndefined ( ) <nl> - . collapseUnion ( ) <nl> - . toMaybeFunctionType ( ) ; <nl> - if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { <nl> - / / infer from return type of the function type <nl> - maybeResolveTemplatedType ( <nl> - paramFunctionType . getTypeOfThis ( ) , <nl> - argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; <nl> - / / infer from return type of the function type <nl> - maybeResolveTemplatedType ( <nl> - paramFunctionType . getReturnType ( ) , <nl> - argFunctionType . getReturnType ( ) , resolvedTypes ) ; <nl> - / / infer from parameter types of the function type <nl> - maybeResolveTemplateTypeFromNodes ( <nl> - paramFunctionType . getParameters ( ) , <nl> - argFunctionType . getParameters ( ) , resolvedTypes ) ; <nl> - } <nl> - } else if ( paramType . isTemplatizedType ( ) ) { <nl> - / / @ param { Array . < T > } <nl> - ObjectType referencedParamType = paramType <nl> - . toMaybeTemplatizedType ( ) <nl> - . getReferencedType ( ) ; <nl> - JSType argObjectType = argType <nl> - . restrictByNotNullOrUndefined ( ) <nl> - . collapseUnion ( ) ; <nl> - <nl> - if ( argObjectType . isSubtype ( referencedParamType ) ) { <nl> - / / If the argument type is a subtype of the parameter type , resolve any <nl> - / / template types amongst their templatized types . <nl> - TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; <nl> - TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; <nl> - for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { <nl> - maybeResolveTemplatedType ( <nl> - paramTypeMap . getTemplateType ( key ) , <nl> - argTypeMap . getTemplateType ( key ) , <nl> - resolvedTypes ) ; <nl> - } <nl> - } <nl> - } <nl> + } else <nl> + ; <nl> } <nl> private void maybeResolveTemplateTypeFromNodes ( <nl> TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; <nl> TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( <nl> registry , typeMap ) ; <nl> - propertyType = propertyType . visit ( replacer ) ; <nl> + return null ; <nl> } <nl> } <nl> 
0<ml>ARJA_Chart-3_P_Patch_604_568.txt<ml>ARJA_Chart-3_P_Patch_604_568.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_3 / source / org / jfree / data / time / TimeSeries . java 	 2019 - 07 - 18 <nl> ppp  / tmp / Arja_Defects4J_Chart_3 / patches_itwf / Patch_568 / patched / org / jfree / data / time / TimeSeries . java 	 2019 - 07 - 19 <nl> Class c = item . getPeriod ( ) . getClass ( ) ; <nl> if ( this . timePeriodClass = = null ) { <nl> this . timePeriodClass = c ; <nl> - } <nl> - else if ( ! this . timePeriodClass . equals ( c ) ) { <nl> - StringBuffer b = new StringBuffer ( ) ; <nl> - b . append ( " You are trying to add data where the time period class " ) ; <nl> - b . append ( " is " ) ; <nl> - b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; <nl> - b . append ( " , but the TimeSeries is expecting an instance of " ) ; <nl> - b . append ( this . timePeriodClass . getName ( ) ) ; <nl> - b . append ( " . " ) ; <nl> - throw new SeriesException ( b . toString ( ) ) ; <nl> - } <nl> + } else <nl> + findBoundsByIteration ( ) ; <nl> / / make the change ( if it ' s not a duplicate time period ) . . . <nl> boolean added = false ; <nl> public void add ( RegularTimePeriod period , double value , boolean notify ) { <nl> / / defer argument checking . . . <nl> TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; <nl> - add ( item , notify ) ; <nl> + if ( notify ) { <nl> + fireSeriesChanged ( ) ; <nl> + } <nl> + add ( item , notify ) ; <nl> } <nl> / * * <nl> 
1<ml>ARJA_Chart-12_C_Patch_87_84.txt<ml>ARJA_Chart-12_C_Patch_87_84.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_12 / source / org / jfree / chart / plot / MultiplePiePlot . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_12 / patches_p20q / Patch_84 / patched / org / jfree / chart / plot / MultiplePiePlot . java 	 2019 - 07 - 19 <nl> this . dataset = dataset ; <nl> PiePlot piePlot = new PiePlot ( null ) ; <nl> this . pieChart = new JFreeChart ( piePlot ) ; <nl> - this . pieChart . removeLegend ( ) ; <nl> + setDataset ( dataset ) ; <nl> + this . pieChart . removeLegend ( ) ; <nl> this . dataExtractOrder = TableOrder . BY_COLUMN ; <nl> this . pieChart . setBackgroundPaint ( null ) ; <nl> TextTitle seriesTitle = new TextTitle ( " Series Title " , <nl> 
0<ml>ARJA_Closure-21_P_Patch_18_5.txt<ml>ARJA_Closure-21_P_Patch_18_5.txt<ml>mmm  / tmp / Arja_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> ppp  / tmp / Arja_Defects4J_Closure_21 / patches_yxa3 / Patch_5 / patched / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) continue ; <nl> - if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> - else break ; <nl> + break ; <nl> } <nl> } <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> 
0<ml>ARJA_Math-74_P_Patch_245_203.txt<ml>ARJA_Math-74_P_Patch_245_203.txt<ml>mmm  / tmp / Arja_Defects4J_Math_74 / src / main / java / org / apache / commons / math / ode / nonstiff / AdamsMoultonIntegrator . java 	 2019 - 07 - 30 <nl> ppp  / tmp / Arja_Defects4J_Math_74 / patches_w3ps / Patch_203 / patched / org / apache / commons / math / ode / nonstiff / AdamsMoultonIntegrator . java 	 2019 - 07 - 30 <nl> stepSize = hNew ; <nl> - / / predict a first estimate of the state at step end ( P in the PECE sequence ) <nl> + lastStep = manager . stop ( ) ; <nl> + / / predict a first estimate of the state at step end ( P in the PECE sequence ) <nl> final double stepEnd = stepStart + stepSize ; <nl> interpolator . setInterpolatedTime ( stepEnd ) ; <nl> System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; <nl> / / discrete events handling <nl> interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; <nl> - interpolatorTmp . storeTime ( stepStart ) ; <nl> + setMaxGrowth ( 10 . 0 ) ; <nl> + interpolatorTmp . storeTime ( stepStart ) ; <nl> interpolatorTmp . shift ( ) ; <nl> interpolatorTmp . storeTime ( stepEnd ) ; <nl> if ( manager . evaluateStep ( interpolatorTmp ) ) { <nl> 
0<ml>ARJA_Chart-7_P_Patch_362_357.txt<ml>ARJA_Chart-7_P_Patch_362_357.txt<ml>mmm  / tmp / Arja_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValues . java 	 2019 - 07 - 19 <nl> ppp  / tmp / Arja_Defects4J_Chart_7 / patches_cz2a / Patch_357 / patched / org / jfree / data / time / TimePeriodValues . java 	 2019 - 07 - 19 <nl> long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) <nl> . getTime ( ) ; <nl> if ( end < minEnd ) { <nl> - this . minEndIndex = index ; <nl> + this . data . remove ( index ) ; <nl> + this . minEndIndex = index ; <nl> } <nl> } <nl> else { <nl> 
0<ml>GenProg-A_Math-40_P_Patch_1241_726.txt<ml>GenProg-A_Math-40_P_Patch_1241_726.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_40 / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_40 / patches_ezc5 / Patch_726 / patched / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java 	 2019 - 08 - 01 <nl> System . arraycopy ( y , start , y , 0 , nbPoints ) ; <nl> signChangeIndex - = start ; <nl> - } else if ( nbPoints = = x . length ) { <nl> - <nl> - / / we have to drop one point in order to insert the new one <nl> - nbPoints - - ; <nl> - <nl> - / / keep the tightest bracketing interval as centered as possible <nl> - if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { <nl> - / / we drop the lowest point , we have to shift the arrays and the index <nl> - System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; <nl> - System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; <nl> - - - signChangeIndex ; <nl> - } <nl> - <nl> - } <nl> + } else { <nl> + signChangeIndex = 2 ; <nl> + if ( nbPoints = = x . length ) { <nl> + nbPoints - - ; <nl> + if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { <nl> + System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; <nl> + System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; <nl> + - - signChangeIndex ; <nl> + } <nl> + } <nl> + } <nl> - / / insert the last computed point <nl> + yB = nextY ; <nl> + / / insert the last computed point <nl> / / ( by construction , we know it lies inside the tightest bracketing interval ) <nl> System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; <nl> x [ signChangeIndex ] = nextX ; <nl> System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; <nl> y [ signChangeIndex ] = nextY ; <nl> - + + nbPoints ; <nl> + if ( agingB > = MAXIMAL_AGING ) { <nl> + targetY = - REDUCTION_FACTOR * yA ; <nl> + } else { <nl> + targetY = 0 ; <nl> + } <nl> + + + nbPoints ; <nl> / / update the bracketing interval <nl> if ( nextY * yA < = 0 ) { <nl> public double solve ( int maxEval , UnivariateFunction f , double min , <nl> double max , double startValue , <nl> AllowedSolution allowedSolution ) { <nl> - this . allowed = allowedSolution ; <nl> - return super . solve ( maxEval , f , min , max , startValue ) ; <nl> + double x1 = getMax ( ) ; <nl> + this . allowed = allowedSolution ; <nl> + verifyInterval ( min , max ) ; <nl> + return super . solve ( maxEval , f , min , max , startValue ) ; <nl> } <nl> } <nl> mmm  / tmp / GenProg_Defects4J_Math_40 / src / main / java / org / apache / commons / math / analysis / solvers / BaseAbstractUnivariateRealSolver . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_40 / patches_ezc5 / Patch_726 / patched / org / apache / commons / math / analysis / solvers / BaseAbstractUnivariateRealSolver . java 	 2019 - 08 - 01 <nl> try { <nl> evaluations . incrementCount ( ) ; <nl> } catch ( MaxCountExceededException e ) { <nl> - throw new TooManyEvaluationsException ( e . getMax ( ) ) ; <nl> + double initial = getStartValue ( ) ; <nl> + throw new TooManyEvaluationsException ( e . getMax ( ) ) ; <nl> } <nl> } <nl> } <nl> 
0<ml>GenProg-A_Closure-55_P_Patch_1_1.txt<ml>GenProg-A_Closure-55_P_Patch_1_1.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_55 / src / com / google / javascript / jscomp / FunctionRewriter . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_55 / patches_jmrq / Patch_1 / patched / com / google / javascript / jscomp / FunctionRewriter . java 	 2019 - 08 - 11 <nl> Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; <nl> - / / Accumulate possible reductions in the reduction multi map . They <nl> - / / will be applied in the loop below . <nl> - NodeTraversal . traverse ( compiler , root , <nl> - new ReductionGatherer ( reducers , reductionMap ) ) ; <nl> - <nl> / / Apply reductions iff they will provide some savings . <nl> for ( Reducer reducer : reducers ) { <nl> Collection < Reduction > reductions = reductionMap . get ( reducer ) ; <nl> 
1<ml>GenProg-A_Closure-126_C_Patch_11_6.txt<ml>GenProg-A_Closure-126_C_Patch_11_6.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPoints . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_126 / patches_wwr6 / Patch_6 / patched / com / google / javascript / jscomp / MinimizeExitPoints . java 	 2019 - 08 - 11 <nl> * / <nl> if ( NodeUtil . hasFinally ( n ) ) { <nl> Node finallyBlock = n . getLastChild ( ) ; <nl> - tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> } <nl> } <nl> 
0<ml>GenProg-A_Chart-13_P_Patch_126_29.txt<ml>GenProg-A_Chart-13_P_Patch_126_29.txt<ml>mmm  / tmp / GenProg_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangement . java 	 2019 - 07 - 23 <nl> ppp  / tmp / GenProg_Defects4J_Chart_13 / patches_8l5v / Patch_29 / patched / org / jfree / chart / block / BorderArrangement . java 	 2019 - 07 - 23 <nl> if ( this . leftBlock ! = null ) { <nl> Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; <nl> w [ 2 ] = size . width ; <nl> - h [ 2 ] = size . height ; <nl> + this . topBlock = null ; <nl> + h [ 2 ] = size . height ; <nl> } <nl> if ( this . rightBlock ! = null ) { <nl> double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; <nl> h [ 0 ] = size . height ; <nl> } <nl> w [ 1 ] = w [ 0 ] ; <nl> - if ( this . bottomBlock ! = null ) { <nl> - RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , <nl> - LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , <nl> - constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; <nl> - Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; <nl> - h [ 1 ] = size . height ; <nl> - } <nl> - h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; <nl> + Size2D s1 = arrangeNN ( container , g2 ) ; <nl> + this . rightBlock = null ; <nl> + h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; <nl> if ( this . leftBlock ! = null ) { <nl> RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , <nl> new Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> 
0<ml>GenProg-A_Math-31_P_Patch_235_119.txt<ml>GenProg-A_Math-31_P_Patch_235_119.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_31 / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java 	 2019 - 07 - 31 <nl> ppp  / tmp / GenProg_Defects4J_Math_31 / patches_xnp9 / Patch_119 / patched / org / apache / commons / math3 / distribution / FDistribution . java 	 2019 - 07 - 31 <nl> * / <nl> public double getNumericalVariance ( ) { <nl> if ( ! numericalVarianceIsCalculated ) { <nl> - numericalVariance = calculateNumericalVariance ( ) ; <nl> + final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; <nl> + numericalVariance = calculateNumericalVariance ( ) ; <nl> numericalVarianceIsCalculated = true ; <nl> } <nl> return numericalVariance ; <nl> mmm  / tmp / GenProg_Defects4J_Math_31 / src / main / java / org / apache / commons / math3 / util / ContinuedFraction . java 	 2019 - 07 - 31 <nl> ppp  / tmp / GenProg_Defects4J_Math_31 / patches_xnp9 / Patch_119 / patched / org / apache / commons / math3 / util / ContinuedFraction . java 	 2019 - 07 - 31 <nl> x ) ; <nl> } <nl> if ( Double . isNaN ( hN ) ) { <nl> - throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , <nl> - x ) ; <nl> + return - 0 . 0 ; <nl> } <nl> if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { <nl> mmm  / tmp / GenProg_Defects4J_Math_31 / src / main / java / org / apache / commons / math3 / exception / MathIllegalStateException . java 	 2019 - 07 - 31 <nl> ppp  / tmp / GenProg_Defects4J_Math_31 / patches_xnp9 / Patch_119 / patched / org / apache / commons / math3 / exception / MathIllegalStateException . java 	 2019 - 07 - 31 <nl> / * * { @ inheritDoc } * / <nl> @ Override <nl> public String getLocalizedMessage ( ) { <nl> - return context . getLocalizedMessage ( ) ; <nl> + return context . getMessage ( ) ; <nl> } <nl> } <nl> 
0<ml>GenProg-A_Chart-25_P_Patch_8_2.txt<ml>GenProg-A_Chart-25_P_Patch_8_2.txt<ml>mmm  / tmp / GenProg_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2019 - 07 - 24 <nl> ppp  / tmp / GenProg_Defects4J_Chart_25 / patches_8aax / Patch_2 / patched / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java 	 2019 - 07 - 24 <nl> Number result = null ; <nl> MeanAndStandardDeviation masd <nl> = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; <nl> - if ( masd ! = null ) { <nl> - result = masd . getMean ( ) ; <nl> - } <nl> return result ; <nl> } <nl> 
0<ml>GenProg-A_Math-81_P_Patch_1_1.txt<ml>GenProg-A_Math-81_P_Patch_1_1.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_81 / patches_dbia / Patch_1 / patched / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 01 <nl> } <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> - / / approximate contribution to norm squared from i < nn - 2 . <nl> - if ( end - start > 2 ) { <nl> - b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> - a2 = a2 + b2 ; <nl> - for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <nl> - if ( b2 = = 0 . 0 ) { <nl> - break ; <nl> - } <nl> - b1 = b2 ; <nl> - if ( work [ i4 ] > work [ i4 - 2 ] ) { <nl> - return ; <nl> - } <nl> - b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; <nl> - a2 = a2 + b2 ; <nl> - if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { <nl> - break ; <nl> - } <nl> - } <nl> - a2 = cnst3 * a2 ; <nl> - } <nl> - <nl> if ( a2 < cnst1 ) { <nl> tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; <nl> } else { <nl> 
0<ml>GenProg-A_Closure-114_P_Patch_34_20.txt<ml>GenProg-A_Closure-114_P_Patch_34_20.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_114 / src / com / google / javascript / jscomp / AstChangeProxy . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_114 / patches_h8i4 / Patch_20 / patched / com / google / javascript / jscomp / AstChangeProxy . java 	 2019 - 08 - 11 <nl> parent . replaceChild ( node , block ) ; <nl> } else { <nl> for ( Node newChild : replacements ) { <nl> - newChild . copyInformationFrom ( node ) ; <nl> + final String paramName = " jscomp_throw_param " ; <nl> + newChild . copyInformationFrom ( node ) ; <nl> parent . addChildBefore ( newChild , node ) ; <nl> } <nl> parent . removeChild ( node ) ; <nl> mmm  / tmp / GenProg_Defects4J_Closure_114 / src / com / google / javascript / jscomp / NameAnalyzer . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_114 / patches_h8i4 / Patch_20 / patched / com / google / javascript / jscomp / NameAnalyzer . java 	 2019 - 08 - 11 <nl> return scopes . get ( parent ) ; <nl> } <nl> - if ( parent . isAssign ( ) ) { <nl> - return scopes . get ( parent ) ; <nl> - } <nl> + final String paramName = " jscomp_throw_param " ; <nl> } <nl> return Collections . emptyList ( ) ; <nl> 
0<ml>GenProg-A_Math-85_P_Patch_220_40.txt<ml>GenProg-A_Math-85_P_Patch_220_40.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_85 / patches_j3jy / Patch_40 / patched / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java 	 2019 - 08 - 01 <nl> do { <nl> a = Math . max ( a - 1 . 0 , lowerBound ) ; <nl> - b = Math . min ( b + 1 . 0 , upperBound ) ; <nl> + int i = 0 ; <nl> + b = Math . min ( b + 1 . 0 , upperBound ) ; <nl> fa = function . value ( a ) ; <nl> fb = function . value ( b ) ; <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> if ( fa * fb > = 0 . 0 ) { <nl> - throw new ConvergenceException ( <nl> - " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> - " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> - " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , <nl> - numIterations , maximumIterations , initial , <nl> - lowerBound , upperBound , a , b , fa , fb ) ; <nl> } <nl> return new double [ ] { a , b } ; <nl> mmm  / tmp / GenProg_Defects4J_Math_85 / src / java / org / apache / commons / math / distribution / AbstractContinuousDistribution . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_85 / patches_j3jy / Patch_40 / patched / org / apache / commons / math / distribution / AbstractContinuousDistribution . java 	 2019 - 08 - 01 <nl> if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { <nl> return lowerBound ; <nl> } <nl> - if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { <nl> + if ( p = = 0 ) { <nl> + return Double . NEGATIVE_INFINITY ; <nl> + } <nl> + if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { <nl> return upperBound ; <nl> } <nl> / / Failed bracket convergence was not because of corner solution <nl> 
0<ml>GenProg-A_Math-95_P_Patch_817_386.txt<ml>GenProg-A_Math-95_P_Patch_817_386.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpl . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_95 / patches_eusf / Patch_386 / patched / org / apache / commons / math / distribution / FDistributionImpl . java 	 2019 - 08 - 01 <nl> if ( x < = 0 . 0 ) { <nl> ret = 0 . 0 ; <nl> } else { <nl> - double n = getNumeratorDegreesOfFreedom ( ) ; <nl> + setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; <nl> + setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; <nl> + setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; <nl> + double n = getNumeratorDegreesOfFreedom ( ) ; <nl> double m = getDenominatorDegreesOfFreedom ( ) ; <nl> ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> - return ret ; <nl> + return p ; <nl> } <nl> / * * <nl> mmm  / tmp / GenProg_Defects4J_Math_95 / src / java / org / apache / commons / math / analysis / UnivariateRealSolverUtils . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_95 / patches_eusf / Patch_386 / patched / org / apache / commons / math / analysis / UnivariateRealSolverUtils . java 	 2019 - 08 - 01 <nl> ( " bad value for maximumIterations : " + maximumIterations ) ; <nl> } <nl> if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { <nl> - throw new IllegalArgumentException <nl> - ( " Invalid endpoint parameters : lowerBound = " + lowerBound + <nl> - " initial = " + initial + " upperBound = " + upperBound ) ; <nl> + int i = 0 ; <nl> + throw new IllegalArgumentException ( " Function is not polynomial . " ) ; <nl> } <nl> double a = initial ; <nl> double b = initial ; <nl> 
0<ml>GenProg-A_Chart-1_P_Patch_104_70.txt<ml>GenProg-A_Chart-1_P_Patch_104_70.txt<ml>mmm  / tmp / GenProg_Defects4J_Chart_1 / source / org / jfree / chart / plot / CategoryPlot . java 	 2019 - 07 - 23 <nl> ppp  / tmp / GenProg_Defects4J_Chart_1 / patches_9l9w / Patch_70 / patched / org / jfree / chart / plot / CategoryPlot . java 	 2019 - 07 - 23 <nl> result = ( ValueAxis ) this . rangeAxes . get ( index ) ; <nl> } <nl> if ( result = = null ) { <nl> - Plot parent = getParent ( ) ; <nl> + CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; <nl> + Plot parent = getParent ( ) ; <nl> if ( parent instanceof CategoryPlot ) { <nl> CategoryPlot cp = ( CategoryPlot ) parent ; <nl> result = cp . getRangeAxis ( index ) ; <nl> * / <nl> public void setDataset ( int index , CategoryDataset dataset ) { <nl> - CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; <nl> + Object result = null ; <nl> + CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; <nl> if ( existing ! = null ) { <nl> existing . removeChangeListener ( this ) ; <nl> } <nl> mmm  / tmp / GenProg_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2019 - 07 - 23 <nl> ppp  / tmp / GenProg_Defects4J_Chart_1 / patches_9l9w / Patch_70 / patched / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java 	 2019 - 07 - 23 <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> if ( dataset ! = null ) { <nl> - return result ; <nl> + Paint outlinePaint = plot . getOutlinePaint ( ) ; <nl> } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { <nl> 
0<ml>GenProg-A_Closure-67_P_Patch_6_1.txt<ml>GenProg-A_Closure-67_P_Patch_6_1.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_67 / src / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_67 / patches_yhkr / Patch_1 / patched / com / google / javascript / jscomp / RemoveUnusedPrototypeProperties . java 	 2019 - 08 - 11 <nl> boolean changed = false ; <nl> for ( NameInfo nameInfo : allNameInfo ) { <nl> if ( ! nameInfo . isReferenced ( ) ) { <nl> - for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { <nl> - boolean canRemove = false ; <nl> - <nl> - if ( specializationState = = null ) { <nl> - canRemove = true ; <nl> - } else { <nl> - Node specializableFunction = <nl> - getSpecializableFunctionFromSymbol ( declaration ) ; <nl> - <nl> - if ( specializableFunction ! = null ) { <nl> - specializationState . reportRemovedFunction ( <nl> - specializableFunction , null ) ; <nl> - canRemove = true ; <nl> - } <nl> - } <nl> - <nl> - if ( canRemove ) { <nl> - declaration . remove ( ) ; <nl> - changed = true ; <nl> - } <nl> - } <nl> - <nl> logger . fine ( " Removed unused prototype property : " + nameInfo . name ) ; <nl> } <nl> } <nl> 
0<ml>GenProg-A_Math-80_P_Patch_9_2.txt<ml>GenProg-A_Math-80_P_Patch_9_2.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 01 <nl> ppp  / tmp / GenProg_Defects4J_Math_80 / patches_hsqy / Patch_2 / patched / org / apache / commons / math / linear / EigenDecompositionImpl . java 	 2019 - 08 - 01 <nl> for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { <nl> if ( work [ i + 2 ] < = 0 ) { <nl> i0 = 1 + i / 4 ; <nl> - break ; <nl> } <nl> if ( diagMin > = 4 * offDiagMax ) { <nl> diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; <nl> work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; <nl> dMin = 0 . 0 ; <nl> updateSigma ( tau ) ; <nl> - return deflatedEnd ; <nl> + final int upperStart = 5 * main . length ; <nl> + return deflatedEnd ; <nl> } else if ( dMin < 0 . 0 ) { <nl> / / tau too big . Select new tau and try again . <nl> if ( tType < - 22 ) { <nl> / / flip array <nl> int j = 4 * n - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ i + k ] ; <nl> - work [ i + k ] = work [ j - k ] ; <nl> - work [ j - k ] = tmp ; <nl> - } <nl> + if ( tType < - 22 ) { <nl> + tau = 0 . 0 ; <nl> + } else if ( dMin1 > 0 . 0 ) { <nl> + tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; <nl> + tType - = 11 ; <nl> + } else { <nl> + tau * = 0 . 25 ; <nl> + tType - = 12 ; <nl> + } <nl> j - = 4 ; <nl> } <nl> return true ; <nl> 
0<ml>GenProg-A_Closure-59_P_Patch_96_27.txt<ml>GenProg-A_Closure-59_P_Patch_96_27.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_59 / src / com / google / javascript / jscomp / WarningLevel . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_59 / patches_imep / Patch_27 / patched / com / google / javascript / jscomp / WarningLevel . java 	 2019 - 08 - 11 <nl> addDefaultWarnings ( options ) ; <nl> break ; <nl> case VERBOSE : <nl> - addVerboseWarnings ( options ) ; <nl> + boolean valid = false ; <nl> break ; <nl> default : <nl> throw new RuntimeException ( " Unknown warning level . " ) ; <nl> 
0<ml>GenProg-A_Lang-7_P_Patch_40_21.txt<ml>GenProg-A_Lang-7_P_Patch_40_21.txt<ml>mmm  / tmp / GenProg_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 26 <nl> ppp  / tmp / GenProg_Defects4J_Lang_7 / patches_sxic / Patch_21 / patched / org / apache / commons / lang3 / math / NumberUtils . java 	 2019 - 07 - 26 <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> if ( str . startsWith ( " - - " ) ) { <nl> - return null ; <nl> + Double d = createDouble ( str ) ; <nl> + return null ; <nl> } <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> int hexDigits = str . length ( ) - 2 ; / / drop 0x <nl> 
0<ml>GenProg-A_Closure-78_P_Patch_23_10.txt<ml>GenProg-A_Closure-78_P_Patch_23_10.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_78 / src / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_78 / patches_i18t / Patch_10 / patched / com / google / javascript / jscomp / AbstractPeepholeOptimization . java 	 2019 - 08 - 11 <nl> * / <nl> protected void error ( DiagnosticType diagnostic , Node n ) { <nl> JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; <nl> - currentTraversal . getCompiler ( ) . report ( error ) ; <nl> + int start = 0 ; <nl> } <nl> / * * <nl> 
0<ml>GenProg-A_Closure-124_P_Patch_25_9.txt<ml>GenProg-A_Closure-124_P_Patch_25_9.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_124 / src / com / google / javascript / jscomp / ExploitAssigns . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_124 / patches_njul / Patch_9 / patched / com / google / javascript / jscomp / ExploitAssigns . java 	 2019 - 08 - 11 <nl> case Token . NAME : <nl> if ( next . isQualifiedName ( ) ) { <nl> String nextName = next . getQualifiedName ( ) ; <nl> - if ( value . isQualifiedName ( ) & & <nl> - nextName . equals ( value . getQualifiedName ( ) ) ) { <nl> - / / If the previous expression evaluates to value of a <nl> - / / qualified name , and that qualified name is used again <nl> - / / shortly , then we can exploit the assign here . <nl> - <nl> - / / Verify the assignment doesn ' t change its own value . <nl> - if ( ! isSafeReplacement ( next , assign ) ) { <nl> - return false ; <nl> - } <nl> - <nl> - exprParent . removeChild ( expr ) ; <nl> - expr . removeChild ( assign ) ; <nl> - parent . replaceChild ( next , assign ) ; <nl> - return true ; <nl> - } <nl> } <nl> return false ; <nl> 
0<ml>GenProg-A_Closure-22_P_Patch_24_7.txt<ml>GenProg-A_Closure-22_P_Patch_24_7.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_22 / patches_m6gq / Patch_7 / patched / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) <nl> continue ; <nl> - if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) <nl> - return ; <nl> - else <nl> - break ; <nl> } <nl> } <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> 
0<ml>GenProg-A_Closure-75_P_Patch_128_47.txt<ml>GenProg-A_Closure-75_P_Patch_128_47.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_75 / src / com / google / javascript / rhino / Token . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_75 / patches_mgrb / Patch_47 / patched / com / google / javascript / rhino / Token . java 	 2019 - 08 - 11 <nl> case MOD : return " MOD " ; <nl> case NOT : return " NOT " ; <nl> case BITNOT : return " BITNOT " ; <nl> - case POS : return " POS " ; <nl> + case POS : ; <nl> case NEG : return " NEG " ; <nl> case NEW : return " NEW " ; <nl> case DELPROP : return " DELPROP " ; <nl> mmm  / tmp / GenProg_Defects4J_Closure_75 / src / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_75 / patches_mgrb / Patch_47 / patched / com / google / javascript / jscomp / NodeUtil . java 	 2019 - 08 - 11 <nl> static TernaryValue isStrWhiteSpaceChar ( int c ) { <nl> switch ( c ) { <nl> case ' \ u000B ' : / / < VT > <nl> - return TernaryValue . TRUE ; <nl> + ; <nl> case ' ' : / / < SP > <nl> case ' \ n ' : / / < LF > <nl> case ' \ r ' : / / < CR > <nl> mmm  / tmp / GenProg_Defects4J_Closure_75 / src / com / google / javascript / jscomp / PeepholeFoldConstants . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_75 / patches_mgrb / Patch_47 / patched / com / google / javascript / jscomp / PeepholeFoldConstants . java 	 2019 - 08 - 11 <nl> } else { <nl> replacement = Node . newNumber ( value ) ; <nl> } <nl> - <nl> - n . getParent ( ) . replaceChild ( n , replacement ) ; <nl> - reportCodeChange ( ) ; <nl> } <nl> / * * <nl> 
0<ml>GenProg-A_Closure-10_P_Patch_2_1.txt<ml>GenProg-A_Closure-10_P_Patch_2_1.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_10 / src / com / google / javascript / jscomp / PeepholeFoldConstants . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_10 / patches_wcjr / Patch_1 / patched / com / google / javascript / jscomp / PeepholeFoldConstants . java 	 2019 - 08 - 11 <nl> tryConvertToNumber ( n . getLastChild ( ) ) ; <nl> return ; <nl> case Token . HOOK : <nl> - tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; <nl> + ; <nl> tryConvertToNumber ( n . getLastChild ( ) ) ; <nl> return ; <nl> case Token . NAME : <nl> Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; <nl> if ( replacement = = null ) { <nl> valueToCombine = lr ; <nl> - replacement = performArithmeticOp ( opType , valueToCombine , right ) ; <nl> + int start = 0 ; <nl> } <nl> if ( replacement ! = null ) { <nl> / / Remove the child that has been combined <nl> 
0<ml>GenProg-A_Closure-112_P_Patch_17_7.txt<ml>GenProg-A_Closure-112_P_Patch_17_7.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_112 / src / com / google / javascript / jscomp / TypeInference . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_112 / patches_gjzb / Patch_7 / patched / com / google / javascript / jscomp / TypeInference . java 	 2019 - 08 - 11 <nl> JSType argType , <nl> Map < TemplateType , JSType > resolvedTypes ) { <nl> if ( paramType . isTemplateType ( ) ) { <nl> - / / @ param { T } <nl> - resolvedTemplateType ( <nl> - resolvedTypes , paramType . toMaybeTemplateType ( ) , argType ) ; <nl> } else if ( paramType . isUnionType ( ) ) { <nl> / / @ param { Array . < T > | NodeList | Arguments | { length : number } } <nl> UnionType unionType = paramType . toMaybeUnionType ( ) ; <nl> 
0<ml>GenProg-A_Math-2_P_Patch_35_11.txt<ml>GenProg-A_Math-2_P_Patch_35_11.txt<ml>mmm  / tmp / GenProg_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2019 - 07 - 29 <nl> ppp  / tmp / GenProg_Defects4J_Math_2 / patches_fwqz / Patch_11 / patched / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java 	 2019 - 07 - 29 <nl> k = 1 . 0 / k ; <nl> tmp = mu + k * sigma ; <nl> if ( tmp < upper ) { <nl> - upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <nl> } <nl> } <nl> mmm  / tmp / GenProg_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / ml / clustering / FuzzyKMeansClusterer . java 	 2019 - 07 - 29 <nl> ppp  / tmp / GenProg_Defects4J_Math_2 / patches_fwqz / Patch_11 / patched / org / apache / commons / math3 / ml / clustering / FuzzyKMeansClusterer . java 	 2019 - 07 - 29 <nl> this . membershipMatrix = null ; <nl> this . points = null ; <nl> - this . clusters = null ; <nl> + boolean emptyCluster = false ; <nl> + this . clusters = null ; <nl> } <nl> / * * <nl> 
0<ml>GenProg-A_Chart-3_P_Patch_1990_733.txt<ml>GenProg-A_Chart-3_P_Patch_1990_733.txt<ml>mmm  / tmp / GenProg_Defects4J_Chart_3 / source / org / jfree / data / time / TimeSeries . java 	 2019 - 07 - 23 <nl> ppp  / tmp / GenProg_Defects4J_Chart_3 / patches_ff3y / Patch_733 / patched / org / jfree / data / time / TimeSeries . java 	 2019 - 07 - 23 <nl> * @ param notify notify listeners ? <nl> * / <nl> public void add ( TimeSeriesDataItem item , boolean notify ) { <nl> - if ( item = = null ) { <nl> - throw new IllegalArgumentException ( " Null ' item ' argument . " ) ; <nl> - } <nl> + updateBoundsForRemovedItem ( item ) ; <nl> item = ( TimeSeriesDataItem ) item . clone ( ) ; <nl> Class c = item . getPeriod ( ) . getClass ( ) ; <nl> if ( this . timePeriodClass = = null ) { <nl> 
0<ml>GenProg-A_Closure-21_P_Patch_61_20.txt<ml>GenProg-A_Closure-21_P_Patch_61_20.txt<ml>mmm  / tmp / GenProg_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> ppp  / tmp / GenProg_Defects4J_Closure_21 / patches_kg96 / Patch_20 / patched / com / google / javascript / jscomp / CheckSideEffects . java 	 2019 - 08 - 11 <nl> if ( isResultUsed ) { <nl> return ; <nl> } <nl> - if ( n = = parent . getLastChild ( ) ) { <nl> - for ( Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = Token . COMMA ) continue ; <nl> - if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> - else break ; <nl> - } <nl> - } <nl> + int start = 0 ; <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { <nl> return ; <nl> 
0<ml>GenProg-A_Chart-12_P_Patch_130_65.txt<ml>GenProg-A_Chart-12_P_Patch_130_65.txt<ml>mmm  / tmp / GenProg_Defects4J_Chart_12 / source / org / jfree / chart / JFreeChart . java 	 2019 - 07 - 23 <nl> ppp  / tmp / GenProg_Defects4J_Chart_12 / patches_d944 / Patch_65 / patched / org / jfree / chart / JFreeChart . java 	 2019 - 07 - 23 <nl> * @ see # getLegend ( ) <nl> * / <nl> public void removeLegend ( ) { <nl> - removeSubtitle ( getLegend ( ) ) ; <nl> } <nl> / * * <nl> * / <nl> public void removeSubtitle ( Title title ) { <nl> this . subtitles . remove ( title ) ; <nl> - fireChartChanged ( ) ; <nl> } <nl> / * * <nl> mmm  / tmp / GenProg_Defects4J_Chart_12 / source / org / jfree / chart / plot / MultiplePiePlot . java 	 2019 - 07 - 23 <nl> ppp  / tmp / GenProg_Defects4J_Chart_12 / patches_d944 / Patch_65 / patched / org / jfree / chart / plot / MultiplePiePlot . java 	 2019 - 07 - 23 <nl> this . pieChart . setBackgroundPaint ( null ) ; <nl> TextTitle seriesTitle = new TextTitle ( " Series Title " , <nl> new Font ( " SansSerif " , Font . BOLD , 12 ) ) ; <nl> - seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; <nl> - this . pieChart . setTitle ( seriesTitle ) ; <nl> + if ( dataset ! = null ) { <nl> + setDatasetGroup ( dataset . getGroup ( ) ) ; <nl> + dataset . addChangeListener ( this ) ; <nl> + } <nl> this . aggregatedItemsKey = " Other " ; <nl> - this . aggregatedItemsPaint = Color . lightGray ; <nl> - this . sectionPaints = new HashMap ( ) ; <nl> + Plot p = getParent ( ) ; <nl> } <nl> / * * <nl> 
0<ml>jKali_Lang-27_P_Patch_59_43.txt<ml>jKali_Lang-27_P_Patch_59_43.txt<ml>mmm  / tmp / jKali_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> ppp  / tmp / jKali_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> } <nl> mant = str . substring ( 0 , decPos ) ; <nl> } else { <nl> - if ( expPos > ( - 1 ) ) { <nl> + if ( false ) { <nl> mant = str . substring ( 0 , expPos ) ; <nl> } else { <nl> mant = str ; <nl> 
0<ml>jKali_Math-71_P_Patch_331_302.txt<ml>jKali_Math-71_P_Patch_331_302.txt<ml>mmm  / tmp / jKali_Defects4J_Math_71 / src / main / java / org / apache / commons / math / ConvergingAlgorithmImpljava <nl> ppp  / tmp / jKali_Defects4J_Math_71 / src / main / java / org / apache / commons / math / ConvergingAlgorithmImpljava <nl> protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final <nl> double defaultAbsoluteAccuracy ) { <nl> this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; <nl> - this . defaultRelativeAccuracy = 1 . 0E - 14 ; <nl> + <nl> this . absoluteAccuracy = defaultAbsoluteAccuracy ; <nl> this . relativeAccuracy = defaultRelativeAccuracy ; <nl> this . defaultMaximalIterationCount = defaultMaximalIterationCount ; <nl> 
1<ml>jKali_Math-50_C_Patch_1_1.txt<ml>jKali_Math-50_C_Patch_1_1.txt<ml>mmm  / tmp / jKali_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava <nl> ppp  / tmp / jKali_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava <nl> break ; <nl> case REGULA_FALSI : <nl> - if ( x = = x1 ) { <nl> - x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; <nl> + if ( x = = x1 ) <nl> + <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> - } <nl> + <nl> break ; <nl> default : <nl> 
0<ml>jKali_Closure-45_P_Patch_5_5.txt<ml>jKali_Closure-45_P_Patch_5_5.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_45 / src / com / google / javascript / jscomp / RemoveUnusedVarsjava <nl> ppp  / tmp / jKali_Defects4J_Closure_45 / src / com / google / javascript / jscomp / RemoveUnusedVarsjava <nl> for ( com . google . javascript . jscomp . RemoveUnusedVars . Assign assign : assignsByVar . get ( var ) ) { <nl> if ( assign . isPropertyAssign ) { <nl> hasPropertyAssign = true ; <nl> - } else { if ( ! ( com . google . javascript . jscomp . NodeUtil . isLiteralValue ( <nl> - assign . assignNode . getLastChild ( ) , true ) ) ) { <nl> + } else { if ( true ) <nl> + { <nl> assignedToUnknownValue = true ; <nl> } } <nl> } <nl> 
1<ml>jKali_Closure-126_C_Patch_7_6.txt<ml>jKali_Closure-126_C_Patch_7_6.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPointsjava <nl> ppp  / tmp / jKali_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPointsjava <nl> - if ( com . google . javascript . jscomp . NodeUtil . hasFinally ( n ) ) { <nl> + if ( false ) { <nl> com . google . javascript . rhino . Node finallyBlock = n . getLastChild ( ) ; <nl> tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> } <nl> 
0<ml>jKali_Chart-13_P_Patch_49_48.txt<ml>jKali_Chart-13_P_Patch_49_48.txt<ml>mmm  / tmp / jKali_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava <nl> ppp  / tmp / jKali_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava <nl> h [ 1 ] = size . height ; <nl> } <nl> h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; <nl> - if ( ( this . leftBlock ) ! = null ) { <nl> + if ( false ) { <nl> org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , <nl> new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , <nl> org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , <nl> 
0<ml>jKali_Chart-25_P_Patch_6_6.txt<ml>jKali_Chart-25_P_Patch_6_6.txt<ml>mmm  / tmp / jKali_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava <nl> ppp  / tmp / jKali_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava <nl> org . jfree . data . statistics . StatisticalCategoryDataset statData = ( ( org . jfree . data . statistics . StatisticalCategoryDataset ) ( data ) ) ; <nl> org . jfree . chart . plot . PlotOrientation orientation = plot . getOrientation ( ) ; <nl> - if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . HORIZONTAL ) ) { <nl> - drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> - rangeAxis , statData , row , column ) ; <nl> - } else <nl> - if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . VERTICAL ) ) { <nl> - drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> - statData , row , column ) ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> } <nl> 
0<ml>jKali_Math-28_P_Patch_5_4.txt<ml>jKali_Math-28_P_Patch_5_4.txt<ml>mmm  / tmp / jKali_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava <nl> ppp  / tmp / jKali_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava <nl> for ( java . lang . Integer row : minRatioPositions ) { <nl> int i = tableau . getNumObjectiveFunctions ( ) ; <nl> for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { <nl> - if ( row = = ( tableau . getBasicRow ( i ) ) ) { <nl> + if ( true ) { <nl> if ( i < minIndex ) { <nl> minIndex = i ; <nl> minRow = row ; <nl> 
0<ml>jKali_Math-49_P_Patch_22_16.txt<ml>jKali_Math-49_P_Patch_22_16.txt<ml>mmm  / tmp / jKali_Defects4J_Math_49 / src / main / java / org / apache / commons / math / linear / OpenMapRealVectorjava <nl> ppp  / tmp / jKali_Defects4J_Math_49 / src / main / java / org / apache / commons / math / linear / OpenMapRealVectorjava <nl> public void setEntry ( int index , double value ) { <nl> checkIndex ( index ) ; <nl> - if ( ! ( isDefaultValue ( value ) ) ) { <nl> - entries . put ( index , value ) ; <nl> - } else if ( entries . containsKey ( index ) ) { <nl> - entries . remove ( index ) ; <nl> + if ( true ) { <nl> + this . entries . put ( index , value ) ; <nl> + } else if ( this . entries . containsKey ( index ) ) { <nl> + this . entries . remove ( index ) ; <nl> } <nl> } <nl> 
0<ml>jKali_Closure-46_P_Patch_5_5.txt<ml>jKali_Closure-46_P_Patch_5_5.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordTypejava <nl> ppp  / tmp / jKali_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordTypejava <nl> @ java . lang . Override <nl> public com . google . javascript . rhino . jstype . JSType getLeastSupertype ( com . google . javascript . rhino . jstype . JSType that ) { <nl> - if ( ! ( that . isRecordType ( ) ) ) { <nl> + if ( true ) { <nl> return super . getLeastSupertype ( that ) ; <nl> } <nl> com . google . javascript . rhino . jstype . RecordTypeBuilder builder = new com . google . javascript . rhino . jstype . RecordTypeBuilder ( registry ) ; <nl> 
0<ml>jKali_Chart-1_P_Patch_36_35.txt<ml>jKali_Chart-1_P_Patch_36_35.txt<ml>mmm  / tmp / jKali_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRendererjava <nl> ppp  / tmp / jKali_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRendererjava <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> + if ( false ) { <nl> return result ; <nl> } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> 
0<ml>jKali_Closure-63_P_Patch_3_3.txt<ml>jKali_Closure-63_P_Patch_3_3.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> ppp  / tmp / jKali_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> - if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> - ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { <nl> + if ( true ) <nl> + { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( java . lang . Character . isWhitespace ( c ) ) { <nl> 
0<ml>jKali_Chart-5_P_Patch_3_3.txt<ml>jKali_Chart-5_P_Patch_3_3.txt<ml>mmm  / tmp / jKali_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava <nl> ppp  / tmp / jKali_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava <nl> - if ( this . autoSort ) { <nl> + if ( false ) { <nl> this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <nl> } else <nl> { <nl> 
0<ml>jKali_Math-32_P_Patch_2_2.txt<ml>jKali_Math-32_P_Patch_2_2.txt<ml>mmm  / tmp / jKali_Defects4J_Math_32 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSetjava <nl> ppp  / tmp / jKali_Defects4J_Math_32 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSetjava <nl> if ( ( v . length ) = = 0 ) { <nl> final org . apache . commons . math3 . geometry . partitioning . BSPTree < org . apache . commons . math3 . geometry . euclidean . twod . Euclidean2D > tree = getTree ( false ) ; <nl> - if ( ( ( java . lang . Boolean ) ( tree . getAttribute ( ) ) ) ) { <nl> + if ( false ) { <nl> setSize ( java . lang . Double . POSITIVE_INFINITY ) ; <nl> setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; <nl> 
0<ml>jKali_Math-80_P_Patch_14_14.txt<ml>jKali_Math-80_P_Patch_14_14.txt<ml>mmm  / tmp / jKali_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> ppp  / tmp / jKali_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> if ( ( 1 . 5 * ( work [ pingPong ] ) ) < ( work [ ( ( 4 * ( n - 1 ) ) + ( pingPong ) ) ] ) ) { <nl> int j = ( 4 * n ) - 1 ; <nl> - for ( int i = 0 ; i < j ; i + = 4 ) { <nl> - for ( int k = 0 ; k < 4 ; k + = step ) { <nl> - final double tmp = work [ ( i + k ) ] ; <nl> - work [ ( i + k ) ] = work [ ( j - k ) ] ; <nl> - work [ ( j - k ) ] = tmp ; <nl> - } <nl> - j - = 4 ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> return true ; <nl> } <nl> return false ; <nl> 
1<ml>jKali_Lang-7_C_Patch_18_17.txt<ml>jKali_Lang-7_C_Patch_18_17.txt<ml>mmm  / tmp / jKali_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> ppp  / tmp / jKali_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> throw new java . lang . NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> if ( str . startsWith ( " - - " ) ) { <nl> - return null ; <nl> + <nl> } <nl> if ( ( ( ( str . startsWith ( " 0x " ) ) | | ( str . startsWith ( " - 0x " ) ) ) | | ( str . startsWith ( " 0X " ) ) ) | | ( str . startsWith ( " - 0X " ) ) ) { <nl> int hexDigits = ( str . length ( ) ) - 2 ; <nl> 
0<ml>jKali_Math-29_P_Patch_92_84.txt<ml>jKali_Math-29_P_Patch_92_84.txt<ml>mmm  / tmp / jKali_Defects4J_Math_29 / src / main / java / org / apache / commons / math3 / linear / OpenMapRealVectorjava <nl> ppp  / tmp / jKali_Defects4J_Math_29 / src / main / java / org / apache / commons / math3 / linear / OpenMapRealVectorjava <nl> this . epsilon = epsilon ; <nl> for ( int key = 0 ; key < ( values . length ) ; key + + ) { <nl> double value = values [ key ] ; <nl> - if ( ! ( isDefaultValue ( value ) ) ) { <nl> - entries . put ( key , value ) ; <nl> + if ( true ) { <nl> + this . entries . put ( key , value ) ; <nl> } <nl> } <nl> } <nl> 
0<ml>jKali_Closure-62_P_Patch_3_3.txt<ml>jKali_Closure-62_P_Patch_3_3.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> ppp  / tmp / jKali_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> - if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> - ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { <nl> + if ( true ) <nl> + { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( java . lang . Character . isWhitespace ( c ) ) { <nl> 
0<ml>jKali_Closure-101_P_Patch_49_45.txt<ml>jKali_Closure-101_P_Patch_49_45.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_101 / src / com / google / javascript / jscomp / CompilationLeveljava <nl> ppp  / tmp / jKali_Defects4J_Closure_101 / src / com / google / javascript / jscomp / CompilationLeveljava <nl> private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) { <nl> - options . closurePass = true ; <nl> + <nl> options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; <nl> options . inlineLocalVariables = true ; <nl> options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ; <nl> 
0<ml>jKali_Closure-22_P_Patch_14_14.txt<ml>jKali_Closure-22_P_Patch_14_14.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> ppp  / tmp / jKali_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) <nl> continue ; <nl> - if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) <nl> - return ; else <nl> - break ; <nl> + <nl> + <nl> + <nl> } <nl> } <nl> } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { <nl> 
1<ml>jKali_Lang-10_C_Patch_83_81.txt<ml>jKali_Lang-10_C_Patch_83_81.txt<ml>mmm  / tmp / jKali_Defects4J_Lang_10 / src / main / java / org / apache / commons / lang3 / time / FastDateParserjava <nl> ppp  / tmp / jKali_Defects4J_Lang_10 / src / main / java / org / apache / commons / lang3 / time / FastDateParserjava <nl> boolean wasWhite = false ; <nl> for ( int i = 0 ; i < ( value . length ( ) ) ; + + i ) { <nl> char c = value . charAt ( i ) ; <nl> - if ( java . lang . Character . isWhitespace ( c ) ) { <nl> + if ( false ) { <nl> if ( ! wasWhite ) { <nl> wasWhite = true ; <nl> regex . append ( " \ \ s * + " ) ; <nl> 
0<ml>jKali_Lang-22_P_Patch_50_50.txt<ml>jKali_Lang-22_P_Patch_50_50.txt<ml>mmm  / tmp / jKali_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava <nl> ppp  / tmp / jKali_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava <nl> private static int greatestCommonDivisor ( int u , int v ) { <nl> - if ( ( ( java . lang . Math . abs ( u ) ) < = 1 ) | | ( ( java . lang . Math . abs ( v ) ) < = 1 ) ) { <nl> + if ( false ) { <nl> return 1 ; <nl> } <nl> 
0<ml>jKali_Math-8_P_Patch_5_4.txt<ml>jKali_Math-8_P_Patch_5_4.txt<ml>mmm  / tmp / jKali_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava <nl> ppp  / tmp / jKali_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava <nl> final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; <nl> - for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> - out [ i ] = sample ( ) ; <nl> - } <nl> + <nl> + <nl> + <nl> return out ; <nl> 
0<ml>jKali_Math-2_P_Patch_23_18.txt<ml>jKali_Math-2_P_Patch_23_18.txt<ml>mmm  / tmp / jKali_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava <nl> ppp  / tmp / jKali_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava <nl> } <nl> k = 1 . 0 / k ; <nl> tmp = mu + ( k * sigma ) ; <nl> - if ( tmp < upper ) { <nl> + if ( false ) { <nl> upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; <nl> } <nl> } <nl> 
0<ml>jKali_Closure-21_P_Patch_2_2.txt<ml>jKali_Closure-21_P_Patch_2_2.txt<ml>mmm  / tmp / jKali_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> ppp  / tmp / jKali_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> return ; <nl> } <nl> if ( n = = ( parent . getLastChild ( ) ) ) { <nl> - for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { <nl> - int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; <nl> - if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else <nl> - break ; <nl> - } <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> } <nl> } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { <nl> if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) { <nl> 
0<ml>SimFix_Lang-1_P_Patch_164_164.txt<ml>SimFix_Lang-1_P_Patch_164_164.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> } <nl> if ( pfxLen > 0 ) { / / we have a hex number <nl> final int hexDigits = str . length ( ) - pfxLen ; <nl> + / / start of generated patch <nl> + if ( hexDigits > 16 ) { <nl> + try { <nl> + return createLong ( str ) ; <nl> + } catch ( final NumberFormatException nfe ) { <nl> + } <nl> + <nl> + return createBigInteger ( str ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( hexDigits > 16 ) { / / too many for Long <nl> return createBigInteger ( str ) ; <nl> } <nl> + end of original code * / <nl> if ( hexDigits > 8 ) { / / too many for an int <nl> return createLong ( str ) ; <nl> } <nl> 
0<ml>SimFix_Math-82_P_Patch_2356_2356.txt<ml>SimFix_Math-82_P_Patch_2356_2356.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> double minValue = 0 ; <nl> Integer minPos = null ; <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { <nl> + / / start of generated patch <nl> + if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { <nl> + minValue = tableau . getEntry ( 0 , i ) ; <nl> + minPos = i ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { <nl> minValue = tableau . getEntry ( 0 , i ) ; <nl> minPos = i ; <nl> } <nl> + end of original code * / <nl> } <nl> return minPos ; <nl> } <nl> 
0<ml>SimFix_Math-88_P_Patch_4565_4565.txt<ml>SimFix_Math-88_P_Patch_4565_4565.txt<ml>mmm a / src / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; <nl> if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { <nl> double ratio = rhs / tableau . getEntry ( i , col ) ; <nl> + / / start of generated patch <nl> + if ( ratio < = minRatio ) { <nl> + minRatio = ratio ; <nl> + minRatioPos = i ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( ratio < minRatio ) { <nl> minRatio = ratio ; <nl> minRatioPos = i ; <nl> } <nl> + end of original code * / <nl> } <nl> } <nl> return minRatioPos ; <nl> 
0<ml>SimFix_Lang-27_P_Patch_91_91.txt<ml>SimFix_Lang-27_P_Patch_91_91.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> / / a wrong value . <nl> return null ; <nl> } <nl> + / / start of generated patch <nl> + str = str . toLowerCase ( ) ; <nl> + if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) ) { <nl> + return createInteger ( str ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) ) { <nl> return createInteger ( str ) ; <nl> } <nl> + end of original code * / <nl> char lastChar = str . charAt ( str . length ( ) - 1 ) ; <nl> String mant ; <nl> String dec ; <nl> 
0<ml>SimFix_Chart-22_P_Patch_1504_1504.txt<ml>SimFix_Chart-22_P_Patch_1504_1504.txt<ml>mmm a / source / org / jfree / data / KeyedObjects2D . java <nl> ppp b / source / org / jfree / data / KeyedObjects2D . java <nl> throw new UnknownKeyException ( " Column key ( " + columnKey <nl> + " ) not recognised . " ) ; <nl> } <nl> + / / start of generated patch <nl> + if ( row > = column ) { <nl> + KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; <nl> + return rowData . getObject ( columnKey ) ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( row > = 0 ) { <nl> KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; <nl> return rowData . getObject ( columnKey ) ; <nl> else { <nl> return null ; <nl> } <nl> + end of original code * / <nl> } <nl> / * * <nl> * @ see # removeColumn ( Comparable ) <nl> * / <nl> public void removeRow ( Comparable rowKey ) { <nl> + / / start of generated patch <nl> + int index = getRowIndex ( rowKey ) ; <nl> + if ( index < 0 ) { <nl> + throw new UnknownKeyException ( " The key ( " + rowKey . toString ( ) ) ; <nl> + } <nl> + removeRow ( index ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> int index = getRowIndex ( rowKey ) ; <nl> removeRow ( index ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> * @ see # removeRow ( Comparable ) <nl> * / <nl> public void removeColumn ( Comparable columnKey ) { <nl> + / / start of generated patch <nl> + int index = getColumnIndex ( columnKey ) ; <nl> + if ( index < 0 ) { <nl> + throw new UnknownKeyException ( " Column key ( " + columnKey ) ; <nl> + } <nl> + Iterator iterator = this . rows . iterator ( ) ; <nl> + while ( iterator . hasNext ( ) ) { <nl> + KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; <nl> + this . rows . remove ( index ) ; <nl> + rowData . removeValue ( columnKey ) ; <nl> + } <nl> + this . columnKeys . remove ( columnKey ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> int index = getColumnIndex ( columnKey ) ; <nl> if ( index < 0 ) { <nl> throw new UnknownKeyException ( " Column key ( " + columnKey <nl> rowData . removeValue ( columnKey ) ; <nl> } <nl> this . columnKeys . remove ( columnKey ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
0<ml>SimFix_Math-44_P_Patch_4783_4783.txt<ml>SimFix_Math-44_P_Patch_4783_4783.txt<ml>mmm a / src / main / java / org / apache / commons / math / ode / events / EventState . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / events / EventState . java <nl> public boolean evaluateStep ( final StepInterpolator interpolator ) <nl> throws ConvergenceException { <nl> + / / start of generated patch <nl> + forward = interpolator . isForward ( ) ; <nl> + t0 = interpolator . getPreviousTime ( ) ; <nl> + final double t1 = interpolator . getCurrentTime ( ) ; <nl> + final double dt = t1 - t0 ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> forward = interpolator . isForward ( ) ; <nl> final double t1 = interpolator . getCurrentTime ( ) ; <nl> final double dt = t1 - t0 ; <nl> + end of original code * / <nl> if ( FastMath . abs ( dt ) < convergence ) { <nl> / / we cannot do anything on such a small step , don ' t trigger any events <nl> return false ; <nl> 
0<ml>SimFix_Lang-63_P_Patch_45_45.txt<ml>SimFix_Lang-63_P_Patch_45_45.txt<ml>mmm a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> end . add ( field , - 1 * difference ) ; <nl> int endValue = end . get ( field ) ; <nl> int startValue = start . get ( field ) ; <nl> + / / start of generated patch <nl> + if ( endValue < field ) { <nl> + int newdiff = startValue - endValue ; <nl> + end . add ( field , newdiff ) ; <nl> + return newdiff ; <nl> + } else { <nl> + return 0 ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( endValue < startValue ) { <nl> int newdiff = startValue - endValue ; <nl> end . add ( field , newdiff ) ; <nl> } else { <nl> return 0 ; <nl> } <nl> + end of original code * / <nl> } <nl> static final Object y = " y " ; <nl> 
1<ml>SimFix_Lang-39_C_Patch_2275_2275.txt<ml>SimFix_Lang-39_C_Patch_2275_2275.txt<ml>mmm a / src / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / java / org / apache / commons / lang3 / StringUtils . java <nl> int increase = 0 ; <nl> / / count the replacement text elements that are larger than their corresponding text being replaced <nl> + / / start of generated patch <nl> + for ( int i = 0 ; i < searchList . length ; i + + ) { <nl> + if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { <nl> + continue ; <nl> + } <nl> + int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> + if ( greater > 0 ) { <nl> + increase + = 3 * greater ; <nl> + } <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int i = 0 ; i < searchList . length ; i + + ) { <nl> int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> if ( greater > 0 ) { <nl> increase + = 3 * greater ; / / assume 3 matches <nl> } <nl> } <nl> + end of original code * / <nl> / / have upper - bound at 20 % increase , then let Java take over <nl> increase = Math . min ( increase , text . length ( ) / 5 ) ; <nl> 
1<ml>SimFix_Math-75_C_Patch_8_8.txt<ml>SimFix_Math-75_C_Patch_8_8.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / Frequency . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / Frequency . java <nl> * / <nl> @ Deprecated <nl> public double getPct ( Object v ) { <nl> + / / start of generated patch <nl> + return getPct ( ( Comparable < ? > ) v ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> return getCumPct ( ( Comparable < ? > ) v ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
1<ml>SimFix_Lang-58_C_Patch_1138_1138.txt<ml>SimFix_Lang-58_C_Patch_1138_1138.txt<ml>mmm a / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> switch ( lastChar ) { <nl> case ' l ' : <nl> case ' L ' : <nl> + / / start of generated patch <nl> + if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> + try { <nl> + return createLong ( numeric ) ; <nl> + } catch ( NumberFormatException nfe ) { <nl> + } <nl> + <nl> + return createBigInteger ( numeric ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( dec = = null <nl> & & exp = = null <nl> & & isDigits ( numeric . substring ( 1 ) ) <nl> return createBigInteger ( numeric ) ; <nl> } <nl> + end of original code * / <nl> throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> case ' f ' : <nl> case ' F ' : <nl> 
1<ml>SimFix_Lang-33_C_Patch_43_43.txt<ml>SimFix_Lang-33_C_Patch_43_43.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / ClassUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / ClassUtils . java <nl> return ArrayUtils . EMPTY_CLASS_ARRAY ; <nl> } <nl> Class < ? > [ ] classes = new Class [ array . length ] ; <nl> + / / start of generated patch <nl> + for ( int i = 0 ; i < array . length ; i + + ) { <nl> + classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int i = 0 ; i < array . length ; i + + ) { <nl> classes [ i ] = array [ i ] . getClass ( ) ; <nl> } <nl> + end of original code * / <nl> return classes ; <nl> } <nl> 
0<ml>SimFix_Closure-109_P_Patch_6_6.txt<ml>SimFix_Closure-109_P_Patch_6_6.txt<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> * TypeApplication : = ' . < ' TypeExpressionList ' > ' <nl> * / <nl> private Node parseTypeName ( JsDocToken token ) { <nl> + / / start of generated patch <nl> + if ( token = = null ) { <nl> + return reportGenericTypeSyntaxWarning ( ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( token ! = JsDocToken . STRING ) { <nl> return reportGenericTypeSyntaxWarning ( ) ; <nl> } <nl> + end of original code * / <nl> String typeName = stream . getString ( ) ; <nl> int lineno = stream . getLineno ( ) ; <nl> 
0<ml>SimFix_Closure-126_P_Patch_32_32.txt<ml>SimFix_Closure-126_P_Patch_32_32.txt<ml>mmm a / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> ppp b / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> * can cause problems if it changes the completion type of the finally <nl> * block . See ECMA 262 Sections 8 . 9 & 12 . 14 <nl> * / <nl> + / / start of generated patch <nl> + if ( ! n . isName ( ) ) { <nl> + return ; <nl> + } <nl> + if ( NodeUtil . hasFinally ( n ) ) { <nl> + Node finallyBlock = n . getLastChild ( ) ; <nl> + tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( NodeUtil . hasFinally ( n ) ) { <nl> Node finallyBlock = n . getLastChild ( ) ; <nl> tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> } <nl> + end of original code * / <nl> } <nl> / / Just a ' label ' . <nl> 
0<ml>SimFix_Lang-12_P_Patch_128_128.txt<ml>SimFix_Lang-12_P_Patch_128_128.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / RandomStringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / RandomStringUtils . java <nl> throw new IllegalArgumentException ( " Requested random string length " + count + " is less than 0 . " ) ; <nl> } <nl> + / / start of generated patch <nl> + if ( chars = = null & & end = = 0 ) { <nl> + if ( ! letters & & ! numbers ) { <nl> + end = Integer . MAX_VALUE ; <nl> + } else { <nl> + end = ' z ' + 1 ; <nl> + start = ' ' ; <nl> + } <nl> + } <nl> + char [ ] buffer = new char [ count ] ; <nl> + int gap = end - start ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( start = = 0 & & end = = 0 ) { <nl> if ( ! letters & & ! numbers ) { <nl> end = Integer . MAX_VALUE ; <nl> char [ ] buffer = new char [ count ] ; <nl> int gap = end - start ; <nl> + end of original code * / <nl> while ( count - - ! = 0 ) { <nl> char ch ; <nl> 
0<ml>SimFix_Math-50_P_Patch_18_18.txt<ml>SimFix_Math-50_P_Patch_18_18.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> break ; <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> + / / start of generated patch <nl> + if ( x = = x0 ) { <nl> + x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + f0 = computeObjectiveValue ( x0 ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( x = = x1 ) { <nl> x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> + end of original code * / <nl> break ; <nl> default : <nl> / / Should never happen . <nl> 
0<ml>SimFix_Lang-16_P_Patch_2548_2548.txt<ml>SimFix_Lang-16_P_Patch_2548_2548.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> if ( str = = null ) { <nl> return null ; <nl> } <nl> + / / start of generated patch <nl> + str = str . toLowerCase ( ) ; <nl> + if ( StringUtils . isBlank ( str ) ) { <nl> + throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( StringUtils . isBlank ( str ) ) { <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> + end of original code * / <nl> if ( str . startsWith ( " - - " ) ) { <nl> / / this is protection for poorness in java . lang . BigDecimal . <nl> / / it accepts this as a legal value , but it does not appear <nl> 
1<ml>SimFix_Math-71_C_Patch_899_899.txt<ml>SimFix_Math-71_C_Patch_899_899.txt<ml>mmm a / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> interpolator . storeTime ( stepStart + stepSize ) ; <nl> if ( manager . evaluateStep ( interpolator ) ) { <nl> final double dt = manager . getEventTime ( ) - stepStart ; <nl> + / / start of generated patch <nl> + if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { <nl> + interpolator . storeTime ( stepStart ) ; <nl> + System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; <nl> + hNew = 0 ; <nl> + stepSize = 0 ; <nl> + <nl> + loop = false ; <nl> + } else { <nl> + hNew = dt ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { <nl> / / we cannot simply truncate the step , reject the current computation <nl> / / and let the loop compute another state with the truncated step . <nl> / / reject the step to match exactly the next switch time <nl> hNew = dt ; <nl> } <nl> + end of original code * / <nl> } else { <nl> / / accept the step <nl> loop = false ; <nl> mmm a / src / main / java / org / apache / commons / math / ode / nonstiff / RungeKuttaIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / RungeKuttaIntegrator . java <nl> interpolator . storeTime ( stepStart + stepSize ) ; <nl> if ( manager . evaluateStep ( interpolator ) ) { <nl> final double dt = manager . getEventTime ( ) - stepStart ; <nl> + / / start of generated patch <nl> + if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { <nl> + System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; <nl> + stepSize = 0 ; <nl> + loop = false ; <nl> + } else { <nl> + stepSize = dt ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { <nl> / / we cannot simply truncate the step , reject the current computation <nl> / / and let the loop compute another state with the truncated step . <nl> / / reject the step to match exactly the next switch time <nl> stepSize = dt ; <nl> } <nl> + end of original code * / <nl> } else { <nl> loop = false ; <nl> } <nl> 
0<ml>SimFix_Closure-107_P_Patch_1263_1263.txt<ml>SimFix_Closure-107_P_Patch_1263_1263.txt<ml>mmm a / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> ppp b / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> } catch ( IOException e ) { <nl> throw new RuntimeException ( " Reading XTB file " , e ) ; <nl> } <nl> + } else / / start of generated patch <nl> + if ( options . messageBundle ! = null ) { <nl> + options . messageBundle = new EmptyMessageBundle ( ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { <nl> / / In SIMPLE or WHITESPACE mode , if the user hasn ' t specified a <nl> / / translations file , they might reasonably try to write their own <nl> / / because the user didn ' t really ask for i18n . <nl> options . messageBundle = new EmptyMessageBundle ( ) ; <nl> } <nl> + end of original code * / <nl> return options ; <nl> } <nl> 
0<ml>SimFix_Chart-25_P_Patch_1_1.txt<ml>SimFix_Chart-25_P_Patch_1_1.txt<ml>mmm a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; <nl> PlotOrientation orientation = plot . getOrientation ( ) ; <nl> + / / start of generated patch <nl> + if ( orientation = = PlotOrientation . VERTICAL ) { <nl> + drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; <nl> + } else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> + drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( orientation = = PlotOrientation . HORIZONTAL ) { <nl> drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , <nl> rangeAxis , statData , row , column ) ; <nl> } <nl> else if ( orientation = = PlotOrientation . VERTICAL ) { <nl> drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , <nl> statData , row , column ) ; <nl> } <nl> + end of original code * / <nl> } <nl> / * * <nl> 
0<ml>SimFix_Lang-41_P_Patch_8416_8416.txt<ml>SimFix_Lang-41_P_Patch_8416_8416.txt<ml>mmm a / src / java / org / apache / commons / lang / ClassUtils . java <nl> ppp b / src / java / org / apache / commons / lang / ClassUtils . java <nl> * @ return the class name without the package name or an empty string <nl> * / <nl> public static String getShortClassName ( Class < ? > cls ) { <nl> + / / start of generated patch <nl> + if ( cls = = null ) { <nl> + return StringUtils . EMPTY ; <nl> + } <nl> + return getShortCanonicalName ( cls . getName ( ) ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( cls = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> return getShortClassName ( cls . getName ( ) ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> * @ return the package name or an empty string <nl> * / <nl> public static String getPackageName ( Class < ? > cls ) { <nl> + / / start of generated patch <nl> + if ( cls = = null ) { <nl> + return StringUtils . EMPTY ; <nl> + } <nl> + return getPackageCanonicalName ( cls . getName ( ) ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( cls = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> return getPackageName ( cls . getName ( ) ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
0<ml>SimFix_Math-81_P_Patch_642_642.txt<ml>SimFix_Math-81_P_Patch_642_642.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> / / compute contribution to norm squared from i > nn - 2 . <nl> final int np = nn - 2 * pingPong ; <nl> double b1 = work [ np - 2 ] ; <nl> + / / start of generated patch <nl> + double b2 = work [ np - 6 ] ; <nl> + final double gam = dN2 ; <nl> + if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { <nl> + return ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> double b2 = work [ np - 6 ] ; <nl> final double gam = dN2 ; <nl> if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { <nl> return ; <nl> } <nl> + end of original code * / <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> / / approximate contribution to norm squared from i < nn - 2 . <nl> 
1<ml>SimFix_Closure-73_C_Patch_1_1.txt<ml>SimFix_Closure-73_C_Patch_1_1.txt<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> / / No charsetEncoder provided - pass straight latin characters <nl> / / through , and escape the rest . Doing the explicit character <nl> / / check is measurably faster than using the CharsetEncoder . <nl> + / / start of generated patch <nl> + if ( c > 0x1f & & c < 0x7f ) { <nl> + sb . append ( c ) ; <nl> + } else { <nl> + appendHexJavaScriptRepresentation ( sb , c ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( c > 0x1f & & c < = 0x7f ) { <nl> sb . append ( c ) ; <nl> } else { <nl> / / so we play it safe and unicode escape them . <nl> appendHexJavaScriptRepresentation ( sb , c ) ; <nl> } <nl> + end of original code * / <nl> } <nl> } <nl> } <nl> 
0<ml>SimFix_Math-43_P_Patch_17_17.txt<ml>SimFix_Math-43_P_Patch_17_17.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> * @ since 1 . 2 <nl> * / <nl> public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { <nl> + / / start of generated patch <nl> + this . sumImpl = geoMeanImpl ; <nl> + checkEmpty ( ) ; <nl> + this . geoMeanImpl = geoMeanImpl ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> checkEmpty ( ) ; <nl> this . geoMeanImpl = geoMeanImpl ; <nl> + end of original code * / <nl> } <nl> / * * <nl> * @ since 1 . 2 <nl> * / <nl> public void setVarianceImpl ( StorelessUnivariateStatistic varianceImpl ) { <nl> + / / start of generated patch <nl> + this . sumImpl = varianceImpl ; <nl> + checkEmpty ( ) ; <nl> + this . varianceImpl = varianceImpl ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> checkEmpty ( ) ; <nl> this . varianceImpl = varianceImpl ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
1<ml>SimFix_Lang-60_C_Patch_1290_1290.txt<ml>SimFix_Lang-60_C_Patch_1290_1290.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> * / <nl> public boolean contains ( char ch ) { <nl> char [ ] thisBuf = buffer ; <nl> + / / start of generated patch <nl> + for ( int i = 0 ; i < size ; i + + ) { <nl> + if ( thisBuf [ i ] = = ch ) { <nl> + return true ; <nl> + } <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int i = 0 ; i < thisBuf . length ; i + + ) { <nl> if ( thisBuf [ i ] = = ch ) { <nl> return true ; <nl> } <nl> } <nl> + end of original code * / <nl> return false ; <nl> } <nl> 
0<ml>SimFix_Lang-45_P_Patch_855_855.txt<ml>SimFix_Lang-45_P_Patch_855_855.txt<ml>mmm a / src / java / org / apache / commons / lang / WordUtils . java <nl> ppp b / src / java / org / apache / commons / lang / WordUtils . java <nl> upper = str . length ( ) ; <nl> } <nl> / / if upper is less than lower , raise it to lower <nl> + / / start of generated patch <nl> + if ( ( lower + ( upper - 3 ) ) < lower ) { <nl> + upper = lower ; <nl> + } <nl> + StringBuffer result = new StringBuffer ( ) ; <nl> + int index = StringUtils . indexOf ( str , " " , lower ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( upper < lower ) { <nl> upper = lower ; <nl> } <nl> StringBuffer result = new StringBuffer ( ) ; <nl> int index = StringUtils . indexOf ( str , " " , lower ) ; <nl> + end of original code * / <nl> if ( index = = - 1 ) { <nl> result . append ( str . substring ( 0 , upper ) ) ; <nl> / / only if abbreviation has occured do we append the appendToEnd value <nl> 
0<ml>SimFix_Math-85_P_Patch_5_5.txt<ml>SimFix_Math-85_P_Patch_5_5.txt<ml>mmm a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> ppp b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> + / / start of generated patch <nl> + if ( fa * upperBound > = 0 . 0 ) { <nl> + throw new ConvergenceException ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( fa * fb > = 0 . 0 ) { <nl> throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> numIterations , maximumIterations , initial , <nl> lowerBound , upperBound , a , b , fa , fb ) ; <nl> } <nl> + end of original code * / <nl> return new double [ ] { a , b } ; <nl> } <nl> 
1<ml>SimFix_Math-53_C_Patch_2_2.txt<ml>SimFix_Math-53_C_Patch_2_2.txt<ml>mmm a / src / main / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math / complex / Complex . java <nl> * / <nl> public Complex add ( Complex rhs ) <nl> throws NullArgumentException { <nl> + / / start of generated patch <nl> + MathUtils . checkNotNull ( rhs ) ; <nl> + if ( isNaN | | rhs . isNaN ) { <nl> + return NaN ; <nl> + } <nl> + return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> MathUtils . checkNotNull ( rhs ) ; <nl> return createComplex ( real + rhs . getReal ( ) , <nl> imaginary + rhs . getImaginary ( ) ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
0<ml>SimFix_Closure-46_P_Patch_21_21.txt<ml>SimFix_Closure-46_P_Patch_21_21.txt<ml>mmm a / src / com / google / javascript / rhino / jstype / RecordType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / RecordType . java <nl> @ Override <nl> public JSType getLeastSupertype ( JSType that ) { <nl> + / / start of generated patch <nl> + if ( ! that . isRecordType ( ) ) { <nl> + return super . getLeastSupertype ( that ) ; <nl> + } <nl> + RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; <nl> + for ( String property : properties . keySet ( ) ) { <nl> + if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { <nl> + builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; <nl> + } <nl> + } <nl> + return getLeastSupertype ( this , that ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( ! that . isRecordType ( ) ) { <nl> return super . getLeastSupertype ( that ) ; <nl> } <nl> } <nl> } <nl> return builder . build ( ) ; <nl> + end of original code * / <nl> } <nl> JSType getGreatestSubtypeHelper ( JSType that ) { <nl> if ( that . isRecordType ( ) ) { <nl> 
1<ml>SimFix_Math-59_C_Patch_9_9.txt<ml>SimFix_Math-59_C_Patch_9_9.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math / util / FastMath . java <nl> * For x between 0 and 1 , returns exp ( x ) , uses extended precision <nl> * @ param x argument of exponential <nl> * @ param result placeholder where to place exp ( x ) split in two terms <nl> - * for extra precision ( i . e . exp ( x ) = result [ 0 ] ° result [ 1 ] <nl> + * for extra precision ( i . e . exp ( x ) = result [ 0 ] ? ? result [ 1 ] <nl> * @ return exp ( x ) <nl> * / <nl> private static double slowexp ( final double x , final double result [ ] ) { <nl> * @ return b if a is lesser or equal to b , a otherwise <nl> * / <nl> public static float max ( final float a , final float b ) { <nl> + / / start of generated patch <nl> + return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; <nl> + end of original code * / <nl> } <nl> / * * Compute the maximum of two values <nl> 
0<ml>SimFix_Closure-6_P_Patch_1874_1874.txt<ml>SimFix_Closure-6_P_Patch_1874_1874.txt<ml>mmm a / src / com / google / javascript / jscomp / TypeValidator . java <nl> ppp b / src / com / google / javascript / jscomp / TypeValidator . java <nl> boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , <nl> JSType leftType , String msg ) { <nl> if ( ! rightType . canAssignTo ( leftType ) ) { <nl> + / / start of generated patch <nl> + if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { <nl> + registerMismatch ( rightType , leftType , null ) ; <nl> + } else { <nl> + mismatch ( t , n , msg , rightType , leftType ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { <nl> registerMismatch ( rightType , leftType , null ) ; <nl> } else { <nl> mismatch ( t , n , msg , rightType , leftType ) ; <nl> } <nl> + end of original code * / <nl> return false ; <nl> } <nl> return true ; <nl> 
1<ml>SimFix_Chart-1_C_Patch_914_914.txt<ml>SimFix_Chart-1_C_Patch_914_914.txt<ml>mmm a / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java <nl> if ( this . plot = = null ) { <nl> return result ; <nl> } <nl> + / / start of generated patch <nl> + int index = this . plot . getIndexOf ( this ) ; <nl> + CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> + if ( dataset = = null ) { <nl> + return result ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> int index = this . plot . getIndexOf ( this ) ; <nl> CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> if ( dataset ! = null ) { <nl> return result ; <nl> } <nl> + end of original code * / <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { <nl> for ( int i = 0 ; i < seriesCount ; i + + ) { <nl> 
1<ml>SimFix_Math-72_C_Patch_2_2.txt<ml>SimFix_Math-72_C_Patch_2_2.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> / / return the first endpoint if it is good enough <nl> double yMin = f . value ( min ) ; <nl> + / / start of generated patch <nl> + if ( Math . abs ( yMin ) < = functionValueAccuracy ) { <nl> + setResult ( min , 0 ) ; <nl> + return result ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( Math . abs ( yMin ) < = functionValueAccuracy ) { <nl> setResult ( yMin , 0 ) ; <nl> return result ; <nl> } <nl> + end of original code * / <nl> / / reduce interval if min and initial bracket the root <nl> if ( yInitial * yMin < 0 ) { <nl> 
1<ml>SimFix_Closure-63_C_Patch_1218_1218.txt<ml>SimFix_Closure-63_C_Patch_1218_1218.txt<ml>mmm a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> ppp b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java <nl> / / padding equal to the excerpt and arrow at the end <nl> / / charno = = sourceExpert . length ( ) means something is missing <nl> / / at the end of the line <nl> + / / start of generated patch <nl> + if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { <nl> + for ( int i = 0 ; i < charno ; i + + ) { <nl> + char c = sourceExcerpt . charAt ( i ) ; <nl> + if ( Character . isWhitespace ( c ) ) { <nl> + b . append ( c ) ; <nl> + } else { <nl> + b . append ( ' ' ) ; <nl> + } <nl> + } <nl> + b . append ( " ^ \ n " ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( excerpt . equals ( LINE ) <nl> & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> } <nl> b . append ( " ^ \ n " ) ; <nl> } <nl> + end of original code * / <nl> } <nl> return b . toString ( ) ; <nl> } <nl> 
1<ml>SimFix_Math-57_C_Patch_169_169.txt<ml>SimFix_Math-57_C_Patch_169_169.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java <nl> while ( resultSet . size ( ) < k ) { <nl> / / For each data point x , compute D ( x ) , the distance between x and <nl> / / the nearest center that has already been chosen . <nl> + / / start of generated patch <nl> + double sum = 0 ; <nl> + for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { <nl> + final T p = pointSet . get ( i ) ; <nl> + final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ; <nl> + final double d = p . distanceFrom ( nearest . getCenter ( ) ) ; <nl> + sum + = d * d ; <nl> + dx2 [ i ] = sum ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> int sum = 0 ; <nl> for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { <nl> final T p = pointSet . get ( i ) ; <nl> sum + = d * d ; <nl> dx2 [ i ] = sum ; <nl> } <nl> + end of original code * / <nl> / / Add one new data point as a center . Each point x is chosen with <nl> / / probability proportional to D ( x ) 2 <nl> 
1<ml>SimFix_Chart-20_C_Patch_4_4.txt<ml>SimFix_Chart-20_C_Patch_4_4.txt<ml>mmm a / source / org / jfree / chart / plot / ValueMarker . java <nl> ppp b / source / org / jfree / chart / plot / ValueMarker . java <nl> * / <nl> public ValueMarker ( double value , Paint paint , Stroke stroke , <nl> Paint outlinePaint , Stroke outlineStroke , float alpha ) { <nl> + / / start of generated patch <nl> + super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; <nl> + this . value = value ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> super ( paint , stroke , paint , stroke , alpha ) ; <nl> this . value = value ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
0<ml>SimFix_Math-80_P_Patch_1091_1091.txt<ml>SimFix_Math-80_P_Patch_1091_1091.txt<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> / / flip array <nl> int j = 4 * n - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> + / / start of generated patch <nl> + for ( int k = 0 ; k < 0 ; k + = step ) { <nl> + final double tmp = work [ i + k ] ; <nl> + work [ i + k ] = work [ j - k ] ; <nl> + work [ j - k ] = tmp ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int k = 0 ; k < 4 ; k + = step ) { <nl> final double tmp = work [ i + k ] ; <nl> work [ i + k ] = work [ j - k ] ; <nl> work [ j - k ] = tmp ; <nl> } <nl> + end of original code * / <nl> j - = 4 ; <nl> } <nl> return true ; <nl> 
0<ml>SimFix_Lang-9_P_Patch_4_4.txt<ml>SimFix_Lang-9_P_Patch_4_4.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / event / EventListenerSupport . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / event / EventListenerSupport . java <nl> * not an interface . <nl> * / <nl> public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { <nl> + / / start of generated patch <nl> + this ( ) ; <nl> + Validate . notNull ( listenerInterface , " Listener interface cannot be null . " ) ; <nl> + Validate . notNull ( classLoader , " ClassLoader cannot be null . " ) ; <nl> + Validate . isTrue ( listenerInterface . isInterface ( ) , " Class { 0 } is not an interface " , listenerInterface . getName ( ) ) ; <nl> + this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; <nl> + initializeTransientFields ( listenerInterface , classLoader ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> this ( ) ; <nl> Validate . notNull ( listenerInterface , " Listener interface cannot be null . " ) ; <nl> Validate . notNull ( classLoader , " ClassLoader cannot be null . " ) ; <nl> Validate . isTrue ( listenerInterface . isInterface ( ) , " Class { 0 } is not an interface " , <nl> listenerInterface . getName ( ) ) ; <nl> initializeTransientFields ( listenerInterface , classLoader ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
1<ml>SimFix_Closure-57_C_Patch_26_26.txt<ml>SimFix_Closure-57_C_Patch_26_26.txt<ml>mmm a / src / com / google / javascript / jscomp / ClosureCodingConvention . java <nl> ppp b / src / com / google / javascript / jscomp / ClosureCodingConvention . java <nl> String qualifiedName = callee . getQualifiedName ( ) ; <nl> if ( functionName . equals ( qualifiedName ) ) { <nl> Node target = callee . getNext ( ) ; <nl> + / / start of generated patch <nl> + if ( target ! = null & & target . getType ( ) = = Token . STRING ) { <nl> + className = target . getString ( ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( target ! = null ) { <nl> className = target . getString ( ) ; <nl> } <nl> + end of original code * / <nl> } <nl> } <nl> } <nl> 
0<ml>SimFix_Closure-38_P_Patch_1376_1376.txt<ml>SimFix_Closure-38_P_Patch_1376_1376.txt<ml>mmm a / src / com / google / javascript / jscomp / CodeConsumer . java <nl> ppp b / src / com / google / javascript / jscomp / CodeConsumer . java <nl> / / x - - 4 ( which is a syntax error ) . <nl> char prev = getLastChar ( ) ; <nl> boolean negativeZero = isNegativeZero ( x ) ; <nl> + / / start of generated patch <nl> + if ( prev = = ' - ' ) { <nl> + add ( " " ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( x < 0 & & prev = = ' - ' ) { <nl> add ( " " ) ; <nl> } <nl> + end of original code * / <nl> if ( ( long ) x = = x & & ! negativeZero ) { <nl> long value = ( long ) x ; <nl> 
1<ml>SimFix_Math-5_C_Patch_1_1.txt<ml>SimFix_Math-5_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math3 / complex / Complex . java <nl> return NaN ; <nl> } <nl> + / / start of generated patch <nl> + if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { <nl> + return INF ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { <nl> return NaN ; <nl> } <nl> + end of original code * / <nl> if ( isInfinite ) { <nl> return ZERO ; <nl> 
0<ml>SimFix_Lang-61_P_Patch_4407_4407.txt<ml>SimFix_Lang-61_P_Patch_4407_4407.txt<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> char [ ] thisBuf = buffer ; <nl> int len = thisBuf . length - strLen ; <nl> outer : <nl> + / / start of generated patch <nl> + for ( int i = startIndex ; i < size ; i + + ) { <nl> + for ( int j = 0 ; j < strLen ; j + + ) { <nl> + if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { <nl> + continue outer ; <nl> + } <nl> + } <nl> + return i ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int i = startIndex ; i < len ; i + + ) { <nl> for ( int j = 0 ; j < strLen ; j + + ) { <nl> if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { <nl> } <nl> return i ; <nl> } <nl> + end of original code * / <nl> return - 1 ; <nl> } <nl> 
0<ml>SimFix_Math-1_P_Patch_60_60.txt<ml>SimFix_Math-1_P_Patch_60_60.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / fraction / BigFraction . java <nl> ppp b / src / main / java / org / apache / commons / math3 / fraction / BigFraction . java <nl> final long a1 = ( long ) FastMath . floor ( r1 ) ; <nl> p2 = ( a1 * p1 ) + p0 ; <nl> q2 = ( a1 * q1 ) + q0 ; <nl> + / / start of generated patch <nl> + if ( ( n < maxIterations ) & & ( FastMath . abs ( value - value ) > epsilon ) ) { <nl> + throw new FractionConversionException ( value , p2 , q2 ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { <nl> / / in maxDenominator mode , if the last fraction was very close to the actual value <nl> / / q2 may overflow in the next iteration ; in this case return the last one . <nl> throw new FractionConversionException ( value , p2 , q2 ) ; <nl> } <nl> + end of original code * / <nl> final double convergent = ( double ) p2 / ( double ) q2 ; <nl> if ( ( n < maxIterations ) & & <nl> 
0<ml>SimFix_Closure-19_P_Patch_4878_4878.txt<ml>SimFix_Closure-19_P_Patch_4878_4878.txt<ml>mmm a / src / com / google / javascript / jscomp / type / ClosureReverseAbstractInterpreter . java <nl> ppp b / src / com / google / javascript / jscomp / type / ClosureReverseAbstractInterpreter . java <nl> if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { <nl> Node callee = condition . getFirstChild ( ) ; <nl> Node param = condition . getLastChild ( ) ; <nl> + / / start of generated patch <nl> + if ( param . isName ( ) | | param . isGetProp ( ) ) { <nl> + JSType paramType = getTypeIfRefinable ( param , blindScope ) ; <nl> + Node left = callee . getFirstChild ( ) ; <nl> + Node right = callee . getLastChild ( ) ; <nl> + if ( left . isName ( ) & & " goog " . equals ( left . getString ( ) ) ) { <nl> + Function < TypeRestriction , JSType > restricter = restricters . get ( right . getString ( ) ) ; <nl> + if ( restricter ! = null ) { <nl> + return restrictParameter ( param , paramType , blindScope , restricter , outcome ) ; <nl> + } <nl> + } <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( callee . isGetProp ( ) & & param . isQualifiedName ( ) ) { <nl> JSType paramType = getTypeIfRefinable ( param , blindScope ) ; <nl> Node left = callee . getFirstChild ( ) ; <nl> } <nl> } <nl> } <nl> + end of original code * / <nl> } <nl> return nextPreciserScopeKnowingConditionOutcome ( <nl> condition , blindScope , outcome ) ; <nl> 
1<ml>SimFix_Closure-115_C_Patch_3_3.txt<ml>SimFix_Closure-115_C_Patch_3_3.txt<ml>mmm a / src / com / google / javascript / jscomp / FunctionInjector . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionInjector . java <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> + / / start of generated patch <nl> + if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> + return CanInlineResult . NO ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> return CanInlineResult . NO ; <nl> } <nl> + end of original code * / <nl> / / Check for arguments that are evaluated more than once . <nl> / / Note : Unlike block inlining , there it is not possible that a <nl> / / parameter reference will be in a loop . <nl> 
0<ml>SimFix_Math-63_P_Patch_28_28.txt<ml>SimFix_Math-63_P_Patch_28_28.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> * @ return { @ code true } if the values are equal . <nl> * / <nl> public static boolean equals ( double x , double y ) { <nl> + / / start of generated patch <nl> + return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
0<ml>SimFix_Math-84_P_Patch_26_26.txt<ml>SimFix_Math-84_P_Patch_26_26.txt<ml>mmm a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> / / compute the contracted simplex <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> + / / start of generated patch <nl> + if ( comparator . compare ( contracted , best ) < = 0 ) { <nl> + return ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( comparator . compare ( contracted , best ) < 0 ) { <nl> / / accept the contracted simplex <nl> / / check convergence <nl> return ; <nl> } <nl> + end of original code * / <nl> } <nl> 
0<ml>SimFix_Math-69_P_Patch_63_63.txt<ml>SimFix_Math-69_P_Patch_63_63.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java <nl> double [ ] [ ] out = new double [ nVars ] [ nVars ] ; <nl> for ( int i = 0 ; i < nVars ; i + + ) { <nl> for ( int j = 0 ; j < nVars ; j + + ) { <nl> + / / start of generated patch <nl> + if ( i = = j & & i < nVars ) { <nl> + out [ i ] [ j ] = 0 . 0 ; <nl> + } else { <nl> + double r = correlationMatrix . getEntry ( i , j ) ; <nl> + double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; <nl> + out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( i = = j ) { <nl> out [ i ] [ j ] = 0d ; <nl> } else { <nl> double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; <nl> out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; <nl> } <nl> + end of original code * / <nl> } <nl> } <nl> return new BlockRealMatrix ( out ) ; <nl> 
0<ml>SimFix_Lang-10_P_Patch_2518_2518.txt<ml>SimFix_Lang-10_P_Patch_2518_2518.txt<ml>mmm a / src / main / java / org / apache / commons / lang3 / event / EventListenerSupport . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / event / EventListenerSupport . java <nl> * not an interface . <nl> * / <nl> public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { <nl> + / / start of generated patch <nl> + this ( ) ; <nl> + Validate . notNull ( listenerInterface , " Listener interface cannot be null . " ) ; <nl> + Validate . notNull ( classLoader , " ClassLoader cannot be null . " ) ; <nl> + Validate . isTrue ( listenerInterface . isInterface ( ) , " Class { 0 } is not an interface " , listenerInterface . getName ( ) ) ; <nl> + this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; <nl> + initializeTransientFields ( listenerInterface , classLoader ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> this ( ) ; <nl> Validate . notNull ( listenerInterface , " Listener interface cannot be null . " ) ; <nl> Validate . notNull ( classLoader , " ClassLoader cannot be null . " ) ; <nl> Validate . isTrue ( listenerInterface . isInterface ( ) , " Class { 0 } is not an interface " , <nl> listenerInterface . getName ( ) ) ; <nl> initializeTransientFields ( listenerInterface , classLoader ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { <nl> boolean wasWhite = false ; <nl> for ( int i = 0 ; i < value . length ( ) ; + + i ) { <nl> + / / start of generated patch <nl> + char c = value . charAt ( i ) ; <nl> + if ( Character . isHighSurrogate ( c ) ) { <nl> + if ( ! wasWhite ) { <nl> + wasWhite = true ; <nl> + regex . append ( " \ \ s * + " ) ; <nl> + } <nl> + continue ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> char c = value . charAt ( i ) ; <nl> if ( Character . isWhitespace ( c ) ) { <nl> if ( ! wasWhite ) { <nl> } <nl> continue ; <nl> } <nl> + end of original code * / <nl> wasWhite = false ; <nl> switch ( c ) { <nl> case ' \ ' ' : <nl> 
0<ml>SimFix_Closure-26_P_Patch_6288_6288.txt<ml>SimFix_Closure-26_P_Patch_6288_6288.txt<ml>mmm a / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> } <nl> Node newRight ; <nl> + / / start of generated patch <nl> + if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { <nl> + n . removeChild ( right ) ; <nl> + newRight = right . getLastChild ( ) ; <nl> + } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) { <nl> + newRight = right . getFirstChild ( ) ; <nl> + } else { <nl> + return n ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { <nl> newRight = right . getLastChild ( ) ; <nl> } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & <nl> } else { <nl> return n ; <nl> } <nl> + end of original code * / <nl> int newType = - 1 ; <nl> switch ( right . getType ( ) ) { <nl> 
0<ml>SimFix_Math-73_P_Patch_4_4.txt<ml>SimFix_Math-73_P_Patch_4_4.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> } <nl> / / reduce interval if initial and max bracket the root <nl> + / / start of generated patch <nl> + if ( yInitial * yMax < 0 ) { <nl> + return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; <nl> + } <nl> + return solve ( f , min , initial ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( yInitial * yMax < 0 ) { <nl> return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; <nl> } <nl> / / full Brent algorithm starting with provided initial guess <nl> return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> + end of original code * / <nl> } <nl> 
1<ml>SimFix_Math-79_C_Patch_1320_1320.txt<ml>SimFix_Math-79_C_Patch_1320_1320.txt<ml>mmm a / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> * @ return the L < sub > 2 < / sub > distance between the two points <nl> * / <nl> public static double distance ( int [ ] p1 , int [ ] p2 ) { <nl> + / / start of generated patch <nl> + double sum = 0 ; <nl> + for ( int i = 0 ; i < p1 . length ; i + + ) { <nl> + final double dp = p1 [ i ] - p2 [ i ] ; <nl> + sum + = dp * dp ; <nl> + } <nl> + return Math . sqrt ( sum ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> int sum = 0 ; <nl> for ( int i = 0 ; i < p1 . length ; i + + ) { <nl> final int dp = p1 [ i ] - p2 [ i ] ; <nl> sum + = dp * dp ; <nl> } <nl> return Math . sqrt ( sum ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
1<ml>SimFix_Closure-68_C_Patch_80_80.txt<ml>SimFix_Closure-68_C_Patch_80_80.txt<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> private Node parseFunctionType ( JsDocToken token ) { <nl> / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so <nl> / / just throw out TypeParameters . <nl> + / / start of generated patch <nl> + if ( token ! = JsDocToken . LP ) { <nl> + restoreLookAhead ( token ) ; <nl> + return reportTypeSyntaxWarning ( " msg . jsdoc . missing . lp " ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( token ! = JsDocToken . LP ) { <nl> return reportTypeSyntaxWarning ( " msg . jsdoc . missing . lp " ) ; <nl> } <nl> + end of original code * / <nl> Node functionType = newNode ( Token . FUNCTION ) ; <nl> Node parameters = null ; <nl> 
0<ml>SimFix_Lang-50_P_Patch_1884_1884.txt<ml>SimFix_Lang-50_P_Patch_1884_1884.txt<ml>mmm a / src / java / org / apache / commons / lang / time / FastDateFormat . java <nl> ppp b / src / java / org / apache / commons / lang / time / FastDateFormat . java <nl> locale = Locale . getDefault ( ) ; <nl> } <nl> try { <nl> + / / start of generated patch <nl> + if ( locale ! = null ) { <nl> + key = new Pair ( key , locale ) ; <nl> + } <nl> + SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; <nl> + String pattern = formatter . toPattern ( ) ; <nl> + format = getInstance ( pattern , timeZone , locale ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; <nl> String pattern = formatter . toPattern ( ) ; <nl> format = getInstance ( pattern , timeZone , locale ) ; <nl> + end of original code * / <nl> cDateInstanceCache . put ( key , format ) ; <nl> } catch ( ClassCastException ex ) { <nl> locale = Locale . getDefault ( ) ; <nl> } <nl> try { <nl> + / / start of generated patch <nl> + if ( locale ! = null ) { <nl> + key = new Pair ( key , locale ) ; <nl> + } <nl> + SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; <nl> + String pattern = formatter . toPattern ( ) ; <nl> + format = getInstance ( pattern , timeZone , locale ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , <nl> locale ) ; <nl> String pattern = formatter . toPattern ( ) ; <nl> format = getInstance ( pattern , timeZone , locale ) ; <nl> + end of original code * / <nl> cDateTimeInstanceCache . put ( key , format ) ; <nl> } catch ( ClassCastException ex ) { <nl> 
0<ml>SimFix_Closure-22_P_Patch_1709_1709.txt<ml>SimFix_Closure-22_P_Patch_1709_1709.txt<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> / / This no - op statement was there so that JSDoc information could <nl> / / be attached to the name . This check should not complain about it . <nl> if ( n = = parent . getLastChild ( ) ) { <nl> + / / start of generated patch <nl> + for ( Node an : parent . getAncestors ( ) ) { <nl> + int ancestorType = parent . getParent ( ) . getType ( ) ; <nl> + if ( ancestorType = = Token . COMMA ) continue ; <nl> + if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) <nl> else <nl> break ; <nl> } <nl> + end of original code * / <nl> } <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | <nl> 
0<ml>SimFix_Math-6_P_Patch_2_2.txt<ml>SimFix_Math-6_P_Patch_2_2.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java <nl> * @ return the number of evaluations of the objective function . <nl> * / <nl> public int getIterations ( ) { <nl> + / / start of generated patch <nl> + return evaluations . getCount ( ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> return iterations . getCount ( ) ; <nl> + end of original code * / <nl> } <nl> / * * <nl> 
1<ml>SimFix_Closure-14_C_Patch_2251_2251.txt<ml>SimFix_Closure-14_C_Patch_2251_2251.txt<ml>mmm a / src / com / google / javascript / jscomp / ControlFlowAnalysis . java <nl> ppp b / src / com / google / javascript / jscomp / ControlFlowAnalysis . java <nl> / / If we are coming out of the FINALLY block . . . <nl> } else if ( parent . getLastChild ( ) = = node ) { <nl> if ( cfa ! = null ) { <nl> + / / start of generated patch <nl> + for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { <nl> + cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { <nl> cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; <nl> } <nl> + end of original code * / <nl> } <nl> return computeFollowNode ( fromNode , parent , cfa ) ; <nl> } <nl> 
1<ml>SimFix_Lang-43_C_Patch_3801_3801.txt<ml>SimFix_Lang-43_C_Patch_3801_3801.txt<ml>mmm a / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java <nl> ppp b / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java <nl> * / <nl> private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , <nl> StringBuffer appendTo , boolean escapingOn ) { <nl> + / / start of generated patch <nl> + int start = pos . getIndex ( ) ; <nl> + char [ ] c = pattern . toCharArray ( ) ; <nl> + if ( escapingOn & & c [ start ] = = QUOTE ) { <nl> + next ( pos ) ; <nl> + return appendTo = = null ? null : appendTo . append ( QUOTE ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> int start = pos . getIndex ( ) ; <nl> char [ ] c = pattern . toCharArray ( ) ; <nl> if ( escapingOn & & c [ start ] = = QUOTE ) { <nl> return appendTo = = null ? null : appendTo . append ( QUOTE ) ; <nl> } <nl> + end of original code * / <nl> int lastHold = start ; <nl> for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) { <nl> if ( escapingOn & & pattern . substring ( i ) . startsWith ( ESCAPED_QUOTE ) ) { <nl> 
0<ml>SimFix_Math-8_P_Patch_78_78.txt<ml>SimFix_Math-8_P_Patch_78_78.txt<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; <nl> + / / start of generated patch <nl> + for ( int i = sampleSize ; i < sampleSize ; i + + ) { <nl> + out [ i ] = sample ( ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> out [ i ] = sample ( ) ; <nl> } <nl> + end of original code * / <nl> return out ; <nl> 
1<ml>SimFix_Math-41_C_Patch_797_797.txt<ml>SimFix_Math-41_C_Patch_797_797.txt<ml>mmm a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java <nl> } <nl> double sumWts = 0 ; <nl> + / / start of generated patch <nl> + for ( int i = begin ; i < begin + length ; i + + ) { <nl> + sumWts + = weights [ i ] ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int i = 0 ; i < weights . length ; i + + ) { <nl> sumWts + = weights [ i ] ; <nl> } <nl> + end of original code * / <nl> if ( isBiasCorrected ) { <nl> var = ( accum - ( accum2 * accum2 / sumWts ) ) / ( sumWts - 1 . 0 ) ; <nl> 
0<ml>SimFix_Closure-108_P_Patch_4497_4497.txt<ml>SimFix_Closure-108_P_Patch_4497_4497.txt<ml>mmm a / src / com / google / javascript / rhino / Node . java <nl> ppp b / src / com / google / javascript / rhino / Node . java <nl> * that of { @ code other } iff the source info is missing . <nl> * / <nl> public Node useSourceInfoIfMissingFromForTree ( Node other ) { <nl> + / / start of generated patch <nl> + useSourceInfoIfMissingFrom ( other ) ; <nl> + for ( Node child = getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { <nl> + child . useSourceInfoIfMissingFromForTree ( other ) ; <nl> + } <nl> + this . propListHead = other . propListHead ; <nl> + return this ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> useSourceInfoIfMissingFrom ( other ) ; <nl> for ( Node child = getFirstChild ( ) ; <nl> child ! = null ; child = child . getNext ( ) ) { <nl> } <nl> return this ; <nl> + end of original code * / <nl> } <nl> / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> 
0<ml>SimFix_Chart-3_P_Patch_1622_1622.txt<ml>SimFix_Chart-3_P_Patch_1622_1622.txt<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> TimeSeries copy = ( TimeSeries ) super . clone ( ) ; <nl> copy . data = new java . util . ArrayList ( ) ; <nl> if ( this . data . size ( ) > 0 ) { <nl> + / / start of generated patch <nl> + this . maxY = 1 . 0 ; <nl> + TimeSeries copy = ( TimeSeries ) super . clone ( ) ; <nl> + copy . data = new java . util . ArrayList ( ) ; <nl> + if ( this . data . size ( ) > 0 ) { <nl> + for ( int index = start ; index < = end ; index + + ) { <nl> + TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ; <nl> + TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; <nl> + try { <nl> + copy . add ( clone ) ; <nl> + } catch ( SeriesException e ) { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + <nl> + } <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( int index = start ; index < = end ; index + + ) { <nl> TimeSeriesDataItem item <nl> = ( TimeSeriesDataItem ) this . data . get ( index ) ; <nl> e . printStackTrace ( ) ; <nl> } <nl> } <nl> + end of original code * / <nl> } <nl> return copy ; <nl> } <nl> 
1<ml>SimFix_Chart-7_C_Patch_447_447.txt<ml>SimFix_Chart-7_C_Patch_447_447.txt<ml>mmm a / source / org / jfree / data / time / TimePeriodValues . java <nl> ppp b / source / org / jfree / data / time / TimePeriodValues . java <nl> this . minMiddleIndex = index ; <nl> } <nl> + / / start of generated patch <nl> + if ( this . maxMiddleIndex > = 0 ) { <nl> + long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; <nl> + long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; <nl> + long maxMiddle = s + ( e - s ) / 2 ; <nl> + if ( middle > maxMiddle ) { <nl> + this . maxMiddleIndex = index ; <nl> + } <nl> + } else { <nl> + this . maxMiddleIndex = index ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( this . maxMiddleIndex > = 0 ) { <nl> long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) <nl> . getTime ( ) ; <nl> else { <nl> this . maxMiddleIndex = index ; <nl> } <nl> + end of original code * / <nl> if ( this . minEndIndex > = 0 ) { <nl> long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) <nl> 
0<ml>SimFix_Chart-18_P_Patch_38_38.txt<ml>SimFix_Chart-18_P_Patch_38_38.txt<ml>mmm a / source / org / jfree / data / DefaultKeyedValues . java <nl> ppp b / source / org / jfree / data / DefaultKeyedValues . java <nl> public void removeValue ( int index ) { <nl> this . keys . remove ( index ) ; <nl> this . values . remove ( index ) ; <nl> + / / start of generated patch <nl> + if ( index < = this . keys . size ( ) ) { <nl> + rebuildIndex ( ) ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> if ( index < this . keys . size ( ) ) { <nl> rebuildIndex ( ) ; <nl> } <nl> + end of original code * / <nl> } <nl> / * * <nl> * Removes a value from the collection . <nl> 
0<ml>SimFix_Closure-21_P_Patch_15_15.txt<ml>SimFix_Closure-21_P_Patch_15_15.txt<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> return ; <nl> } <nl> if ( n = = parent . getLastChild ( ) ) { <nl> + / / start of generated patch <nl> + for ( Node an : parent . getAncestors ( ) ) { <nl> + int ancestorType = parent . getParent ( ) . getType ( ) ; <nl> + if ( ancestorType = = Token . COMMA ) continue ; <nl> + if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; <nl> + } <nl> + / / end of generated patch <nl> + / * start of original code <nl> for ( Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> if ( ancestorType = = Token . COMMA ) continue ; <nl> if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> else break ; <nl> } <nl> + end of original code * / <nl> } <nl> } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { <nl> 
0<ml>SimFix_Chart-12_P_Patch_107_107.txt<ml>SimFix_Chart-12_P_Patch_107_107.txt<ml>mmm a / source / org / jfree / chart / plot / MultiplePiePlot . java <nl> ppp b / source / org / jfree / chart / plot / MultiplePiePlot . java <nl> * / <nl> public MultiplePiePlot ( CategoryDataset dataset ) { <nl> super ( ) ; <nl> + / / start of generated patch <nl> + if ( dataset ! = null ) { <nl> + dataset . addChangeListener ( this ) ; <nl> + } <nl> + this . dataset = dataset ; <nl> + PiePlot piePlot = new PiePlot ( null ) ; <nl> + this . pieChart = new JFreeChart ( piePlot ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> this . dataset = dataset ; <nl> PiePlot piePlot = new PiePlot ( null ) ; <nl> this . pieChart = new JFreeChart ( piePlot ) ; <nl> + end of original code * / <nl> this . pieChart . removeLegend ( ) ; <nl> this . dataExtractOrder = TableOrder . BY_COLUMN ; <nl> this . pieChart . setBackgroundPaint ( null ) ; <nl> 
1<ml>SimFix_Math-70_C_Patch_1_1.txt<ml>SimFix_Math-70_C_Patch_1_1.txt<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BisectionSolver . java <nl> / * * { @ inheritDoc } * / <nl> public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) <nl> throws MaxIterationsExceededException , FunctionEvaluationException { <nl> + / / start of generated patch <nl> + return solve ( f , min , max ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> return solve ( min , max ) ; <nl> + end of original code * / <nl> } <nl> / * * { @ inheritDoc } * / <nl> 
0<ml>SimFix_Closure-106_P_Patch_1483_1483.txt<ml>SimFix_Closure-106_P_Patch_1483_1483.txt<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> builder . append ( toString ( token ) ) ; <nl> String line = stream . getRemainingJSDocLine ( ) ; <nl> + / / start of generated patch <nl> + line = trimEnd ( line ) ; <nl> + builder . append ( line ) ; <nl> + jsdocBuilder . recordDescription ( line ) ; <nl> + token = next ( ) ; <nl> + / / end of generated patch <nl> + / * start of original code <nl> line = trimEnd ( line ) ; <nl> builder . append ( line ) ; <nl> token = next ( ) ; <nl> + end of original code * / <nl> } <nl> } while ( true ) ; <nl> } <nl> 
0<ml>jMutRepair_Chart-26_P_Patch_158_78.txt<ml>jMutRepair_Chart-26_P_Patch_158_78.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Chart_26 / source / org / jfree / chart / plot / CategoryPlotjava <nl> ppp  / tmp / jMutRepair_Defects4J_Chart_26 / source / org / jfree / chart / plot / CategoryPlotjava <nl> boolean b1 = ( area . getWidth ( ) ) < = ( org . jfree . chart . plot . Plot . MINIMUM_WIDTH_TO_DRAW ) ; <nl> boolean b2 = ( area . getHeight ( ) ) < = ( org . jfree . chart . plot . Plot . MINIMUM_HEIGHT_TO_DRAW ) ; <nl> - if ( b1 | | b2 ) { <nl> + if ( ( ! b1 ) | | b2 ) { <nl> return ; <nl> } <nl> 
0<ml>jMutRepair_Math-88_P_Patch_60_56.txt<ml>jMutRepair_Math-88_P_Patch_60_56.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_88 / src / java / org / apache / commons / math / optimization / linear / SimplexSolverjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_88 / src / java / org / apache / commons / math / optimization / linear / SimplexSolverjava <nl> double rhs = tableau . getEntry ( i , ( ( tableau . getWidth ( ) ) - 1 ) ) ; <nl> if ( ( org . apache . commons . math . util . MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) ) > = 0 ) { <nl> double ratio = rhs / ( tableau . getEntry ( i , col ) ) ; <nl> - if ( ratio < minRatio ) { <nl> + if ( ratio < = minRatio ) { <nl> minRatio = ratio ; <nl> minRatioPos = i ; <nl> } <nl> 
0<ml>jMutRepair_Lang-27_P_Patch_67_55.txt<ml>jMutRepair_Lang-27_P_Patch_67_55.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> ppp  / tmp / jMutRepair_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava <nl> } <nl> mant = str . substring ( 0 , decPos ) ; <nl> } else { <nl> - if ( expPos > ( - 1 ) ) { <nl> + if ( expPos < ( - 1 ) ) { <nl> mant = str . substring ( 0 , expPos ) ; <nl> } else { <nl> mant = str ; <nl> 
1<ml>jMutRepair_Math-82_C_Patch_28_28.txt<ml>jMutRepair_Math-82_C_Patch_28_28.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_82 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolverjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_82 / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolverjava <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < ( tableau . getHeight ( ) ) ; i + + ) { <nl> final double rhs = tableau . getEntry ( i , ( ( tableau . getWidth ( ) ) - 1 ) ) ; <nl> final double entry = tableau . getEntry ( i , col ) ; <nl> - if ( ( org . apache . commons . math . util . MathUtils . compareTo ( entry , 0 , epsilon ) ) > = 0 ) { <nl> + if ( ( org . apache . commons . math . util . MathUtils . compareTo ( entry , 0 , this . epsilon ) ) > 0 ) { <nl> final double ratio = rhs / entry ; <nl> if ( ratio < minRatio ) { <nl> minRatio = ratio ; <nl> 
0<ml>jMutRepair_Closure-126_P_Patch_2_2.txt<ml>jMutRepair_Closure-126_P_Patch_2_2.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPointsjava <nl> ppp  / tmp / jMutRepair_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPointsjava <nl> - if ( com . google . javascript . jscomp . NodeUtil . hasFinally ( n ) ) { <nl> + if ( ! ( com . google . javascript . jscomp . NodeUtil . hasFinally ( n ) ) ) { <nl> com . google . javascript . rhino . Node finallyBlock = n . getLastChild ( ) ; <nl> tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> } <nl> 
0<ml>jMutRepair_Math-50_P_Patch_3_3.txt<ml>jMutRepair_Math-50_P_Patch_3_3.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava <nl> break ; <nl> case REGULA_FALSI : <nl> - if ( x = = x1 ) { <nl> + if ( x > x1 ) { <nl> x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; <nl> f0 = computeObjectiveValue ( x0 ) ; <nl> } <nl> 
0<ml>jMutRepair_Chart-25_P_Patch_8_4.txt<ml>jMutRepair_Chart-25_P_Patch_8_4.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDatasetjava <nl> ppp  / tmp / jMutRepair_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDatasetjava <nl> java . lang . Number result = null ; <nl> org . jfree . data . statistics . MeanAndStandardDeviation masd = <nl> ( ( org . jfree . data . statistics . MeanAndStandardDeviation ) ( this . data . getObject ( row , column ) ) ) ; <nl> - if ( masd ! = null ) { <nl> + if ( masd = = null ) { <nl> result = masd . getMean ( ) ; <nl> } <nl> return result ; <nl> 
0<ml>jMutRepair_Math-81_P_Patch_3_3.txt<ml>jMutRepair_Math-81_P_Patch_3_3.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> double b1 = work [ ( np - 2 ) ] ; <nl> double b2 = work [ ( np - 6 ) ] ; <nl> final double gam = dN2 ; <nl> - if ( ( ( work [ ( np - 8 ) ] ) > b2 ) | | ( ( work [ ( np - 4 ) ] ) > b1 ) ) { <nl> + if ( ( ( this . work [ ( np - 8 ) ] ) ! = b2 ) | | ( ( this . work [ ( np - 4 ) ] ) > b1 ) ) { <nl> return ; <nl> } <nl> double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ; <nl> 
1<ml>jMutRepair_Math-85_C_Patch_69_69.txt<ml>jMutRepair_Math-85_C_Patch_69_69.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtilsjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtilsjava <nl> } while ( ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> - if ( ( fa * fb ) > = 0 . 0 ) { <nl> + if ( ( fa * fb ) > 0 . 0 ) { <nl> throw new org . apache . commons . math . ConvergenceException ( <nl> ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> ( " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> 
0<ml>jMutRepair_Math-28_P_Patch_1_1.txt<ml>jMutRepair_Math-28_P_Patch_1_1.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava <nl> for ( java . lang . Integer row : minRatioPositions ) { <nl> int i = tableau . getNumObjectiveFunctions ( ) ; <nl> for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { <nl> - if ( row = = ( tableau . getBasicRow ( i ) ) ) { <nl> + if ( row ! = ( tableau . getBasicRow ( i ) ) ) { <nl> if ( i < minIndex ) { <nl> minIndex = i ; <nl> minRow = row ; <nl> 
0<ml>jMutRepair_Math-57_P_Patch_22_22.txt<ml>jMutRepair_Math-57_P_Patch_22_22.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_57 / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPointjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_57 / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPointjava <nl> return false ; <nl> } <nl> for ( int i = 0 ; i < ( point . length ) ; i + + ) { <nl> - if ( ( point [ i ] ) ! = ( otherPoint [ i ] ) ) { <nl> + if ( ( this . point [ i ] ) > ( otherPoint [ i ] ) ) { <nl> return false ; <nl> } <nl> } <nl> 
1<ml>jMutRepair_Chart-1_C_Patch_33_13.txt<ml>jMutRepair_Chart-1_C_Patch_33_13.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRendererjava <nl> ppp  / tmp / jMutRepair_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRendererjava <nl> } <nl> int index = this . plot . getIndexOf ( this ) ; <nl> org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; <nl> - if ( dataset ! = null ) { <nl> + if ( dataset = = null ) { <nl> return result ; <nl> } <nl> int seriesCount = dataset . getRowCount ( ) ; <nl> 
1<ml>jMutRepair_Closure-63_C_Patch_14_14.txt<ml>jMutRepair_Closure-63_C_Patch_14_14.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> ppp  / tmp / jMutRepair_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> - if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> - ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { <nl> + if ( ( ( this . excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> + ( 0 < = charno ) ) & & ( charno < = ( sourceExcerpt . length ( ) ) ) ) { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( java . lang . Character . isWhitespace ( c ) ) { <nl> 
0<ml>jMutRepair_Math-80_P_Patch_305_301.txt<ml>jMutRepair_Math-80_P_Patch_305_301.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava <nl> private boolean flipIfWarranted ( final int n , final int step ) { <nl> - if ( ( 1 . 5 * ( work [ pingPong ] ) ) < ( work [ ( ( 4 * ( n - 1 ) ) + ( pingPong ) ) ] ) ) { <nl> + if ( ( 1 . 5 * ( this . work [ this . pingPong ] ) ) = = ( this . work [ ( ( 4 * ( n - 1 ) ) + ( this . pingPong ) ) ] ) ) { <nl> int j = ( 4 * n ) - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> 
0<ml>jMutRepair_Math-84_P_Patch_7_7.txt<ml>jMutRepair_Math-84_P_Patch_7_7.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava <nl> final org . apache . commons . math . optimization . RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> - if ( ( comparator . compare ( contracted , best ) ) < 0 ) { <nl> + if ( ( comparator . compare ( contracted , best ) ) = = 0 ) { <nl> 
1<ml>jMutRepair_Closure-62_C_Patch_14_14.txt<ml>jMutRepair_Closure-62_C_Patch_14_14.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> ppp  / tmp / jMutRepair_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava <nl> - if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> - ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { <nl> + if ( ( ( this . excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & <nl> + ( 0 < = charno ) ) & & ( charno < = ( sourceExcerpt . length ( ) ) ) ) { <nl> for ( int i = 0 ; i < charno ; i + + ) { <nl> char c = sourceExcerpt . charAt ( i ) ; <nl> if ( java . lang . Character . isWhitespace ( c ) ) { <nl> 
0<ml>jMutRepair_Closure-22_P_Patch_17_9.txt<ml>jMutRepair_Closure-22_P_Patch_17_9.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> ppp  / tmp / jMutRepair_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> if ( n = = ( parent . getLastChild ( ) ) ) { <nl> for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) <nl> + if ( ancestorType > = ( com . google . javascript . rhino . Token . COMMA ) ) <nl> continue ; <nl> if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) <nl> return ; else <nl> 
0<ml>jMutRepair_Math-52_P_Patch_34_34.txt<ml>jMutRepair_Math-52_P_Patch_34_34.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_52 / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotationjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_52 / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotationjava <nl> org . apache . commons . math . geometry . euclidean . threed . Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; <nl> org . apache . commons . math . geometry . euclidean . threed . Vector3D u3 = u1 . crossProduct ( u2 ) ; <nl> double c = k . dotProduct ( u3 ) ; <nl> - if ( c = = 0 ) { <nl> + if ( c < = 0 ) { <nl> org . apache . commons . math . geometry . euclidean . threed . Vector3D v3 = org . apache . commons . math . geometry . euclidean . threed . Vector3D . crossProduct ( v1 , v2 ) ; <nl> 
0<ml>jMutRepair_Lang-22_P_Patch_59_55.txt<ml>jMutRepair_Lang-22_P_Patch_59_55.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava <nl> ppp  / tmp / jMutRepair_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava <nl> private static int greatestCommonDivisor ( int u , int v ) { <nl> - if ( ( ( java . lang . Math . abs ( u ) ) < = 1 ) | | ( ( java . lang . Math . abs ( v ) ) < = 1 ) ) { <nl> + if ( ( ( java . lang . Math . abs ( u ) ) < = 1 ) & & ( ( java . lang . Math . abs ( v ) ) < = 1 ) ) { <nl> return 1 ; <nl> } <nl> 
0<ml>jMutRepair_Math-2_P_Patch_16_16.txt<ml>jMutRepair_Math-2_P_Patch_16_16.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava <nl> ppp  / tmp / jMutRepair_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava <nl> } <nl> k = 1 . 0 / k ; <nl> tmp = mu + ( k * sigma ) ; <nl> - if ( tmp < upper ) { <nl> + if ( tmp > = upper ) { <nl> upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; <nl> } <nl> } <nl> 
0<ml>jMutRepair_Closure-21_P_Patch_2_2.txt<ml>jMutRepair_Closure-21_P_Patch_2_2.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> ppp  / tmp / jMutRepair_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava <nl> if ( n = = ( parent . getLastChild ( ) ) ) { <nl> for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { <nl> int ancestorType = an . getType ( ) ; <nl> - if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; <nl> + if ( ancestorType > = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; <nl> if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else <nl> break ; <nl> } <nl> 
0<ml>jMutRepair_Chart-7_P_Patch_31_27.txt<ml>jMutRepair_Chart-7_P_Patch_31_27.txt<ml>mmm  / tmp / jMutRepair_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava <nl> ppp  / tmp / jMutRepair_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava <nl> this . maxStartIndex = index ; <nl> } <nl> - if ( ( this . minMiddleIndex ) > = 0 ) { <nl> + if ( ( this . minMiddleIndex ) = = 0 ) { <nl> long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; <nl> long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; <nl> 
1<ml>Chart_12.src.patch<ml>Chart_12.src.patch<ml>mmm a / source / org / jfree / chart / plot / MultiplePiePlot . java <nl> ppp b / source / org / jfree / chart / plot / MultiplePiePlot . java <nl> * / <nl> public MultiplePiePlot ( CategoryDataset dataset ) { <nl> super ( ) ; <nl> - setDataset ( dataset ) ; <nl> + this . dataset = dataset ; <nl> PiePlot piePlot = new PiePlot ( null ) ; <nl> this . pieChart = new JFreeChart ( piePlot ) ; <nl> this . pieChart . removeLegend ( ) ; <nl> 
1<ml>Chart_6.src.patch<ml>Chart_6.src.patch<ml>mmm a / source / org / jfree / chart / util / ShapeList . java <nl> ppp b / source / org / jfree / chart / util / ShapeList . java <nl> if ( ! ( obj instanceof ShapeList ) ) { <nl> return false ; <nl> } <nl> - ShapeList that = ( ShapeList ) obj ; <nl> - int listSize = size ( ) ; <nl> - for ( int i = 0 ; i < listSize ; i + + ) { <nl> - if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { <nl> - return false ; <nl> - } <nl> - } <nl> - return true ; <nl> + return super . equals ( obj ) ; <nl> } <nl> 
1<ml>Chart_19.src.patch<ml>Chart_19.src.patch<ml>mmm a / source / org / jfree / chart / plot / CategoryPlot . java <nl> ppp b / source / org / jfree / chart / plot / CategoryPlot . java <nl> * @ since 1 . 0 . 3 <nl> * / <nl> public int getDomainAxisIndex ( CategoryAxis axis ) { <nl> - if ( axis = = null ) { <nl> - throw new IllegalArgumentException ( " Null ' axis ' argument . " ) ; <nl> - } <nl> return this . domainAxes . indexOf ( axis ) ; <nl> } <nl> * @ since 1 . 0 . 7 <nl> * / <nl> public int getRangeAxisIndex ( ValueAxis axis ) { <nl> - if ( axis = = null ) { <nl> - throw new IllegalArgumentException ( " Null ' axis ' argument . " ) ; <nl> - } <nl> int result = this . rangeAxes . indexOf ( axis ) ; <nl> if ( result < 0 ) { / / try the parent plot <nl> Plot parent = getParent ( ) ; <nl> 
1<ml>Chart_21.src.patch<ml>Chart_21.src.patch<ml>mmm a / source / org / jfree / data / statistics / DefaultBoxAndWhiskerCategoryDataset . java <nl> ppp b / source / org / jfree / data / statistics / DefaultBoxAndWhiskerCategoryDataset . java <nl> & & this . minimumRangeValueColumn = = c ) ) { <nl> updateBounds ( ) ; <nl> } <nl> - else { <nl> double minval = Double . NaN ; <nl> if ( item . getMinOutlier ( ) ! = null ) { <nl> this . minimumRangeValueRow = r ; <nl> this . minimumRangeValueColumn = c ; <nl> } <nl> - } <nl> this . rangeBounds = new Range ( this . minimumRangeValue , <nl> this . maximumRangeValue ) ; <nl> * / <nl> private void updateBounds ( ) { <nl> this . minimumRangeValue = Double . NaN ; <nl> - this . minimumRangeValueRow = - 1 ; <nl> - this . minimumRangeValueColumn = - 1 ; <nl> this . maximumRangeValue = Double . NaN ; <nl> - this . maximumRangeValueRow = - 1 ; <nl> - this . maximumRangeValueColumn = - 1 ; <nl> - int rowCount = getRowCount ( ) ; <nl> - int columnCount = getColumnCount ( ) ; <nl> - for ( int r = 0 ; r < rowCount ; r + + ) { <nl> - for ( int c = 0 ; c < columnCount ; c + + ) { <nl> - BoxAndWhiskerItem item = getItem ( r , c ) ; <nl> - if ( item ! = null ) { <nl> - Number min = item . getMinOutlier ( ) ; <nl> - if ( min ! = null ) { <nl> - double minv = min . doubleValue ( ) ; <nl> - if ( ! Double . isNaN ( minv ) ) { <nl> - if ( minv < this . minimumRangeValue | | Double . isNaN ( <nl> - this . minimumRangeValue ) ) { <nl> - this . minimumRangeValue = minv ; <nl> - this . minimumRangeValueRow = r ; <nl> - this . minimumRangeValueColumn = c ; <nl> - } <nl> - } <nl> - } <nl> - Number max = item . getMaxOutlier ( ) ; <nl> - if ( max ! = null ) { <nl> - double maxv = max . doubleValue ( ) ; <nl> - if ( ! Double . isNaN ( maxv ) ) { <nl> - if ( maxv > this . maximumRangeValue | | Double . isNaN ( <nl> - this . maximumRangeValue ) ) { <nl> - this . maximumRangeValue = maxv ; <nl> - this . maximumRangeValueRow = r ; <nl> - this . maximumRangeValueColumn = c ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> } <nl> / * * <nl> 
1<ml>Chart_13.src.patch<ml>Chart_13.src.patch<ml>mmm a / source / org / jfree / chart / block / BorderArrangement . java <nl> ppp b / source / org / jfree / chart / block / BorderArrangement . java <nl> h [ 3 ] = h [ 2 ] ; <nl> if ( this . rightBlock ! = null ) { <nl> RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , <nl> - new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , <nl> + new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , <nl> LengthConstraintType . RANGE , h [ 2 ] , null , <nl> LengthConstraintType . FIXED ) ; <nl> Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <nl> 
1<ml>Chart_26.src.patch<ml>Chart_26.src.patch<ml>mmm a / source / org / jfree / chart / axis / Axis . java <nl> ppp b / source / org / jfree / chart / axis / Axis . java <nl> } <nl> if ( plotState ! = null & & hotspot ! = null ) { <nl> ChartRenderingInfo owner = plotState . getOwner ( ) ; <nl> - if ( owner ! = null ) { <nl> EntityCollection entities = owner . getEntityCollection ( ) ; <nl> if ( entities ! = null ) { <nl> entities . add ( new AxisLabelEntity ( this , hotspot , <nl> this . labelToolTip , this . labelURL ) ) ; <nl> } <nl> - } <nl> } <nl> return state ; <nl> 
1<ml>Chart_7.src.patch<ml>Chart_7.src.patch<ml>Index : source / org / jfree / data / time / TimePeriodValues . java <nl> = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> mmm source / org / jfree / data / time / TimePeriodValues . java 	  ( revision <nl> ppp source / org / jfree / data / time / TimePeriodValues . java 	  ( revision <nl> } <nl> if ( this . maxMiddleIndex > = 0 ) { <nl> - long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) <nl> + long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) <nl> . getTime ( ) ; <nl> - long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) <nl> + long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) <nl> . getTime ( ) ; <nl> long maxMiddle = s + ( e - s ) / 2 ; <nl> if ( middle > maxMiddle ) { <nl> 
1<ml>Chart_18.src.patch<ml>Chart_18.src.patch<ml>mmm a / source / org / jfree / data / DefaultKeyedValues . java <nl> ppp b / source / org / jfree / data / DefaultKeyedValues . java <nl> public void removeValue ( int index ) { <nl> this . keys . remove ( index ) ; <nl> this . values . remove ( index ) ; <nl> + if ( index < this . keys . size ( ) ) { <nl> rebuildIndex ( ) ; <nl> + } <nl> } <nl> / * * <nl> public void removeValue ( Comparable key ) { <nl> int index = getIndex ( key ) ; <nl> if ( index < 0 ) { <nl> - throw new UnknownKeyException ( " The key ( " + key <nl> - + " ) is not recognised . " ) ; <nl> + return ; <nl> } <nl> removeValue ( index ) ; <nl> } <nl> mmm a / source / org / jfree / data / DefaultKeyedValues2D . java <nl> ppp b / source / org / jfree / data / DefaultKeyedValues2D . java <nl> * @ see # removeRow ( Comparable ) <nl> * / <nl> public void removeColumn ( Comparable columnKey ) { <nl> - if ( columnKey = = null ) { <nl> - throw new IllegalArgumentException ( " Null ' columnKey ' argument . " ) ; <nl> - } <nl> - if ( ! this . columnKeys . contains ( columnKey ) ) { <nl> - throw new UnknownKeyException ( " Unknown key : " + columnKey ) ; <nl> - } <nl> Iterator iterator = this . rows . iterator ( ) ; <nl> while ( iterator . hasNext ( ) ) { <nl> DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; <nl> - int index = rowData . getIndex ( columnKey ) ; <nl> - if ( index > = 0 ) { <nl> rowData . removeValue ( columnKey ) ; <nl> - } <nl> } <nl> this . columnKeys . remove ( columnKey ) ; <nl> } <nl> 
1<ml>Chart_15.src.patch<ml>Chart_15.src.patch<ml>mmm a / source / org / jfree / chart / plot / PiePlot . java <nl> ppp b / source / org / jfree / chart / plot / PiePlot . java <nl> * @ return The percent . <nl> * / <nl> public double getMaximumExplodePercent ( ) { <nl> - if ( this . dataset = = null ) { <nl> - return 0 . 0 ; <nl> - } <nl> double result = 0 . 0 ; <nl> Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; <nl> while ( iterator . hasNext ( ) ) { <nl> PiePlotState state = new PiePlotState ( info ) ; <nl> state . setPassesRequired ( 2 ) ; <nl> - if ( this . dataset ! = null ) { <nl> state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( <nl> plot . getDataset ( ) ) ) ; <nl> - } <nl> state . setLatestAngle ( plot . getStartAngle ( ) ) ; <nl> return state ; <nl> 
1<ml>Chart_2.src.patch<ml>Chart_2.src.patch<ml>mmm a / source / org / jfree / data / general / DatasetUtilities . java <nl> ppp b / source / org / jfree / data / general / DatasetUtilities . java <nl> for ( int series = 0 ; series < seriesCount ; series + + ) { <nl> int itemCount = dataset . getItemCount ( series ) ; <nl> for ( int item = 0 ; item < itemCount ; item + + ) { <nl> - double value = intervalXYData . getXValue ( series , item ) ; <nl> lvalue = intervalXYData . getStartXValue ( series , item ) ; <nl> uvalue = intervalXYData . getEndXValue ( series , item ) ; <nl> - if ( ! Double . isNaN ( value ) ) { <nl> - minimum = Math . min ( minimum , value ) ; <nl> - maximum = Math . max ( maximum , value ) ; <nl> - } <nl> if ( ! Double . isNaN ( lvalue ) ) { <nl> minimum = Math . min ( minimum , lvalue ) ; <nl> - maximum = Math . max ( maximum , lvalue ) ; <nl> } <nl> if ( ! Double . isNaN ( uvalue ) ) { <nl> - minimum = Math . min ( minimum , uvalue ) ; <nl> maximum = Math . max ( maximum , uvalue ) ; <nl> } <nl> } <nl> for ( int series = 0 ; series < seriesCount ; series + + ) { <nl> int itemCount = dataset . getItemCount ( series ) ; <nl> for ( int item = 0 ; item < itemCount ; item + + ) { <nl> - double value = ixyd . getYValue ( series , item ) ; <nl> double lvalue = ixyd . getStartYValue ( series , item ) ; <nl> double uvalue = ixyd . getEndYValue ( series , item ) ; <nl> - if ( ! Double . isNaN ( value ) ) { <nl> - minimum = Math . min ( minimum , value ) ; <nl> - maximum = Math . max ( maximum , value ) ; <nl> - } <nl> if ( ! Double . isNaN ( lvalue ) ) { <nl> minimum = Math . min ( minimum , lvalue ) ; <nl> - maximum = Math . max ( maximum , lvalue ) ; <nl> } <nl> if ( ! Double . isNaN ( uvalue ) ) { <nl> - minimum = Math . min ( minimum , uvalue ) ; <nl> maximum = Math . max ( maximum , uvalue ) ; <nl> } <nl> } <nl> 
1<ml>Chart_25.src.patch<ml>Chart_25.src.patch<ml>mmm a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java <nl> / / BAR X <nl> Number meanValue = dataset . getMeanValue ( row , column ) ; <nl> - if ( meanValue = = null ) { <nl> - return ; <nl> - } <nl> double value = meanValue . doubleValue ( ) ; <nl> double base = 0 . 0 ; <nl> } <nl> / / standard deviation lines <nl> - Number n = dataset . getStdDevValue ( row , column ) ; <nl> - if ( n ! = null ) { <nl> - double valueDelta = n . doubleValue ( ) ; <nl> + double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; <nl> double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) <nl> + valueDelta , dataArea , yAxisLocation ) ; <nl> double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) <nl> line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , <nl> lowVal , rectY + rectHeight * 0 . 75 ) ; <nl> g2 . draw ( line ) ; <nl> - } <nl> CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , <nl> column ) ; <nl> / / BAR Y <nl> Number meanValue = dataset . getMeanValue ( row , column ) ; <nl> - if ( meanValue = = null ) { <nl> - return ; <nl> - } <nl> double value = meanValue . doubleValue ( ) ; <nl> double base = 0 . 0 ; <nl> } <nl> / / standard deviation lines <nl> - Number n = dataset . getStdDevValue ( row , column ) ; <nl> - if ( n ! = null ) { <nl> - double valueDelta = n . doubleValue ( ) ; <nl> + double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; <nl> double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) <nl> + valueDelta , dataArea , yAxisLocation ) ; <nl> double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) <nl> line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , <nl> rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; <nl> g2 . draw ( line ) ; <nl> - } <nl> CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , <nl> column ) ; <nl> 
1<ml>Chart_10.src.patch<ml>Chart_10.src.patch<ml>mmm a / source / org / jfree / chart / imagemap / StandardToolTipTagFragmentGenerator . java <nl> ppp b / source / org / jfree / chart / imagemap / StandardToolTipTagFragmentGenerator . java <nl> * @ return The formatted HTML area tag attribute ( s ) . <nl> * / <nl> public String generateToolTipFragment ( String toolTipText ) { <nl> - return " title = \ " " + ImageMapUtilities . htmlEscape ( toolTipText ) <nl> + return " title = \ " " + toolTipText <nl> + " \ " alt = \ " \ " " ; <nl> } <nl> 
1<ml>Chart_4.src.patch<ml>Chart_4.src.patch<ml>mmm a / source / org / jfree / chart / plot / XYPlot . java <nl> ppp b / source / org / jfree / chart / plot / XYPlot . java <nl> } <nl> } <nl> - if ( r ! = null ) { <nl> Collection c = r . getAnnotations ( ) ; <nl> Iterator i = c . iterator ( ) ; <nl> while ( i . hasNext ( ) ) { <nl> includedAnnotations . add ( a ) ; <nl> } <nl> } <nl> - } <nl> } <nl> } <nl> 
1<ml>Chart_16.src.patch<ml>Chart_16.src.patch<ml>mmm a / source / org / jfree / data / category / DefaultIntervalCategoryDataset . java <nl> ppp b / source / org / jfree / data / category / DefaultIntervalCategoryDataset . java <nl> } <nl> else { <nl> - this . seriesKeys = new Comparable [ 0 ] ; <nl> - this . categoryKeys = new Comparable [ 0 ] ; <nl> + this . seriesKeys = null ; <nl> + this . categoryKeys = null ; <nl> } <nl> } <nl> if ( categoryKeys = = null ) { <nl> throw new IllegalArgumentException ( " Null ' categoryKeys ' argument . " ) ; <nl> } <nl> - if ( categoryKeys . length ! = getCategoryCount ( ) ) { <nl> + if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { <nl> throw new IllegalArgumentException ( <nl> " The number of categories does not match the data . " ) ; <nl> } <nl> 
1<ml>Chart_9.src.patch<ml>Chart_9.src.patch<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period <nl> endIndex = endIndex - 1 ; / / so this is last item BEFORE end <nl> } <nl> - if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { <nl> + if ( endIndex < 0 ) { <nl> emptyRange = true ; <nl> } <nl> if ( emptyRange ) { <nl> 
1<ml>Chart_23.src.patch<ml>Chart_23.src.patch<ml>mmm a / source / org / jfree / chart / renderer / category / MinMaxCategoryRenderer . java <nl> ppp b / source / org / jfree / chart / renderer / category / MinMaxCategoryRenderer . java <nl> * <nl> * @ since 1 . 0 . 7 <nl> * / <nl> - public boolean equals ( Object obj ) { <nl> - if ( obj = = this ) { <nl> - return true ; <nl> - } <nl> - if ( ! ( obj instanceof MinMaxCategoryRenderer ) ) { <nl> - return false ; <nl> - } <nl> - MinMaxCategoryRenderer that = ( MinMaxCategoryRenderer ) obj ; <nl> - if ( this . plotLines ! = that . plotLines ) { <nl> - return false ; <nl> - } <nl> - if ( ! PaintUtilities . equal ( this . groupPaint , that . groupPaint ) ) { <nl> - return false ; <nl> - } <nl> - if ( ! this . groupStroke . equals ( that . groupStroke ) ) { <nl> - return false ; <nl> - } <nl> - return super . equals ( obj ) ; <nl> - } <nl> / * * <nl> * Returns an icon . <nl> 
1<ml>Chart_3.src.patch<ml>Chart_3.src.patch<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> throw new IllegalArgumentException ( " Requires start < = end . " ) ; <nl> } <nl> TimeSeries copy = ( TimeSeries ) super . clone ( ) ; <nl> - copy . minY = Double . NaN ; <nl> - copy . maxY = Double . NaN ; <nl> copy . data = new java . util . ArrayList ( ) ; <nl> if ( this . data . size ( ) > 0 ) { <nl> for ( int index = start ; index < = end ; index + + ) { <nl> 
1<ml>Chart_24.src.patch<ml>Chart_24.src.patch<ml>mmm a / source / org / jfree / chart / renderer / GrayPaintScale . java <nl> ppp b / source / org / jfree / chart / renderer / GrayPaintScale . java <nl> public Paint getPaint ( double value ) { <nl> double v = Math . max ( value , this . lowerBound ) ; <nl> v = Math . min ( v , this . upperBound ) ; <nl> - int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound <nl> + int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound <nl> - this . lowerBound ) * 255 . 0 ) ; <nl> return new Color ( g , g , g ) ; <nl> } <nl> 
1<ml>Chart_11.src.patch<ml>Chart_11.src.patch<ml>mmm a / source / org / jfree / chart / util / ShapeUtilities . java <nl> ppp b / source / org / jfree / chart / util / ShapeUtilities . java <nl> return false ; <nl> } <nl> PathIterator iterator1 = p1 . getPathIterator ( null ) ; <nl> - PathIterator iterator2 = p2 . getPathIterator ( null ) ; <nl> + PathIterator iterator2 = p1 . getPathIterator ( null ) ; <nl> double [ ] d1 = new double [ 6 ] ; <nl> double [ ] d2 = new double [ 6 ] ; <nl> boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; <nl> 
1<ml>Chart_5.src.patch<ml>Chart_5.src.patch<ml>mmm a / source / org / jfree / data / xy / XYSeries . java <nl> ppp b / source / org / jfree / data / xy / XYSeries . java <nl> if ( x = = null ) { <nl> throw new IllegalArgumentException ( " Null ' x ' argument . " ) ; <nl> } <nl> - if ( this . allowDuplicateXValues ) { <nl> - add ( x , y ) ; <nl> - return null ; <nl> - } <nl> / / if we get to here , we know that duplicate X values are not permitted <nl> XYDataItem overwritten = null ; <nl> int index = indexOf ( x ) ; <nl> - if ( index > = 0 ) { <nl> + if ( index > = 0 & & ! this . allowDuplicateXValues ) { <nl> XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; <nl> try { <nl> overwritten = ( XYDataItem ) existing . clone ( ) ; <nl> 
1<ml>Chart_17.src.patch<ml>Chart_17.src.patch<ml>mmm a / source / org / jfree / data / time / TimeSeries . java <nl> ppp b / source / org / jfree / data / time / TimeSeries . java <nl> * subclasses may differ . <nl> * / <nl> public Object clone ( ) throws CloneNotSupportedException { <nl> - TimeSeries clone = ( TimeSeries ) super . clone ( ) ; <nl> - clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; <nl> + Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; <nl> return clone ; <nl> } <nl> 
1<ml>Chart_8.src.patch<ml>Chart_8.src.patch<ml>mmm a / source / org / jfree / data / time / Week . java <nl> ppp b / source / org / jfree / data / time / Week . java <nl> * / <nl> public Week ( Date time , TimeZone zone ) { <nl> / / defer argument checking . . . <nl> - this ( time , zone , Locale . getDefault ( ) ) ; <nl> + this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; <nl> } <nl> / * * <nl> 
1<ml>Chart_22.src.patch<ml>Chart_22.src.patch<ml>mmm a / source / org / jfree / data / KeyedObjects2D . java <nl> ppp b / source / org / jfree / data / KeyedObjects2D . java <nl> throw new UnknownKeyException ( " Column key ( " + columnKey <nl> + " ) not recognised . " ) ; <nl> } <nl> + if ( row > = 0 ) { <nl> KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; <nl> - int index = rowData . getIndex ( columnKey ) ; <nl> - if ( index > = 0 ) { <nl> - return rowData . getObject ( index ) ; <nl> + return rowData . getObject ( columnKey ) ; <nl> } <nl> else { <nl> return null ; <nl> } <nl> / / 2 . check whether the column is now empty . <nl> - allNull = true ; <nl> - for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; <nl> - item + + ) { <nl> - row = ( KeyedObjects ) this . rows . get ( item ) ; <nl> - int columnIndex = row . getIndex ( columnKey ) ; <nl> - if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { <nl> - allNull = false ; <nl> - break ; <nl> - } <nl> - } <nl> - if ( allNull ) { <nl> - for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; <nl> - item + + ) { <nl> - row = ( KeyedObjects ) this . rows . get ( item ) ; <nl> - int columnIndex = row . getIndex ( columnKey ) ; <nl> - if ( columnIndex > = 0 ) { <nl> - row . removeValue ( columnIndex ) ; <nl> - } <nl> - } <nl> - this . columnKeys . remove ( columnKey ) ; <nl> - } <nl> } <nl> / * * <nl> * / <nl> public void removeRow ( Comparable rowKey ) { <nl> int index = getRowIndex ( rowKey ) ; <nl> - if ( index < 0 ) { <nl> - throw new UnknownKeyException ( " Row key ( " + rowKey <nl> - + " ) not recognised . " ) ; <nl> - } <nl> removeRow ( index ) ; <nl> } <nl> Iterator iterator = this . rows . iterator ( ) ; <nl> while ( iterator . hasNext ( ) ) { <nl> KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; <nl> - int i = rowData . getIndex ( columnKey ) ; <nl> - if ( i > = 0 ) { <nl> - rowData . removeValue ( i ) ; <nl> - } <nl> + rowData . removeValue ( columnKey ) ; <nl> } <nl> this . columnKeys . remove ( columnKey ) ; <nl> } <nl> 
1<ml>Closure_65.src.patch<ml>Closure_65.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> for ( int i = 0 ; i < s . length ( ) ; i + + ) { <nl> char c = s . charAt ( i ) ; <nl> switch ( c ) { <nl> - case ' \ 0 ' : sb . append ( " \ \ 000 " ) ; break ; <nl> + case ' \ 0 ' : sb . append ( " \ \ 0 " ) ; break ; <nl> case ' \ n ' : sb . append ( " \ \ n " ) ; break ; <nl> case ' \ r ' : sb . append ( " \ \ r " ) ; break ; <nl> case ' \ t ' : sb . append ( " \ \ t " ) ; break ; <nl> 
1<ml>Closure_71.src.patch<ml>Closure_71.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CheckAccessControls . java <nl> ppp b / src / com / google / javascript / jscomp / CheckAccessControls . java <nl> if ( objectType ! = null ) { <nl> / / Is this a normal property access , or are we trying to override <nl> / / an existing property ? <nl> - boolean isOverride = parent . getJSDocInfo ( ) ! = null & & <nl> + boolean isOverride = t . inGlobalScope ( ) & & <nl> parent . getType ( ) = = Token . ASSIGN & & <nl> parent . getFirstChild ( ) = = getprop ; <nl> 
1<ml>Closure_50.src.patch<ml>Closure_50.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeReplaceKnownMethods . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeReplaceKnownMethods . java <nl> Node right = callTarget . getNext ( ) ; <nl> if ( right ! = null ) { <nl> - if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { <nl> + if ( ! NodeUtil . isImmutableValue ( right ) ) { <nl> return n ; <nl> } <nl> } <nl> return n ; <nl> } <nl> - if ( right ! = null & & right . getType ( ) = = Token . STRING <nl> - & & " , " . equals ( right . getString ( ) ) ) { <nl> / / " , " is the default , it doesn ' t need to be explicit <nl> - n . removeChild ( right ) ; <nl> - reportCodeChange ( ) ; <nl> - } <nl> String joinString = ( right = = null ) ? " , " : NodeUtil . getStringValue ( right ) ; <nl> List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; <nl> 
1<ml>Closure_99.src.patch<ml>Closure_99.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CheckGlobalThis . java <nl> ppp b / src / com / google / javascript / jscomp / CheckGlobalThis . java <nl> JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; <nl> if ( jsDoc ! = null & & <nl> ( jsDoc . isConstructor ( ) | | <nl> - jsDoc . isInterface ( ) | | <nl> jsDoc . hasThisType ( ) | | <nl> jsDoc . isOverride ( ) ) ) { <nl> return false ; <nl> } else { <nl> / / Only traverse the right side if it ' s not an assignment to a prototype <nl> / / property or subproperty . <nl> - if ( NodeUtil . isGet ( lhs ) ) { <nl> if ( lhs . getType ( ) = = Token . GETPROP & & <nl> lhs . getLastChild ( ) . getString ( ) . equals ( " prototype " ) ) { <nl> return false ; <nl> } <nl> - Node llhs = lhs . getFirstChild ( ) ; <nl> - if ( llhs . getType ( ) = = Token . GETPROP & & <nl> - llhs . getLastChild ( ) . getString ( ) . equals ( " prototype " ) ) { <nl> + if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( " . prototype . " ) ) { <nl> return false ; <nl> } <nl> - } <nl> } <nl> } <nl> 
1<ml>Closure_44.src.patch<ml>Closure_44.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeConsumer . java <nl> ppp b / src / com / google / javascript / jscomp / CodeConsumer . java <nl> / / need space to separate . This is not pretty printing . <nl> / / For example : " return foo ; " <nl> append ( " " ) ; <nl> - } else if ( c = = ' / ' & & getLastChar ( ) = = ' / ' ) { <nl> / / Do not allow a forward slash to appear after a DIV . <nl> / / For example , <nl> / / REGEXP DIV REGEXP <nl> / / is valid and should print like <nl> / / / / / / / <nl> - append ( " " ) ; <nl> } <nl> append ( newcode ) ; <nl> 
1<ml>Closure_68.src.patch<ml>Closure_68.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> } <nl> break ; <nl> } <nl> - } <nl> token = eatTokensUntilEOL ( ) ; <nl> + } <nl> continue retry ; <nl> } <nl> } <nl> } <nl> } <nl> - restoreLookAhead ( token ) ; <nl> return reportGenericTypeSyntaxWarning ( ) ; <nl> } <nl> / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so <nl> / / just throw out TypeParameters . <nl> if ( token ! = JsDocToken . LP ) { <nl> - restoreLookAhead ( token ) ; <nl> return reportTypeSyntaxWarning ( " msg . jsdoc . missing . lp " ) ; <nl> } <nl> 
1<ml>Closure_103.src.patch<ml>Closure_103.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ControlFlowAnalysis . java <nl> ppp b / src / com / google / javascript / jscomp / ControlFlowAnalysis . java <nl> case Token . ASSIGN : <nl> case Token . INC : <nl> case Token . DEC : <nl> - case Token . INSTANCEOF : <nl> return true ; <nl> case Token . FUNCTION : <nl> return false ; <nl> mmm a / src / com / google / javascript / jscomp / DisambiguateProperties . java <nl> ppp b / src / com / google / javascript / jscomp / DisambiguateProperties . java <nl> } <nl> / / If the property does not exist on the referenced type but the original <nl> / / type is an object type , see if any subtype has the property . <nl> - if ( foundType = = null ) { <nl> - ObjectType maybeType = ObjectType . cast ( <nl> - registry . getGreatestSubtypeWithProperty ( type , field ) ) ; <nl> / / getGreatestSubtypeWithProperty does not guarantee that the property <nl> / / is defined on the returned type , it just indicates that it might be , <nl> / / so we have to double check . <nl> - if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { <nl> - foundType = maybeType ; <nl> - } <nl> - } <nl> return foundType ; <nl> } <nl> 
1<ml>Closure_12.src.patch<ml>Closure_12.src.patch<ml>mmm a / src / com / google / javascript / jscomp / MaybeReachingVariableUse . java <nl> ppp b / src / com / google / javascript / jscomp / MaybeReachingVariableUse . java <nl> } <nl> private boolean hasExceptionHandler ( Node cfgNode ) { <nl> - List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( cfgNode ) ; <nl> - for ( DiGraphEdge < Node , Branch > edge : branchEdges ) { <nl> - if ( edge . getValue ( ) = = Branch . ON_EX ) { <nl> - return true ; <nl> - } <nl> - } <nl> return false ; <nl> } <nl> 
1<ml>Closure_117.src.patch<ml>Closure_117.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeValidator . java <nl> ppp b / src / com / google / javascript / jscomp / TypeValidator . java <nl> * to an Object type , if possible . <nl> * / <nl> String getReadableJSTypeName ( Node n , boolean dereference ) { <nl> - JSType type = getJSType ( n ) ; <nl> - if ( dereference ) { <nl> - ObjectType dereferenced = type . dereference ( ) ; <nl> - if ( dereferenced ! = null ) { <nl> - type = dereferenced ; <nl> - } <nl> - } <nl> / / The best type name is the actual type name . <nl> - if ( type . isFunctionPrototypeType ( ) | | <nl> - ( type . toObjectType ( ) ! = null & & <nl> - type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { <nl> - return type . toString ( ) ; <nl> - } <nl> / / If we ' re analyzing a GETPROP , the property may be inherited by the <nl> / / prototype chain . So climb the prototype chain and find out where <nl> } <nl> } <nl> + JSType type = getJSType ( n ) ; <nl> + if ( dereference ) { <nl> + ObjectType dereferenced = type . dereference ( ) ; <nl> + if ( dereferenced ! = null ) { <nl> + type = dereferenced ; <nl> + } <nl> + } <nl> + if ( type . isFunctionPrototypeType ( ) | | <nl> + ( type . toObjectType ( ) ! = null & & <nl> + type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { <nl> + return type . toString ( ) ; <nl> + } <nl> String qualifiedName = n . getQualifiedName ( ) ; <nl> if ( qualifiedName ! = null ) { <nl> return qualifiedName ; <nl> 
1<ml>Closure_27.src.patch<ml>Closure_27.src.patch<ml>mmm a / src / com / google / javascript / rhino / IR . java <nl> ppp b / src / com / google / javascript / rhino / IR . java <nl> return block ; <nl> } <nl> - private static Node blockUnchecked ( Node stmt ) { <nl> - return new Node ( Token . BLOCK , stmt ) ; <nl> - } <nl> public static Node script ( Node . . . stmts ) { <nl> / / TODO ( johnlenz ) : finish setting up the SCRIPT node <nl> } <nl> public static Node tryFinally ( Node tryBody , Node finallyBody ) { <nl> - Preconditions . checkState ( tryBody . isBlock ( ) ) ; <nl> - Preconditions . checkState ( finallyBody . isBlock ( ) ) ; <nl> + Preconditions . checkState ( tryBody . isLabelName ( ) ) ; <nl> + Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; <nl> Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; <nl> return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; <nl> } <nl> public static Node tryCatch ( Node tryBody , Node catchNode ) { <nl> Preconditions . checkState ( tryBody . isBlock ( ) ) ; <nl> Preconditions . checkState ( catchNode . isCatch ( ) ) ; <nl> - Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; <nl> + Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; <nl> return new Node ( Token . TRY , tryBody , catchBody ) ; <nl> } <nl> 
1<ml>Closure_94.src.patch<ml>Closure_94.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> return true ; <nl> / / Binary operators are only valid if both children are valid . <nl> - case Token . ADD : <nl> case Token . BITAND : <nl> case Token . BITNOT : <nl> case Token . BITOR : <nl> case Token . BITXOR : <nl> - case Token . DIV : <nl> - case Token . EQ : <nl> - case Token . GE : <nl> - case Token . GT : <nl> - case Token . LE : <nl> - case Token . LSH : <nl> - case Token . LT : <nl> - case Token . MOD : <nl> - case Token . MUL : <nl> - case Token . NE : <nl> - case Token . RSH : <nl> - case Token . SHEQ : <nl> - case Token . SHNE : <nl> - case Token . SUB : <nl> - case Token . URSH : <nl> - return isValidDefineValue ( val . getFirstChild ( ) , defines ) <nl> - & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; <nl> / / Uniary operators are valid if the child is valid . <nl> case Token . NOT : <nl> case Token . NEG : <nl> - case Token . POS : <nl> return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; <nl> / / Names are valid if and only if they are defines themselves . <nl> 
1<ml>Closure_80.src.patch<ml>Closure_80.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> / / Inversion <nl> case Token . NOT : <nl> / / delete operator returns a boolean . <nl> - case Token . DELPROP : <nl> return true ; <nl> default : <nl> return false ; <nl> case Token . OBJECTLIT : <nl> / / Literals objects with non - literal children are allowed . <nl> return true ; <nl> - case Token . DELPROP : <nl> case Token . IN : <nl> / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? <nl> return true ; <nl> 
1<ml>Closure_49.src.patch<ml>Closure_49.src.patch<ml>mmm a / src / com / google / javascript / jscomp / MakeDeclaredNamesUnique . java <nl> ppp b / src / com / google / javascript / jscomp / MakeDeclaredNamesUnique . java <nl> renamer = nameStack . peek ( ) . forChildScope ( ) ; <nl> } <nl> + if ( declarationRoot . getType ( ) = = Token . FUNCTION ) { <nl> + for ( Node c = declarationRoot . getFirstChild ( ) . getNext ( ) . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { <nl> + String name = c . getString ( ) ; <nl> + renamer . addDeclaredName ( name ) ; <nl> + } <nl> + Node functionBody = declarationRoot . getLastChild ( ) ; <nl> + findDeclaredNames ( functionBody , null , renamer ) ; <nl> + } else <nl> if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { <nl> / / Add the block declarations <nl> findDeclaredNames ( declarationRoot , null , renamer ) ; <nl> renamer . addDeclaredName ( name ) ; <nl> } <nl> - nameStack . push ( renamer ) ; <nl> - } <nl> - break ; <nl> - case Token . LP : { <nl> - Renamer renamer = nameStack . peek ( ) . forChildScope ( ) ; <nl> / / Add the function parameters <nl> - for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { <nl> - String name = c . getString ( ) ; <nl> - renamer . addDeclaredName ( name ) ; <nl> - } <nl> / / Add the function body declarations <nl> - Node functionBody = n . getNext ( ) ; <nl> - findDeclaredNames ( functionBody , null , renamer ) ; <nl> nameStack . push ( renamer ) ; <nl> } <nl> case Token . FUNCTION : <nl> / / Remove the function body scope <nl> - nameStack . pop ( ) ; <nl> / / Remove function recursive name ( if any ) . <nl> nameStack . pop ( ) ; <nl> break ; <nl> - case Token . LP : <nl> / / Note : The parameters and function body variables live in the <nl> / / same scope , we introduce the scope when in the " shouldTraverse " <nl> / / visit of LP , but remove it when when we exit the function above . <nl> - break ; <nl> case Token . CATCH : <nl> / / Remove catch except name from the stack of names . <nl> 
1<ml>Closure_122.src.patch<ml>Closure_122.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> * Check to see if the given block comment looks like it should be JSDoc . <nl> * / <nl> private void handleBlockComment ( Comment comment ) { <nl> - Pattern p = Pattern . compile ( " ( / | ( \ n [ \ t ] * ) ) \ \ * [ \ t ] * @ [ a - zA - Z ] " ) ; <nl> - if ( p . matcher ( comment . getValue ( ) ) . find ( ) ) { <nl> + if ( comment . getValue ( ) . indexOf ( " / * @ " ) ! = - 1 | | comment . getValue ( ) . indexOf ( " \ n * @ " ) ! = - 1 ) { <nl> errorReporter . warning ( <nl> SUSPICIOUS_COMMENT_WARNING , <nl> sourceName , <nl> 
1<ml>Closure_33.src.patch<ml>Closure_33.src.patch<ml>mmm a / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java <nl> @ Override <nl> public void matchConstraint ( ObjectType constraintObj ) { <nl> / / We only want to match contraints on anonymous types . <nl> - if ( hasReferenceName ( ) ) { <nl> - return ; <nl> - } <nl> / / Handle the case where the constraint object is a record type . <nl> / / <nl> 
1<ml>Closure_56.src.patch<ml>Closure_56.src.patch<ml>mmm a / src / com / google / javascript / jscomp / SourceFile . java <nl> ppp b / src / com / google / javascript / jscomp / SourceFile . java <nl> / / If next new line cannot be found , there are two cases <nl> / / 1 . pos already reaches the end of file , then null should be returned <nl> / / 2 . otherwise , return the contents between pos and the end of file . <nl> - if ( pos > = js . length ( ) ) { <nl> return null ; <nl> - } else { <nl> - return js . substring ( pos , js . length ( ) ) ; <nl> - } <nl> } else { <nl> return js . substring ( pos , js . indexOf ( ' \ n ' , pos ) ) ; <nl> } <nl> 
1<ml>Closure_6.src.patch<ml>Closure_6.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeValidator . java <nl> ppp b / src / com / google / javascript / jscomp / TypeValidator . java <nl> JSType leftType , Node owner , String propName ) { <nl> / / The NoType check is a hack to make typedefs work OK . <nl> if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { <nl> + if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { <nl> + registerMismatch ( rightType , leftType , null ) ; <nl> + } else { <nl> / / Do not type - check interface methods , because we expect that <nl> / / they will have dummy implementations that do not match the type <nl> / / annotations . <nl> " assignment to property " + propName + " of " + <nl> getReadableJSTypeName ( owner , true ) , <nl> rightType , leftType ) ; <nl> + } <nl> return false ; <nl> } <nl> return true ; <nl> boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , <nl> JSType leftType , String msg ) { <nl> if ( ! rightType . canAssignTo ( leftType ) ) { <nl> + if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { <nl> + registerMismatch ( rightType , leftType , null ) ; <nl> + } else { <nl> mismatch ( t , n , msg , rightType , leftType ) ; <nl> + } <nl> return false ; <nl> } <nl> return true ; <nl> 
1<ml>Closure_38.src.patch<ml>Closure_38.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeConsumer . java <nl> ppp b / src / com / google / javascript / jscomp / CodeConsumer . java <nl> / / x - - 4 ( which is a syntax error ) . <nl> char prev = getLastChar ( ) ; <nl> boolean negativeZero = isNegativeZero ( x ) ; <nl> - if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { <nl> + if ( x < 0 & & prev = = ' - ' ) { <nl> add ( " " ) ; <nl> } <nl> 
1<ml>Closure_129.src.patch<ml>Closure_129.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PrepareAst . java <nl> ppp b / src / com / google / javascript / jscomp / PrepareAst . java <nl> Node first = n . getFirstChild ( ) ; <nl> / / ignore cast nodes . <nl> - while ( first . isCast ( ) ) { <nl> - first = first . getFirstChild ( ) ; <nl> - } <nl> if ( ! NodeUtil . isGet ( first ) ) { <nl> n . putBooleanProp ( Node . FREE_CALL , true ) ; <nl> 
1<ml>Closure_42.src.patch<ml>Closure_42.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> @ Override <nl> Node processForInLoop ( ForInLoop loopNode ) { <nl> - if ( loopNode . isForEach ( ) ) { <nl> - errorReporter . error ( <nl> - " unsupported language extension : for each " , <nl> - sourceName , <nl> - loopNode . getLineno ( ) , " " , 0 ) ; <nl> / / Return the bare minimum to put the AST in a valid state . <nl> - return newNode ( Token . EXPR_RESULT , Node . newNumber ( 0 ) ) ; <nl> - } <nl> return newNode ( <nl> Token . FOR , <nl> transform ( loopNode . getIterator ( ) ) , <nl> 
1<ml>Closure_19.src.patch<ml>Closure_19.src.patch<ml>mmm a / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java <nl> ppp b / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java <nl> scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; <nl> break ; <nl> - case Token . THIS : <nl> / / " this " references aren ' t currently modeled in the CFG . <nl> - break ; <nl> default : <nl> throw new IllegalArgumentException ( " Node cannot be refined . \ n " + <nl> 
1<ml>Closure_108.src.patch<ml>Closure_108.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ScopedAliases . java <nl> ppp b / src / com / google / javascript / jscomp / ScopedAliases . java <nl> private final Map < String , Var > aliases = Maps . newHashMap ( ) ; <nl> / / Also temporary and cleared for each scope . <nl> - private final Set < Node > injectedDecls = Sets . newHashSet ( ) ; <nl> / / Suppose you create an alias . <nl> / / var x = goog . x ; <nl> if ( t . getScopeDepth ( ) = = 2 ) { <nl> renameNamespaceShadows ( t ) ; <nl> - injectedDecls . clear ( ) ; <nl> aliases . clear ( ) ; <nl> forbiddenLocals . clear ( ) ; <nl> transformation = null ; <nl> } else { <nl> grandparent . addChildBefore ( newDecl , varNode ) ; <nl> } <nl> - injectedDecls . add ( newDecl . getFirstChild ( ) ) ; <nl> } <nl> / / Rewrite " var name = EXPR ; " to " var name = $ jscomp . scope . name ; " <nl> / / When we inject declarations , we duplicate jsdoc . Make sure <nl> / / we only process that jsdoc once . <nl> JSDocInfo info = n . getJSDocInfo ( ) ; <nl> - if ( info ! = null & & ! injectedDecls . contains ( n ) ) { <nl> + if ( info ! = null ) { <nl> for ( Node node : info . getTypeNodes ( ) ) { <nl> fixTypeNode ( node ) ; <nl> } <nl> 
1<ml>Closure_77.src.patch<ml>Closure_77.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> for ( int i = 0 ; i < s . length ( ) ; i + + ) { <nl> char c = s . charAt ( i ) ; <nl> switch ( c ) { <nl> - case ' \ 0 ' : sb . append ( " \ \ 0 " ) ; break ; <nl> case ' \ n ' : sb . append ( " \ \ n " ) ; break ; <nl> case ' \ r ' : sb . append ( " \ \ r " ) ; break ; <nl> case ' \ t ' : sb . append ( " \ \ t " ) ; break ; <nl> 
1<ml>Closure_92.src.patch<ml>Closure_92.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java <nl> ppp b / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java <nl> } else { <nl> / / In this case , the name was implicitly provided by two independent <nl> / / modules . We need to move this code up to a common module . <nl> - int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; <nl> + int indexOfDot = namespace . indexOf ( ' . ' ) ; <nl> if ( indexOfDot = = - 1 ) { <nl> / / Any old place is fine . <nl> compiler . getNodeForCodeInsertion ( minimumModule ) <nl> 
1<ml>Closure_21.src.patch<ml>Closure_21.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> / / Do not try to remove a block or an expr result . We already handle <nl> / / these cases when we visit the child , and the peephole passes will <nl> / / fix up the tree in more clever ways when these are removed . <nl> - if ( n . isExprResult ( ) | | n . isBlock ( ) ) { <nl> + if ( n . isExprResult ( ) ) { <nl> return ; <nl> } <nl> boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; <nl> boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; <nl> - if ( ! isResultUsed & & <nl> + if ( parent . getType ( ) = = Token . COMMA ) { <nl> + if ( isResultUsed ) { <nl> + return ; <nl> + } <nl> + if ( n = = parent . getLastChild ( ) ) { <nl> + for ( Node an : parent . getAncestors ( ) ) { <nl> + int ancestorType = an . getType ( ) ; <nl> + if ( ancestorType = = Token . COMMA ) continue ; <nl> + if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <nl> + else break ; <nl> + } <nl> + } <nl> + } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> + if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { <nl> + return ; <nl> + } <nl> + } <nl> + if ( <nl> ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { <nl> String msg = " This code lacks side - effects . Is there a bug ? " ; <nl> if ( n . isString ( ) ) { <nl> 
1<ml>Closure_130.src.patch<ml>Closure_130.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CollapseProperties . java <nl> ppp b / src / com / google / javascript / jscomp / CollapseProperties . java <nl> continue ; <nl> } <nl> - if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & <nl> + if ( name . globalSets = = 1 & & name . localSets = = 0 & & <nl> name . aliasingGets > 0 ) { <nl> / / { @ code name } meets condition ( b ) . Find all of its local aliases <nl> / / and try to inline them . <nl> 
1<ml>Closure_124.src.patch<ml>Closure_124.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ExploitAssigns . java <nl> ppp b / src / com / google / javascript / jscomp / ExploitAssigns . java <nl> } <nl> Preconditions . checkArgument ( node . isGetProp ( ) ) ; <nl> - while ( node . isGetProp ( ) ) { <nl> node = node . getFirstChild ( ) ; <nl> - } <nl> if ( node . isName ( ) <nl> & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { <nl> return false ; <nl> 
1<ml>Closure_35.src.patch<ml>Closure_35.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeInference . java <nl> ppp b / src / com / google / javascript / jscomp / TypeInference . java <nl> ObjectType constraintObj = <nl> ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; <nl> - if ( constraintObj ! = null ) { <nl> - type . matchConstraint ( constraintObj ) ; <nl> + if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { <nl> + ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; <nl> + if ( objType ! = null ) { <nl> + for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { <nl> + JSType propType = constraintObj . getPropertyType ( prop ) ; <nl> + if ( ! objType . isPropertyTypeDeclared ( prop ) ) { <nl> + JSType typeToInfer = propType ; <nl> + if ( ! objType . hasProperty ( prop ) ) { <nl> + typeToInfer = <nl> + getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; <nl> + } <nl> + objType . defineInferredProperty ( prop , typeToInfer , null ) ; <nl> + } <nl> + } <nl> + } <nl> } <nl> } <nl> 
1<ml>Closure_86.src.patch<ml>Closure_86.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> / / TODO ( nicksantos ) : This needs to be changed so that it <nl> / / returns true iff we ' re sure the value was never aliased from inside <nl> / / the constructor ( similar to callHasLocalResult ) <nl> - return false ; <nl> + return true ; <nl> case Token . FUNCTION : <nl> case Token . REGEXP : <nl> case Token . ARRAYLIT : <nl> 
1<ml>Closure_105.src.patch<ml>Closure_105.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FoldConstants . java <nl> ppp b / src / com / google / javascript / jscomp / FoldConstants . java <nl> String joinString = NodeUtil . getStringValue ( right ) ; <nl> List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; <nl> - StringBuilder sb = null ; <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> int foldedSize = 0 ; <nl> Node elem = arrayNode . getFirstChild ( ) ; <nl> / / Merges adjacent String nodes . <nl> while ( elem ! = null ) { <nl> if ( NodeUtil . isImmutableValue ( elem ) ) { <nl> - if ( sb = = null ) { <nl> - sb = new StringBuilder ( ) ; <nl> - } else { <nl> + if ( sb . length ( ) > 0 ) { <nl> sb . append ( joinString ) ; <nl> } <nl> sb . append ( NodeUtil . getStringValue ( elem ) ) ; <nl> } else { <nl> - if ( sb ! = null ) { <nl> + if ( sb . length ( ) > 0 ) { <nl> / / + 2 for the quotes . <nl> foldedSize + = sb . length ( ) + 2 ; <nl> arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; <nl> - sb = null ; <nl> + sb = new StringBuilder ( ) ; <nl> } <nl> foldedSize + = InlineCostEstimator . getCost ( elem ) ; <nl> arrayFoldedChildren . add ( elem ) ; <nl> elem = elem . getNext ( ) ; <nl> } <nl> - if ( sb ! = null ) { <nl> + if ( sb . length ( ) > 0 ) { <nl> / / + 2 for the quotes . <nl> foldedSize + = sb . length ( ) + 2 ; <nl> arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; <nl> 
1<ml>Closure_14.src.patch<ml>Closure_14.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ControlFlowAnalysis . java <nl> ppp b / src / com / google / javascript / jscomp / ControlFlowAnalysis . java <nl> } else if ( parent . getLastChild ( ) = = node ) { <nl> if ( cfa ! = null ) { <nl> for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { <nl> - cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; <nl> + cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; <nl> } <nl> } <nl> return computeFollowNode ( fromNode , parent , cfa ) ; <nl> 
1<ml>Closure_111.src.patch<ml>Closure_111.src.patch<ml>mmm a / src / com / google / javascript / jscomp / type / ClosureReverseAbstractInterpreter . java <nl> ppp b / src / com / google / javascript / jscomp / type / ClosureReverseAbstractInterpreter . java <nl> new RestrictByTrueTypeOfResultVisitor ( ) { <nl> @ Override <nl> protected JSType caseTopType ( JSType topType ) { <nl> - return topType . isAllType ( ) ? <nl> - getNativeType ( ARRAY_TYPE ) : topType ; <nl> + return topType ; <nl> } <nl> @ Override <nl> 
1<ml>Closure_70.src.patch<ml>Closure_70.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> for ( Node astParameter : astParameters . children ( ) ) { <nl> if ( jsDocParameter ! = null ) { <nl> defineSlot ( astParameter , functionNode , <nl> - jsDocParameter . getJSType ( ) , false ) ; <nl> + jsDocParameter . getJSType ( ) , true ) ; <nl> jsDocParameter = jsDocParameter . getNext ( ) ; <nl> } else { <nl> defineSlot ( astParameter , functionNode , null , true ) ; <nl> 
1<ml>Closure_64.src.patch<ml>Closure_64.src.patch<ml>mmm a / src / com / google / javascript / jscomp / Compiler . java <nl> ppp b / src / com / google / javascript / jscomp / Compiler . java <nl> / / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' <nl> / / for the first input file <nl> - String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; <nl> + String code = toSource ( root , sourceMap ) ; <nl> if ( ! code . isEmpty ( ) ) { <nl> cb . append ( code ) ; <nl> @ Override <nl> String toSource ( Node n ) { <nl> initCompilerOptionsIfTesting ( ) ; <nl> - return toSource ( n , null , true ) ; <nl> + return toSource ( n , null ) ; <nl> } <nl> / * * <nl> * Generates JavaScript source code for an AST . <nl> * / <nl> - private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { <nl> + private String toSource ( Node n , SourceMap sourceMap ) { <nl> CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; <nl> builder . setPrettyPrint ( options . prettyPrint ) ; <nl> builder . setLineBreak ( options . lineBreak ) ; <nl> builder . setSourceMap ( sourceMap ) ; <nl> builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; <nl> - builder . setTagAsStrict ( firstOutput & & <nl> + builder . setTagAsStrict ( <nl> options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; <nl> builder . setLineLengthThreshold ( options . lineLengthThreshold ) ; <nl> 
1<ml>Closure_45.src.patch<ml>Closure_45.src.patch<ml>mmm a / src / com / google / javascript / jscomp / RemoveUnusedVars . java <nl> ppp b / src / com / google / javascript / jscomp / RemoveUnusedVars . java <nl> assignedToUnknownValue = true ; <nl> } <nl> - boolean maybeEscaped = false ; <nl> for ( Assign assign : assignsByVar . get ( var ) ) { <nl> if ( assign . isPropertyAssign ) { <nl> hasPropertyAssign = true ; <nl> assign . assignNode . getLastChild ( ) , true ) ) { <nl> assignedToUnknownValue = true ; <nl> } <nl> - if ( assign . maybeAliased ) { <nl> - maybeEscaped = true ; <nl> - } <nl> } <nl> - if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { <nl> + if ( assignedToUnknownValue & & hasPropertyAssign ) { <nl> changes = markReferencedVar ( var ) | | changes ; <nl> maybeUnreferenced . remove ( current ) ; <nl> current - - ; <nl> this . nameNode = nameNode ; <nl> this . isPropertyAssign = isPropertyAssign ; <nl> - this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; <nl> + this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; <nl> this . mayHaveSecondarySideEffects = <nl> maybeAliased | | <nl> NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | | <nl> 
1<ml>Closure_1.src.patch<ml>Closure_1.src.patch<ml>mmm a / src / com / google / javascript / jscomp / RemoveUnusedVars . java <nl> ppp b / src / com / google / javascript / jscomp / RemoveUnusedVars . java <nl> / / is removing globals , then it ' s OK to remove unused function args . <nl> / / <nl> / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 <nl> - if ( ! removeGlobals ) { <nl> - return ; <nl> - } <nl> Node function = fnScope . getRootNode ( ) ; <nl> 
1<ml>Closure_51.src.patch<ml>Closure_51.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeConsumer . java <nl> ppp b / src / com / google / javascript / jscomp / CodeConsumer . java <nl> add ( " " ) ; <nl> } <nl> - if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { <nl> + if ( ( long ) x = = x ) { <nl> long value = ( long ) x ; <nl> long mantissa = value ; <nl> int exp = 0 ; <nl> 
1<ml>Closure_98.src.patch<ml>Closure_98.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java <nl> ppp b / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java <nl> } <nl> / / Make sure this assignment is not in a loop . <nl> - for ( BasicBlock block = ref . getBasicBlock ( ) ; <nl> - block ! = null ; block = block . getParent ( ) ) { <nl> - if ( block . isFunction ) { <nl> - break ; <nl> - } else if ( block . isLoop ) { <nl> - return false ; <nl> - } <nl> - } <nl> return true ; <nl> } <nl> / * * <nl> * Whether this block denotes a function scope . <nl> * / <nl> - private final boolean isFunction ; <nl> / * * <nl> * Whether this block denotes a loop . <nl> * / <nl> - private final boolean isLoop ; <nl> / * * <nl> * Creates a new block . <nl> / / only named functions may be hoisted . <nl> this . isHoisted = NodeUtil . isHoistedFunctionDeclaration ( root ) ; <nl> - this . isFunction = root . getType ( ) = = Token . FUNCTION ; <nl> - if ( root . getParent ( ) ! = null ) { <nl> - int pType = root . getParent ( ) . getType ( ) ; <nl> - this . isLoop = pType = = Token . DO | | <nl> - pType = = Token . WHILE | | <nl> - pType = = Token . FOR ; <nl> - } else { <nl> - this . isLoop = false ; <nl> - } <nl> } <nl> BasicBlock getParent ( ) { <nl> 
1<ml>Closure_116.src.patch<ml>Closure_116.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FunctionInjector . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionInjector . java <nl> Node block = fnNode . getLastChild ( ) ; <nl> - boolean hasSideEffects = false ; / / empty function case <nl> - if ( block . hasChildren ( ) ) { <nl> - Preconditions . checkState ( block . hasOneChild ( ) ) ; <nl> - Node stmt = block . getFirstChild ( ) ; <nl> - if ( stmt . isReturn ( ) ) { <nl> - hasSideEffects = NodeUtil . mayHaveSideEffects ( <nl> - stmt . getFirstChild ( ) , compiler ) ; <nl> - } <nl> - } <nl> / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] <nl> Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> - if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> - return CanInlineResult . NO ; <nl> - } <nl> / / Check for arguments that are evaluated more than once . <nl> / / Note : Unlike block inlining , there it is not possible that a <nl> 
1<ml>Closure_69.src.patch<ml>Closure_69.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> / / Functions with explcit ' this ' types must be called in a GETPROP <nl> / / or GETELEM . <nl> - if ( functionType . isOrdinaryFunction ( ) & & <nl> - ! functionType . getTypeOfThis ( ) . isUnknownType ( ) & & <nl> - ! functionType . getTypeOfThis ( ) . isNativeObjectType ( ) & & <nl> - ! ( child . getType ( ) = = Token . GETELEM | | <nl> - child . getType ( ) = = Token . GETPROP ) ) { <nl> - report ( t , n , EXPECTED_THIS_TYPE , functionType . toString ( ) ) ; <nl> - } <nl> visitParameterList ( t , n , functionType ) ; <nl> ensureTyped ( t , n , functionType . getReturnType ( ) ) ; <nl> 
1<ml>Closure_102.src.patch<ml>Closure_102.src.patch<ml>mmm a / src / com / google / javascript / jscomp / Normalize . java <nl> ppp b / src / com / google / javascript / jscomp / Normalize . java <nl> @ Override <nl> public void process ( Node externs , Node root ) { <nl> NodeTraversal . traverse ( compiler , root , this ) ; <nl> - removeDuplicateDeclarations ( root ) ; <nl> if ( MAKE_LOCAL_NAMES_UNIQUE ) { <nl> MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; <nl> NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; <nl> t . traverseRoots ( externs , root ) ; <nl> } <nl> + removeDuplicateDeclarations ( root ) ; <nl> new PropogateConstantAnnotations ( compiler , assertOnChange ) <nl> . process ( externs , root ) ; <nl> } <nl> 
1<ml>Closure_13.src.patch<ml>Closure_13.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeOptimizationsPass . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeOptimizationsPass . java <nl> do { <nl> Node c = node . getFirstChild ( ) ; <nl> while ( c ! = null ) { <nl> - Node next = c . getNext ( ) ; <nl> traverse ( c ) ; <nl> + Node next = c . getNext ( ) ; <nl> c = next ; <nl> } <nl> 
1<ml>Closure_81.src.patch<ml>Closure_81.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> Name name = functionNode . getFunctionName ( ) ; <nl> Boolean isUnnamedFunction = false ; <nl> if ( name = = null ) { <nl> - int functionType = functionNode . getFunctionType ( ) ; <nl> - if ( functionType ! = FunctionNode . FUNCTION_EXPRESSION ) { <nl> - errorReporter . error ( <nl> - " unnamed function statement " , <nl> - sourceName , <nl> - functionNode . getLineno ( ) , " " , 0 ) ; <nl> - } <nl> name = new Name ( ) ; <nl> name . setIdentifier ( " " ) ; <nl> isUnnamedFunction = true ; <nl> 
1<ml>Closure_48.src.patch<ml>Closure_48.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> | | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; <nl> } <nl> - if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { <nl> + if ( inferred ) { <nl> / / Determining declaration for # 2 <nl> - if ( info ! = null ) { <nl> - inferred = false ; <nl> - } else if ( ! scope . isDeclared ( qName , false ) & & <nl> - n . isUnscopedQualifiedName ( ) ) { <nl> - inferred = false ; <nl> - } <nl> + inferred = ! ( rhsValue ! = null & & <nl> + rhsValue . isFunction ( ) & & <nl> + ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; <nl> } <nl> if ( ! inferred ) { <nl> 
1<ml>Closure_123.src.patch<ml>Closure_123.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> case Token . HOOK : { <nl> Preconditions . checkState ( childCount = = 3 ) ; <nl> int p = NodeUtil . precedence ( type ) ; <nl> - Context rhsContext = getContextForNoInOperator ( context ) ; <nl> + Context rhsContext = Context . OTHER ; <nl> addExpr ( first , p + 1 , context ) ; <nl> cc . addOp ( " ? " , true ) ; <nl> addExpr ( first . getNext ( ) , 1 , rhsContext ) ; <nl> 
1<ml>Closure_32.src.patch<ml>Closure_32.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> / / Track the start of the line to count whitespace that <nl> / / the tokenizer skipped . Because this case is rare , it ' s easier <nl> / / to do this here than in the tokenizer . <nl> - int lineStartChar = - 1 ; <nl> do { <nl> switch ( token ) { <nl> case STAR : <nl> if ( ignoreStar ) { <nl> / / Mark the position after the star as the new start of the line . <nl> - lineStartChar = stream . getCharno ( ) + 1 ; <nl> } else { <nl> / / The star is part of the comment . <nl> if ( builder . length ( ) > 0 ) { <nl> } <nl> ignoreStar = true ; <nl> - lineStartChar = 0 ; <nl> token = next ( ) ; <nl> continue ; <nl> ignoreStar = false ; <nl> state = State . SEARCHING_ANNOTATION ; <nl> - boolean isEOC = token = = JsDocToken . EOC ; <nl> - if ( ! isEOC ) { <nl> - if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { <nl> - int numSpaces = stream . getCharno ( ) - lineStartChar ; <nl> - for ( int i = 0 ; i < numSpaces ; i + + ) { <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - lineStartChar = - 1 ; <nl> - } else if ( builder . length ( ) > 0 ) { <nl> / / All tokens must be separated by a space . <nl> - builder . append ( ' ' ) ; <nl> - } <nl> - } <nl> if ( token = = JsDocToken . EOC | | <nl> token = = JsDocToken . EOF | | <nl> return new ExtractionInfo ( multilineText , token ) ; <nl> } <nl> + if ( builder . length ( ) > 0 ) { <nl> + builder . append ( ' ' ) ; <nl> + } <nl> builder . append ( toString ( token ) ) ; <nl> line = stream . getRemainingJSDocLine ( ) ; <nl> 
1<ml>Closure_26.src.patch<ml>Closure_26.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ProcessCommonJSModules . java <nl> ppp b / src / com / google / javascript / jscomp / ProcessCommonJSModules . java <nl> AbstractPostOrderCallback { <nl> private int scriptNodeCount = 0 ; <nl> - private Set < String > modulesWithExports = Sets . newHashSet ( ) ; <nl> @ Override <nl> public void visit ( NodeTraversal t , Node n , Node parent ) { <nl> * / <nl> private void emitOptionalModuleExportsOverride ( Node script , <nl> String moduleName ) { <nl> - if ( ! modulesWithExports . contains ( moduleName ) ) { <nl> - return ; <nl> - } <nl> Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , <nl> IR . string ( " module $ exports " ) ) ; <nl> Node exports = prop . getChildAtIndex ( 1 ) ; <nl> exports . putProp ( Node . ORIGINALNAME_PROP , " exports " ) ; <nl> exports . setString ( " module $ exports " ) ; <nl> - modulesWithExports . add ( moduleName ) ; <nl> } <nl> / * * <nl> 
1<ml>Closure_95.src.patch<ml>Closure_95.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> / / scope where the root object appears . This helps out people <nl> / / who declare " global " names in an anonymous namespace . <nl> Scope scopeToDeclareIn = scope ; <nl> - if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & <nl> - isQnameRootedInGlobalScope ( n ) ) { <nl> - Scope globalScope = scope . getGlobalScope ( ) ; <nl> / / don ' t try to declare in the global scope if there ' s <nl> / / already a symbol there with this name . <nl> - if ( ! globalScope . isDeclared ( variableName , false ) ) { <nl> - scopeToDeclareIn = scope . getGlobalScope ( ) ; <nl> - } <nl> - } <nl> / / declared in closest scope ? <nl> if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) { <nl> 
1<ml>Closure_39.src.patch<ml>Closure_39.src.patch<ml>mmm a / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / PrototypeObjectType . java <nl> sb . append ( property ) ; <nl> sb . append ( " : " ) ; <nl> - sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; <nl> + sb . append ( getPropertyType ( property ) . toString ( ) ) ; <nl> + + i ; <nl> - if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { <nl> + if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { <nl> sb . append ( " , . . . " ) ; <nl> break ; <nl> } <nl> prettyPrint = true ; <nl> return sb . toString ( ) ; <nl> } else { <nl> - return forAnnotations ? " ? " : " { . . . } " ; <nl> + return " { . . . } " ; <nl> } <nl> } <nl> 
1<ml>Closure_128.src.patch<ml>Closure_128.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> static boolean isSimpleNumber ( String s ) { <nl> int len = s . length ( ) ; <nl> - if ( len = = 0 ) { <nl> - return false ; <nl> - } <nl> for ( int index = 0 ; index < len ; index + + ) { <nl> char c = s . charAt ( index ) ; <nl> if ( c < ' 0 ' | | c > ' 9 ' ) { <nl> return false ; <nl> } <nl> } <nl> - return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; <nl> + return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; <nl> } <nl> static double getSimpleNumber ( String s ) { <nl> 
1<ml>Closure_43.src.patch<ml>Closure_43.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> * For more information , see <nl> * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314 <nl> * / <nl> - private List < Node > lentObjectLiterals = null ; <nl> / * * <nl> * Type - less stubs . <nl> } <nl> / / Analyze any @ lends object literals in this statement . <nl> - if ( n . getParent ( ) ! = null & & NodeUtil . isStatement ( n ) & & <nl> - lentObjectLiterals ! = null ) { <nl> - for ( Node objLit : lentObjectLiterals ) { <nl> - defineObjectLiteral ( objLit ) ; <nl> - } <nl> - lentObjectLiterals . clear ( ) ; <nl> - } <nl> } <nl> private void attachLiteralTypes ( NodeTraversal t , Node n ) { <nl> break ; <nl> case Token . OBJECTLIT : <nl> - JSDocInfo info = n . getJSDocInfo ( ) ; <nl> - if ( info ! = null & & <nl> - info . getLendsName ( ) ! = null ) { <nl> - if ( lentObjectLiterals = = null ) { <nl> - lentObjectLiterals = Lists . newArrayList ( ) ; <nl> - } <nl> - lentObjectLiterals . add ( n ) ; <nl> - } else { <nl> defineObjectLiteral ( n ) ; <nl> - } <nl> break ; <nl> / / NOTE ( nicksantos ) : If we ever support Array tuples , <nl> 
1<ml>Closure_57.src.patch<ml>Closure_57.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ClosureCodingConvention . java <nl> ppp b / src / com / google / javascript / jscomp / ClosureCodingConvention . java <nl> String qualifiedName = callee . getQualifiedName ( ) ; <nl> if ( functionName . equals ( qualifiedName ) ) { <nl> Node target = callee . getNext ( ) ; <nl> - if ( target ! = null & & target . getType ( ) = = Token . STRING ) { <nl> + if ( target ! = null ) { <nl> className = target . getString ( ) ; <nl> } <nl> } <nl> 
1<ml>Closure_7.src.patch<ml>Closure_7.src.patch<ml>mmm a / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java <nl> ppp b / src / com / google / javascript / jscomp / type / ChainableReverseAbstractInterpreter . java <nl> public JSType caseObjectType ( ObjectType type ) { <nl> if ( value . equals ( " function " ) ) { <nl> JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; <nl> - if ( resultEqualsValue ) { <nl> + return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; <nl> / / Objects are restricted to " Function " , subtypes are left <nl> - return ctorType . getGreatestSubtype ( type ) ; <nl> - } else { <nl> / / Only filter out subtypes of " function " <nl> - return type . isSubtype ( ctorType ) ? null : type ; <nl> - } <nl> } <nl> return matchesExpectation ( " object " ) ? type : null ; <nl> } <nl> 
1<ml>Closure_76.src.patch<ml>Closure_76.src.patch<ml>mmm a / src / com / google / javascript / jscomp / DeadAssignmentsElimination . java <nl> ppp b / src / com / google / javascript / jscomp / DeadAssignmentsElimination . java <nl> / / If the currently node is the first child of <nl> / / AND / OR , be conservative only consider the READs <nl> / / of the second operand . <nl> - if ( n . getNext ( ) ! = null ) { <nl> - state = isVariableReadBeforeKill ( <nl> - n . getNext ( ) , variable ) ; <nl> - if ( state = = VariableLiveness . KILL ) { <nl> - state = VariableLiveness . MAYBE_LIVE ; <nl> - } <nl> - } <nl> - break ; <nl> case Token . HOOK : <nl> / / If current node is the condition , check each following <nl> / / branch , otherwise it is a conditional branch and the <nl> / / other branch can be ignored . <nl> - if ( n . getNext ( ) ! = null & & n . getNext ( ) . getNext ( ) ! = null ) { <nl> - state = checkHookBranchReadBeforeKill ( <nl> - n . getNext ( ) , n . getNext ( ) . getNext ( ) , variable ) ; <nl> - } <nl> - break ; <nl> default : <nl> for ( Node sibling = n . getNext ( ) ; sibling ! = null ; <nl> sibling = sibling . getNext ( ) ) { <nl> + if ( ! ControlFlowGraph . isEnteringNewCfgNode ( sibling ) ) { <nl> state = isVariableReadBeforeKill ( sibling , variable ) ; <nl> - if ( state ! = VariableLiveness . MAYBE_LIVE ) { <nl> - break ; <nl> - } <nl> - } <nl> - } <nl> / / If we see a READ or KILL there is no need to continue . <nl> if ( state = = VariableLiveness . READ ) { <nl> return true ; <nl> } else if ( state = = VariableLiveness . KILL ) { <nl> return false ; <nl> + } <nl> + } <nl> + } <nl> } <nl> n = n . getParent ( ) ; <nl> } <nl> * / <nl> private VariableLiveness isVariableReadBeforeKill ( <nl> Node n , String variable ) { <nl> - if ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) { / / Not a FUNCTION <nl> - return VariableLiveness . MAYBE_LIVE ; <nl> - } <nl> if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { <nl> if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { <nl> / / Conditionals <nl> case Token . OR : <nl> case Token . AND : <nl> - VariableLiveness v1 = isVariableReadBeforeKill ( <nl> - n . getFirstChild ( ) , variable ) ; <nl> - VariableLiveness v2 = isVariableReadBeforeKill ( <nl> - n . getLastChild ( ) , variable ) ; <nl> / / With a AND / OR the first branch always runs , but the second is <nl> / / may not . <nl> - if ( v1 ! = VariableLiveness . MAYBE_LIVE ) { <nl> - return v1 ; <nl> - } else if ( v2 = = VariableLiveness . READ ) { <nl> - return VariableLiveness . READ ; <nl> - } else { <nl> - return VariableLiveness . MAYBE_LIVE ; <nl> - } <nl> case Token . HOOK : <nl> - VariableLiveness first = isVariableReadBeforeKill ( <nl> - n . getFirstChild ( ) , variable ) ; <nl> - if ( first ! = VariableLiveness . MAYBE_LIVE ) { <nl> - return first ; <nl> - } <nl> return checkHookBranchReadBeforeKill ( <nl> n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; <nl> / / Expressions are evaluated left - right , depth first . <nl> for ( Node child = n . getFirstChild ( ) ; <nl> child ! = null ; child = child . getNext ( ) ) { <nl> + if ( ! ControlFlowGraph . isEnteringNewCfgNode ( child ) ) { / / Not a FUNCTION <nl> VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; <nl> if ( state ! = VariableLiveness . MAYBE_LIVE ) { <nl> return state ; <nl> } <nl> } <nl> + } <nl> } <nl> return VariableLiveness . MAYBE_LIVE ; <nl> 
1<ml>Closure_18.src.patch<ml>Closure_18.src.patch<ml>mmm a / src / com / google / javascript / jscomp / Compiler . java <nl> ppp b / src / com / google / javascript / jscomp / Compiler . java <nl> / / Check if the sources need to be re - ordered . <nl> boolean staleInputs = false ; <nl> - if ( options . dependencyOptions . needsManagement ( ) ) { <nl> + if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { <nl> for ( CompilerInput input : inputs ) { <nl> / / Forward - declare all the provided types , so that they <nl> / / are not flagged even if they are dropped from the process . <nl> 
1<ml>Closure_109.src.patch<ml>Closure_109.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> * For expressions on the right hand side of a this : or new : <nl> * / <nl> private Node parseContextTypeExpression ( JsDocToken token ) { <nl> - if ( token = = JsDocToken . QMARK ) { <nl> - return newNode ( Token . QMARK ) ; <nl> - } else { <nl> - return parseBasicTypeExpression ( token ) ; <nl> - } <nl> + return parseTypeName ( token ) ; <nl> } <nl> / * * <nl> 
1<ml>Closure_125.src.patch<ml>Closure_125.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; <nl> if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { <nl> FunctionType fnType = type . toMaybeFunctionType ( ) ; <nl> - if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { <nl> + if ( fnType ! = null ) { <nl> visitParameterList ( t , n , fnType ) ; <nl> ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; <nl> } else { <nl> 
1<ml>Closure_34.src.patch<ml>Closure_34.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> cc . addOp ( opstr , true ) ; <nl> addExpr ( last , p , rhsContext ) ; <nl> } else { <nl> - unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; <nl> + addExpr ( first , p , context ) ; <nl> + cc . addOp ( opstr , true ) ; <nl> + addExpr ( last , p + 1 , rhsContext ) ; <nl> } <nl> return ; <nl> } <nl> Node current = firstNonOperator ; <nl> do { <nl> current = current . getParent ( ) ; <nl> - cc . addOp ( opStr , true ) ; <nl> + cc . listSeparator ( ) ; <nl> addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; <nl> } while ( current ! = n ) ; <nl> } <nl> mmm a / src / com / google / javascript / jscomp / CodePrinter . java <nl> ppp b / src / com / google / javascript / jscomp / CodePrinter . java <nl> @ Override <nl> void appendOp ( String op , boolean binOp ) { <nl> if ( binOp ) { <nl> - if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { <nl> + if ( getLastChar ( ) ! = ' ' ) { <nl> append ( " " ) ; <nl> } <nl> append ( op ) ; <nl> 
1<ml>Closure_87.src.patch<ml>Closure_87.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeSubstituteAlternateSyntax . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeSubstituteAlternateSyntax . java <nl> if ( n . getType ( ) = = Token . BLOCK ) { <nl> if ( n . hasOneChild ( ) ) { <nl> Node maybeExpr = n . getFirstChild ( ) ; <nl> - if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { <nl> / / IE has a bug where event handlers behave differently when <nl> / / their return value is used vs . when their return value is in <nl> / / an EXPR_RESULT . It ' s pretty freaking weird . See : <nl> / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 <nl> / / We try to detect this case , and not fold EXPR_RESULTs <nl> / / into other expressions . <nl> - if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { <nl> - Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; <nl> / / We only have to worry about methods with an implicit ' this ' <nl> / / param , or this doesn ' t happen . <nl> - if ( calledFn . getType ( ) = = Token . GETELEM ) { <nl> - return false ; <nl> - } else if ( calledFn . getType ( ) = = Token . GETPROP & & <nl> - calledFn . getLastChild ( ) . getString ( ) . startsWith ( " on " ) ) { <nl> - return false ; <nl> - } <nl> - } <nl> - return true ; <nl> - } <nl> - return false ; <nl> + return NodeUtil . isExpressionNode ( maybeExpr ) ; <nl> } <nl> } <nl> 
1<ml>Closure_20.src.patch<ml>Closure_20.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeSubstituteAlternateSyntax . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeSubstituteAlternateSyntax . java <nl> / / slightly different semantics than ' ' + ( a ) . See <nl> / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 <nl> Node value = callTarget . getNext ( ) ; <nl> - if ( value ! = null & & value . getNext ( ) = = null & & <nl> - NodeUtil . isImmutableValue ( value ) ) { <nl> + if ( value ! = null ) { <nl> Node addition = IR . add ( <nl> IR . string ( " " ) . srcref ( callTarget ) , <nl> value . detachFromParent ( ) ) ; <nl> 
1<ml>Closure_131.src.patch<ml>Closure_131.src.patch<ml>mmm a / src / com / google / javascript / rhino / TokenStream . java <nl> ppp b / src / com / google / javascript / rhino / TokenStream . java <nl> int length = s . length ( ) ; <nl> if ( length = = 0 | | <nl> - Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | <nl> ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { <nl> return false ; <nl> } <nl> for ( int i = 1 ; i < length ; i + + ) { <nl> - if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | <nl> + if ( <nl> ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { <nl> return false ; <nl> } <nl> 
1<ml>Closure_110.src.patch<ml>Closure_110.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ScopedAliases . java <nl> ppp b / src / com / google / javascript / jscomp / ScopedAliases . java <nl> Node n = v . getNode ( ) ; <nl> Node parent = n . getParent ( ) ; <nl> boolean isVar = parent . isVar ( ) ; <nl> - boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; <nl> if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { <nl> recordAlias ( v ) ; <nl> } else if ( v . isBleedingFunction ( ) ) { <nl> } else if ( parent . getType ( ) = = Token . LP ) { <nl> / / Parameters of the scope function also get a BAD_PARAMETERS <nl> / / error . <nl> - } else if ( isVar | | isFunctionDecl ) { <nl> - boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; <nl> + } else if ( isVar ) { <nl> Node grandparent = parent . getParent ( ) ; <nl> - Node value = v . getInitialValue ( ) ! = null ? <nl> - v . getInitialValue ( ) : <nl> + Node value = n . hasChildren ( ) ? <nl> + v . getInitialValue ( ) . detachFromParent ( ) : <nl> null ; <nl> - Node varNode = null ; <nl> + Node varNode = parent ; <nl> String name = n . getString ( ) ; <nl> int nameCount = scopedAliasNames . count ( name ) ; <nl> / / First , we need to free up the function expression ( EXPR ) <nl> / / to be used in another expression . <nl> - if ( isFunctionDecl ) { <nl> / / Replace " function NAME ( ) { . . . } " with " var NAME ; " . <nl> - Node existingName = v . getNameNode ( ) ; <nl> / / We can ' t keep the local name on the function expression , <nl> / / because IE is buggy and will leak the name into the global <nl> / / <nl> / / This will only cause problems if this is a hoisted , recursive <nl> / / function , and the programmer is using the hoisting . <nl> - Node newName = IR . name ( " " ) . useSourceInfoFrom ( existingName ) ; <nl> - value . replaceChild ( existingName , newName ) ; <nl> - varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; <nl> - grandparent . replaceChild ( parent , varNode ) ; <nl> - } else { <nl> - if ( value ! = null ) { <nl> / / If this is a VAR , we can just detach the expression and <nl> / / the tree will still be valid . <nl> - value . detachFromParent ( ) ; <nl> - } <nl> - varNode = parent ; <nl> - } <nl> / / Add $ jscomp . scope . name = EXPR ; <nl> / / Make sure we copy over all the jsdoc and debug info . <nl> NodeUtil . setDebugInformation ( <nl> newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; <nl> - if ( isHoisted ) { <nl> - grandparent . addChildToFront ( newDecl ) ; <nl> - } else { <nl> grandparent . addChildBefore ( newDecl , varNode ) ; <nl> - } <nl> } <nl> / / Rewrite " var name = EXPR ; " to " var name = $ jscomp . scope . name ; " <nl> mmm a / src / com / google / javascript / rhino / Node . java <nl> ppp b / src / com / google / javascript / rhino / Node . java <nl> return null ; <nl> } <nl> Node n = first ; <nl> - if ( n = = null ) { <nl> - throw new RuntimeException ( " node is not a child " ) ; <nl> - } <nl> while ( n . next ! = child ) { <nl> n = n . next ; <nl> 
1<ml>Closure_104.src.patch<ml>Closure_104.src.patch<ml>mmm a / src / com / google / javascript / rhino / jstype / UnionType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / UnionType . java <nl> builder . addAlternate ( that ) ; <nl> } <nl> JSType result = builder . build ( ) ; <nl> - if ( ! result . isNoType ( ) ) { <nl> + if ( result ! = null ) { <nl> return result ; <nl> } else if ( this . isObject ( ) & & that . isObject ( ) ) { <nl> return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ; <nl> 
1<ml>Closure_15.src.patch<ml>Closure_15.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> ppp b / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> return true ; <nl> } <nl> - if ( n . isDelProp ( ) ) { <nl> - return true ; <nl> - } <nl> for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { <nl> if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { <nl> 
1<ml>Closure_28.src.patch<ml>Closure_28.src.patch<ml>mmm a / src / com / google / javascript / jscomp / InlineCostEstimator . java <nl> ppp b / src / com / google / javascript / jscomp / InlineCostEstimator . java <nl> * Constants ( true , false , null ) are considered basically free , <nl> * because it ' s likely that they will get folded when we ' re done . <nl> * / <nl> - @ Override <nl> - void addConstant ( String newcode ) { <nl> - add ( " 0 " ) ; <nl> - } <nl> } <nl> } <nl> 
1<ml>Closure_2.src.patch<ml>Closure_2.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> ObjectType interfaceType ) { <nl> ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; <nl> Set < String > currentPropertyNames ; <nl> - if ( implicitProto = = null ) { <nl> / / This can be the case if interfaceType is proxy to a non - existent <nl> / / object ( which is a bad type annotation , but shouldn ' t crash ) . <nl> - currentPropertyNames = ImmutableSet . of ( ) ; <nl> - } else { <nl> currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; <nl> - } <nl> for ( String name : currentPropertyNames ) { <nl> ObjectType oType = properties . get ( name ) ; <nl> if ( oType ! = null ) { <nl> 
1<ml>Closure_52.src.patch<ml>Closure_52.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CodeGenerator . java <nl> ppp b / src / com / google / javascript / jscomp / CodeGenerator . java <nl> return false ; <nl> } <nl> } <nl> - return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; <nl> + return len > 0 ; <nl> } <nl> static double getSimpleNumber ( String s ) { <nl> 
1<ml>Closure_46.src.patch<ml>Closure_46.src.patch<ml>mmm a / src / com / google / javascript / rhino / jstype / RecordType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / RecordType . java <nl> propertyNode ) ; <nl> } <nl> + @ Override <nl> + public JSType getLeastSupertype ( JSType that ) { <nl> + if ( ! that . isRecordType ( ) ) { <nl> + return super . getLeastSupertype ( that ) ; <nl> + } <nl> + RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; <nl> + for ( String property : properties . keySet ( ) ) { <nl> + if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & <nl> + that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( <nl> + getPropertyType ( property ) ) ) { <nl> + builder . addProperty ( property , getPropertyType ( property ) , <nl> + getPropertyNode ( property ) ) ; <nl> + } <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> JSType getGreatestSubtypeHelper ( JSType that ) { <nl> if ( that . isRecordType ( ) ) { <nl> RecordType thatRecord = that . toMaybeRecordType ( ) ; <nl> 
1<ml>Closure_67.src.patch<ml>Closure_67.src.patch<ml>mmm a / src / com / google / javascript / jscomp / AnalyzePrototypeProperties . java <nl> ppp b / src / com / google / javascript / jscomp / AnalyzePrototypeProperties . java <nl> Node n = assign . getFirstChild ( ) ; <nl> if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) <nl> & & n . getType ( ) = = Token . GETPROP <nl> - & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { <nl> + ) { <nl> / / We want to exclude the assignment itself from the usage list <nl> boolean isChainedProperty = <nl> n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ; <nl> 
1<ml>Closure_118.src.patch<ml>Closure_118.src.patch<ml>mmm a / src / com / google / javascript / jscomp / DisambiguateProperties . java <nl> ppp b / src / com / google / javascript / jscomp / DisambiguateProperties . java <nl> child ! = null ; <nl> child = child . getNext ( ) ) { <nl> / / Maybe STRING , GET , SET <nl> - if ( child . isQuotedString ( ) ) { <nl> - continue ; <nl> - } <nl> / / We should never see a mix of numbers and strings . <nl> String name = child . getString ( ) ; <nl> 
1<ml>Closure_25.src.patch<ml>Closure_25.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeInference . java <nl> ppp b / src / com / google / javascript / jscomp / TypeInference . java <nl> } <nl> private FlowScope traverseNew ( Node n , FlowScope scope ) { <nl> - scope = traverseChildren ( n , scope ) ; <nl> Node constructor = n . getFirstChild ( ) ; <nl> + scope = traverse ( constructor , scope ) ; <nl> JSType constructorType = constructor . getJSType ( ) ; <nl> JSType type = null ; <nl> if ( constructorType ! = null ) { <nl> } <nl> if ( ct ! = null & & ct . isConstructor ( ) ) { <nl> type = ct . getInstanceType ( ) ; <nl> - backwardsInferenceFromCallSite ( n , ct ) ; <nl> } <nl> } <nl> } <nl> n . setJSType ( type ) ; <nl> + for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { <nl> + scope = traverse ( arg , scope ) ; <nl> + } <nl> return scope ; <nl> } <nl> 
1<ml>Closure_96.src.patch<ml>Closure_96.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> Node parameter = null ; <nl> Node argument = null ; <nl> while ( arguments . hasNext ( ) & & <nl> - ( parameters . hasNext ( ) | | <nl> - parameter ! = null & & parameter . isVarArgs ( ) ) ) { <nl> + parameters . hasNext ( ) ) { <nl> / / If there are no parameters left in the list , then the while loop <nl> / / above implies that this must be a var_args function . <nl> - if ( parameters . hasNext ( ) ) { <nl> parameter = parameters . next ( ) ; <nl> - } <nl> argument = arguments . next ( ) ; <nl> ordinal + + ; <nl> 
1<ml>Closure_82.src.patch<ml>Closure_82.src.patch<ml>mmm a / src / com / google / javascript / rhino / jstype / JSType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / JSType . java <nl> } <nl> public final boolean isEmptyType ( ) { <nl> - return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | <nl> - ( registry . getNativeFunctionType ( <nl> - JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; <nl> + return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; <nl> } <nl> public boolean isNumberObjectType ( ) { <nl> 
1<ml>Closure_31.src.patch<ml>Closure_31.src.patch<ml>mmm a / src / com / google / javascript / jscomp / Compiler . java <nl> ppp b / src / com / google / javascript / jscomp / Compiler . java <nl> / / Check if the sources need to be re - ordered . <nl> if ( options . dependencyOptions . needsManagement ( ) & & <nl> + ! options . skipAllPasses & & <nl> options . closurePass ) { <nl> for ( CompilerInput input : inputs ) { <nl> / / Forward - declare all the provided types , so that they <nl> 
1<ml>Closure_120.src.patch<ml>Closure_120.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java <nl> ppp b / src / com / google / javascript / jscomp / ReferenceCollectingCallback . java <nl> for ( BasicBlock block = ref . getBasicBlock ( ) ; <nl> block ! = null ; block = block . getParent ( ) ) { <nl> if ( block . isFunction ) { <nl> - if ( ref . getSymbol ( ) . getScope ( ) ! = ref . scope ) { <nl> - return false ; <nl> - } <nl> break ; <nl> } else if ( block . isLoop ) { <nl> return false ; <nl> 
1<ml>Closure_10.src.patch<ml>Closure_10.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> static boolean mayBeString ( Node n , boolean recurse ) { <nl> if ( recurse ) { <nl> - return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; <nl> + return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; <nl> } else { <nl> return mayBeStringHelper ( n ) ; <nl> } <nl> 
1<ml>Closure_101.src.patch<ml>Closure_101.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> ppp b / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> for ( FormattingOption formattingOption : flags . formatting ) { <nl> formattingOption . applyToOptions ( options ) ; <nl> } <nl> + if ( flags . process_closure_primitives ) { <nl> + options . closurePass = true ; <nl> + } <nl> - options . closurePass = flags . process_closure_primitives ; <nl> initOptionsFromFlags ( options ) ; <nl> return options ; <nl> } <nl> 
1<ml>Closure_115.src.patch<ml>Closure_115.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FunctionInjector . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionInjector . java <nl> Node block = fnNode . getLastChild ( ) ; <nl> + boolean hasSideEffects = false ; <nl> + if ( block . hasChildren ( ) ) { <nl> + Preconditions . checkState ( block . hasOneChild ( ) ) ; <nl> + Node stmt = block . getFirstChild ( ) ; <nl> + if ( stmt . isReturn ( ) ) { <nl> + hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; <nl> + } <nl> + } <nl> / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] <nl> Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; <nl> / / For each named parameter check if a mutable argument use more than one . <nl> if ( fnParam ! = null ) { <nl> if ( cArg ! = null ) { <nl> + if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { <nl> + return CanInlineResult . NO ; <nl> + } <nl> / / Check for arguments that are evaluated more than once . <nl> / / Note : Unlike block inlining , there it is not possible that a <nl> / / parameter reference will be in a loop . <nl> 
1<ml>Closure_61.src.patch<ml>Closure_61.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> } <nl> / / Functions in the " Math " namespace have no side effects . <nl> - if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { <nl> - String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; <nl> - if ( namespaceName . equals ( " Math " ) ) { <nl> - return false ; <nl> - } <nl> - } <nl> if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { <nl> if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP <nl> 
1<ml>Closure_75.src.patch<ml>Closure_75.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> } <nl> static Double getStringNumberValue ( String rawJsString ) { <nl> - if ( rawJsString . contains ( " \ u000b " ) ) { <nl> / / vertical tab is not always whitespace <nl> - return null ; <nl> - } <nl> String s = trimJsWhiteSpace ( rawJsString ) ; <nl> / / return ScriptRuntime . toNumber ( s ) ; <nl> static TernaryValue isStrWhiteSpaceChar ( int c ) { <nl> switch ( c ) { <nl> case ' \ u000B ' : / / < VT > <nl> - return TernaryValue . UNKNOWN ; / / IE says " no " , EcmaScript says " yes " <nl> + return TernaryValue . TRUE ; <nl> case ' ' : / / < SP > <nl> case ' \ n ' : / / < LF > <nl> case ' \ r ' : / / < CR > <nl> 
1<ml>Closure_54.src.patch<ml>Closure_54.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> / / then they are responsible for making sure that the object literal ' s <nl> / / implicit prototype is set up appropriately . We just obey <nl> / / the @ extends tag . <nl> - ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; <nl> - if ( qVarType ! = null & & <nl> - rhsValue ! = null & & <nl> - rhsValue . getType ( ) = = Token . OBJECTLIT ) { <nl> - typeRegistry . resetImplicitPrototype ( <nl> - rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; <nl> - } else if ( ! qVar . isTypeInferred ( ) ) { <nl> + if ( ! qVar . isTypeInferred ( ) ) { <nl> / / If the programmer has declared that F inherits from Super , <nl> / / and they assign F . prototype to some arbitrary expression , <nl> / / there ' s not much we can do . We just ignore the expression , <nl> mmm a / src / com / google / javascript / rhino / jstype / FunctionType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / FunctionType . java <nl> / / <nl> / / In the second case , we just use the anonymous object as the prototype . <nl> if ( baseType . hasReferenceName ( ) | | <nl> + baseType . isUnknownType ( ) | | <nl> isNativeObjectType ( ) | | <nl> baseType . isFunctionPrototypeType ( ) | | <nl> ! ( baseType instanceof PrototypeObjectType ) ) { <nl> return false ; <nl> } <nl> - PrototypeObjectType oldPrototype = this . prototype ; <nl> - boolean replacedPrototype = oldPrototype ! = null ; <nl> + boolean replacedPrototype = prototype ! = null ; <nl> this . prototype = prototype ; <nl> this . prototypeSlot = new SimpleSlot ( " prototype " , prototype , true ) ; <nl> this . prototype . setOwnerFunction ( this ) ; <nl> - if ( oldPrototype ! = null ) { <nl> / / Disassociating the old prototype makes this easier to debug - - <nl> / / we don ' t have to worry about two prototypes running around . <nl> - oldPrototype . setOwnerFunction ( null ) ; <nl> - } <nl> if ( isConstructor ( ) | | isInterface ( ) ) { <nl> FunctionType superClass = getSuperClassConstructor ( ) ; <nl> 
1<ml>Closure_4.src.patch<ml>Closure_4.src.patch<ml>mmm a / src / com / google / javascript / rhino / jstype / NamedType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / NamedType . java <nl> / / makes more sense . Now , resolution via registry is first in order to <nl> / / avoid triggering the warnings built into the resolution via properties . <nl> boolean resolved = resolveViaRegistry ( t , enclosing ) ; <nl> - if ( detectInheritanceCycle ( ) ) { <nl> + if ( detectImplicitPrototypeCycle ( ) ) { <nl> handleTypeCycle ( t ) ; <nl> } <nl> } <nl> resolveViaProperties ( t , enclosing ) ; <nl> - if ( detectInheritanceCycle ( ) ) { <nl> + if ( detectImplicitPrototypeCycle ( ) ) { <nl> handleTypeCycle ( t ) ; <nl> } <nl> 
1<ml>Closure_40.src.patch<ml>Closure_40.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NameAnalyzer . java <nl> ppp b / src / com / google / javascript / jscomp / NameAnalyzer . java <nl> Node nameNode = n . getFirstChild ( ) ; <nl> NameInformation ns = createNameInformation ( t , nameNode , n ) ; <nl> if ( ns ! = null & & ns . onlyAffectsClassDef ) { <nl> - JsName name = getName ( ns . name , true ) ; <nl> + JsName name = getName ( ns . name , false ) ; <nl> + if ( name ! = null ) { <nl> refNodes . add ( new ClassDefiningFunctionNode ( <nl> name , n , parent , parent . getParent ( ) ) ) ; <nl> + } <nl> } <nl> } <nl> } <nl> 
1<ml>Closure_89.src.patch<ml>Closure_89.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CollapseProperties . java <nl> ppp b / src / com / google / javascript / jscomp / CollapseProperties . java <nl> Node greatGramps = gramps . getParent ( ) ; <nl> Node greatGreatGramps = greatGramps . getParent ( ) ; <nl> - if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { <nl> - checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; <nl> - } <nl> / / Create the new alias node . <nl> Node nameNode = NodeUtil . newName ( <nl> mmm a / src / com / google / javascript / jscomp / GlobalNamespace . java <nl> ppp b / src / com / google / javascript / jscomp / GlobalNamespace . java <nl> } <nl> / / If this is aliased , then its properties can ' t be collapsed either . <nl> - if ( aliasingGets > 0 ) { <nl> + if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { <nl> return false ; <nl> } <nl> 
1<ml>Closure_16.src.patch<ml>Closure_16.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ScopedAliases . java <nl> ppp b / src / com / google / javascript / jscomp / ScopedAliases . java <nl> private class AliasedTypeNode implements AliasUsage { <nl> private final Node typeReference ; <nl> - private final Node aliasDefinition ; <nl> private final String aliasName ; <nl> - AliasedTypeNode ( Node typeReference , Node aliasDefinition , <nl> + AliasedTypeNode ( Node typeReference , <nl> String aliasName ) { <nl> this . typeReference = typeReference ; <nl> - this . aliasDefinition = aliasDefinition ; <nl> this . aliasName = aliasName ; <nl> } <nl> @ Override <nl> public void applyAlias ( ) { <nl> - String typeName = typeReference . getString ( ) ; <nl> - String aliasExpanded = <nl> - Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; <nl> - Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; <nl> - typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; <nl> + typeReference . setString ( aliasName ) ; <nl> } <nl> } <nl> Var aliasVar = aliases . get ( baseName ) ; <nl> if ( aliasVar ! = null ) { <nl> Node aliasedNode = aliasVar . getInitialValue ( ) ; <nl> - aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; <nl> + aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; <nl> } <nl> } <nl> 
1<ml>Closure_107.src.patch<ml>Closure_107.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> ppp b / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> / / so we might as well inline it . But shut off the i18n warnings , <nl> / / because the user didn ' t really ask for i18n . <nl> options . messageBundle = new EmptyMessageBundle ( ) ; <nl> - options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; <nl> } <nl> return options ; <nl> 
1<ml>Closure_78.src.patch<ml>Closure_78.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> break ; <nl> case Token . MOD : <nl> if ( rval = = 0 ) { <nl> + error ( DiagnosticType . error ( " JSC_DIVIDE_BY_0_ERROR " , " Divide by 0 " ) , right ) ; <nl> return null ; <nl> } <nl> result = lval % rval ; <nl> break ; <nl> case Token . DIV : <nl> if ( rval = = 0 ) { <nl> + error ( DiagnosticType . error ( " JSC_DIVIDE_BY_0_ERROR " , " Divide by 0 " ) , right ) ; <nl> return null ; <nl> } <nl> result = lval / rval ; <nl> 
1<ml>Closure_113.src.patch<ml>Closure_113.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java <nl> ppp b / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java <nl> / / the checks for broken requires turned off . In these cases , we <nl> / / allow broken requires to be preserved by the first run to <nl> / / let them be caught in the subsequent run . <nl> - if ( provided ! = null | | requiresLevel . isOn ( ) ) { <nl> + if ( provided ! = null ) { <nl> parent . detachFromParent ( ) ; <nl> compiler . reportCodeChange ( ) ; <nl> } <nl> 
1<ml>Closure_90.src.patch<ml>Closure_90.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FunctionTypeBuilder . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionTypeBuilder . java <nl> / / create interfaces JSType , ObjectType , FunctionType etc and have <nl> / / separate implementation instead of the class hierarchy , so that <nl> / / union types can also be object types , etc . <nl> - if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( <nl> + if ( ! type . isSubtype ( <nl> typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { <nl> reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; <nl> return false ; <nl> mmm a / src / com / google / javascript / rhino / jstype / FunctionType . java <nl> ppp b / src / com / google / javascript / rhino / jstype / FunctionType . java <nl> / / mean " nullable Foo " . For certain tags ( like @ extends ) we de - nullify <nl> / / the name for them . <nl> JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; <nl> - if ( maybeTypeOfThis ! = null ) { <nl> - maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; <nl> - } <nl> if ( maybeTypeOfThis instanceof ObjectType ) { <nl> typeOfThis = ( ObjectType ) maybeTypeOfThis ; <nl> } <nl> 
1<ml>Closure_59.src.patch<ml>Closure_59.src.patch<ml>mmm a / src / com / google / javascript / jscomp / Compiler . java <nl> ppp b / src / com / google / javascript / jscomp / Compiler . java <nl> CheckLevel . OFF ) ; <nl> } <nl> - if ( options . checkGlobalThisLevel . isOn ( ) & & <nl> - ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { <nl> + if ( options . checkGlobalThisLevel . isOn ( ) ) { <nl> options . setWarningLevel ( <nl> DiagnosticGroups . GLOBAL_THIS , <nl> options . checkGlobalThisLevel ) ; <nl> 
1<ml>Closure_132.src.patch<ml>Closure_132.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeSubstituteAlternateSyntax . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeSubstituteAlternateSyntax . java <nl> / / evaluates LHS before cond ] <nl> / / NOTE - there are some circumstances where we can <nl> / / proceed even if there are side effects . . . <nl> - ! mayEffectMutableState ( lhs ) & & <nl> - ( ! mayHaveSideEffects ( cond ) | | <nl> - ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { <nl> + ! mayEffectMutableState ( lhs ) ) { <nl> n . removeChild ( cond ) ; <nl> Node assignName = thenOp . removeFirstChild ( ) ; <nl> 
1<ml>Closure_9.src.patch<ml>Closure_9.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ProcessCommonJSModules . java <nl> ppp b / src / com / google / javascript / jscomp / ProcessCommonJSModules . java <nl> private String normalizeSourceName ( String filename ) { <nl> / / The DOS command shell will normalize " / " to " \ " , so we have to <nl> / / wrestle it back . <nl> - filename = filename . replace ( " \ \ " , " / " ) ; <nl> if ( filename . indexOf ( filenamePrefix ) = = 0 ) { <nl> filename = filename . substring ( filenamePrefix . length ( ) ) ; <nl> Preconditions . checkArgument ( scriptNodeCount = = 1 , <nl> " ProcessCommonJSModules supports only one invocation per " + <nl> " CompilerInput / script node " ) ; <nl> - String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; <nl> + String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; <nl> script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) <nl> . copyInformationFromForTree ( script ) ) ; <nl> if ( reportDependencies ) { <nl> 
1<ml>Closure_23.src.patch<ml>Closure_23.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> Node current = left . getFirstChild ( ) ; <nl> Node elem = null ; <nl> - for ( int i = 0 ; current ! = null ; i + + ) { <nl> - if ( i ! = intIndex ) { <nl> - if ( mayHaveSideEffects ( current ) ) { <nl> - return n ; <nl> - } <nl> - } else { <nl> + for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { <nl> elem = current ; <nl> - } <nl> current = current . getNext ( ) ; <nl> } <nl> 
1<ml>Closure_37.src.patch<ml>Closure_37.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeTraversal . java <nl> ppp b / src / com / google / javascript / jscomp / NodeTraversal . java <nl> / / Body <nl> Preconditions . checkState ( body . getNext ( ) = = null & & <nl> - body . isBlock ( ) , body ) ; <nl> + body . isBlock ( ) ) ; <nl> traverseBranch ( body , n ) ; <nl> popScope ( ) ; <nl> mmm a / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> node . addChildToBack ( lp ) ; <nl> Node bodyNode = transform ( functionNode . getBody ( ) ) ; <nl> - if ( ! bodyNode . isBlock ( ) ) { <nl> / / When in ideMode Rhino tries to parse some constructs the compiler <nl> / / doesn ' t support , repair it here . see Rhino ' s <nl> / / Parser # parseFunctionBodyExpr . <nl> - Preconditions . checkState ( config . isIdeMode ) ; <nl> - bodyNode = IR . block ( ) ; <nl> - } <nl> parseDirectives ( bodyNode ) ; <nl> node . addChildToBack ( bodyNode ) ; <nl> return node ; <nl> 
1<ml>Closure_126.src.patch<ml>Closure_126.src.patch<ml>mmm a / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> ppp b / src / com / google / javascript / jscomp / MinimizeExitPoints . java <nl> * can cause problems if it changes the completion type of the finally <nl> * block . See ECMA 262 Sections 8 . 9 & 12 . 14 <nl> * / <nl> + if ( NodeUtil . hasFinally ( n ) ) { <nl> + Node finallyBlock = n . getLastChild ( ) ; <nl> + tryMinimizeExits ( finallyBlock , exitType , labelName ) ; <nl> + } <nl> } <nl> / / Just a ' label ' . <nl> 
1<ml>Closure_84.src.patch<ml>Closure_84.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / IRFactory . java <nl> @ Override <nl> Node processAssignment ( Assignment assignmentNode ) { <nl> Node assign = processInfixExpression ( assignmentNode ) ; <nl> - Node target = assign . getFirstChild ( ) ; <nl> - if ( ! validAssignmentTarget ( target ) ) { <nl> - errorReporter . error ( <nl> - " invalid assignment target " , <nl> - sourceName , <nl> - target . getLineno ( ) , " " , 0 ) ; <nl> - } <nl> return assign ; <nl> } <nl> operand . setDouble ( - operand . getDouble ( ) ) ; <nl> return operand ; <nl> } else { <nl> - if ( type = = Token . INC | | type = = Token . DEC ) { <nl> - if ( ! validAssignmentTarget ( operand ) ) { <nl> - String msg = ( type = = Token . INC ) <nl> - ? " invalid increment target " <nl> - : " invalid decrement target " ; <nl> - errorReporter . error ( <nl> - msg , <nl> - sourceName , <nl> - operand . getLineno ( ) , " " , 0 ) ; <nl> - } <nl> - } <nl> Node node = newNode ( type , operand ) ; <nl> if ( exprNode . isPostfix ( ) ) { <nl> } <nl> } <nl> - private boolean validAssignmentTarget ( Node target ) { <nl> - switch ( target . getType ( ) ) { <nl> - case Token . NAME : <nl> - case Token . GETPROP : <nl> - case Token . GETELEM : <nl> - return true ; <nl> - } <nl> - return false ; <nl> - } <nl> @ Override <nl> Node processVariableDeclaration ( VariableDeclaration declarationNode ) { <nl> 
1<ml>Closure_47.src.patch<ml>Closure_47.src.patch<ml>mmm a / src / com / google / debugging / sourcemap / SourceMapConsumerV3 . java <nl> ppp b / src / com / google / debugging / sourcemap / SourceMapConsumerV3 . java <nl> / / Adjust the line / column here to be start at 1 . <nl> Builder x = OriginalMapping . newBuilder ( ) <nl> . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) <nl> - . setLineNumber ( entry . getSourceLine ( ) + 1 ) <nl> - . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; <nl> + . setLineNumber ( entry . getSourceLine ( ) ) <nl> + . setColumnPosition ( entry . getSourceColumn ( ) ) ; <nl> if ( entry . getNameId ( ) ! = UNMAPPED ) { <nl> x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; <nl> } <nl> mmm a / src / com / google / javascript / jscomp / SourceMap . java <nl> ppp b / src / com / google / javascript / jscomp / SourceMap . java <nl> / / zero based . <nl> / / We don ' t change this for the v1 or v2 source maps but for <nl> / / v3 we make them both 0 based . <nl> - int lineBaseOffset = 1 ; <nl> - if ( generator instanceof SourceMapGeneratorV1 <nl> - | | generator instanceof SourceMapGeneratorV2 ) { <nl> - lineBaseOffset = 0 ; <nl> - } <nl> generator . addMapping ( <nl> sourceFile , originalName , <nl> - new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , <nl> + new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , <nl> outputStartPosition , outputEndPosition ) ; <nl> } <nl> 
1<ml>Closure_29.src.patch<ml>Closure_29.src.patch<ml>mmm a / src / com / google / javascript / jscomp / InlineObjectLiterals . java <nl> ppp b / src / com / google / javascript / jscomp / InlineObjectLiterals . java <nl> * / <nl> private boolean isInlinableObject ( List < Reference > refs ) { <nl> boolean ret = false ; <nl> - Set < String > validProperties = Sets . newHashSet ( ) ; <nl> for ( Reference ref : refs ) { <nl> Node name = ref . getNode ( ) ; <nl> Node parent = ref . getParent ( ) ; <nl> / / We short - circuit this problem by bailing out if we see a reference <nl> / / to a property that isn ' t defined on the object literal . This <nl> / / isn ' t a perfect algorithm , but it should catch most cases . <nl> - String propName = parent . getLastChild ( ) . getString ( ) ; <nl> - if ( ! validProperties . contains ( propName ) ) { <nl> - if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , gramps ) ) { <nl> - validProperties . add ( propName ) ; <nl> - } else { <nl> - return false ; <nl> - } <nl> - } <nl> continue ; <nl> } <nl> return false ; <nl> } <nl> - validProperties . add ( child . getString ( ) ) ; <nl> Node childVal = child . getFirstChild ( ) ; <nl> / / Check if childVal is the parent of any of the passed in <nl> 
1<ml>Closure_3.src.patch<ml>Closure_3.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> ppp b / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; <nl> reachingUses . analyze ( ) ; <nl> for ( Candidate c : candidates ) { <nl> - if ( c . canInline ( t . getScope ( ) ) ) { <nl> + if ( c . canInline ( ) ) { <nl> c . inlineVariable ( ) ; <nl> / / If definition c has dependencies , then inlining it may have <nl> return defMetadata . node ; <nl> } <nl> - private boolean canInline ( final Scope scope ) { <nl> + private boolean canInline ( ) { <nl> / / Cannot inline a parameter . <nl> if ( getDefCfgNode ( ) . isFunction ( ) ) { <nl> return false ; <nl> case Token . REGEXP : <nl> case Token . NEW : <nl> return true ; <nl> - case Token . NAME : <nl> - Var var = scope . getOwnSlot ( input . getString ( ) ) ; <nl> - if ( var ! = null <nl> - & & var . getParentNode ( ) . isCatch ( ) ) { <nl> - return true ; <nl> - } <nl> } <nl> return false ; <nl> } <nl> 
1<ml>Closure_53.src.patch<ml>Closure_53.src.patch<ml>mmm a / src / com / google / javascript / jscomp / InlineObjectLiterals . java <nl> ppp b / src / com / google / javascript / jscomp / InlineObjectLiterals . java <nl> } <nl> Node replacement ; <nl> - if ( nodes . isEmpty ( ) ) { <nl> - replacement = new Node ( Token . TRUE ) ; <nl> - } else { <nl> / / All assignments evaluate to true , so make sure that the <nl> / / expr statement evaluates to true in case it matters . <nl> nodes . add ( new Node ( Token . TRUE ) ) ; <nl> } <nl> cur . addChildToFront ( nodes . get ( i ) ) ; <nl> cur . addChildToFront ( nodes . get ( i + 1 ) ) ; <nl> - } <nl> Node replace = ref . getParent ( ) ; <nl> replacement . copyInformationFromForTree ( replace ) ; <nl> 
1<ml>Closure_119.src.patch<ml>Closure_119.src.patch<ml>mmm a / src / com / google / javascript / jscomp / GlobalNamespace . java <nl> ppp b / src / com / google / javascript / jscomp / GlobalNamespace . java <nl> isSet = true ; <nl> type = Name . Type . FUNCTION ; <nl> break ; <nl> - case Token . CATCH : <nl> case Token . INC : <nl> case Token . DEC : <nl> isSet = true ; <nl> 
1<ml>Closure_72.src.patch<ml>Closure_72.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FunctionToBlockMutator . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionToBlockMutator . java <nl> " inline_ " , <nl> isCallInLoop ) ) ) ; <nl> / / Make label names unique to this instance . <nl> - new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) <nl> - . process ( null , fnNode ) ; <nl> } <nl> static class LabelNameSupplier implements Supplier < String > { <nl> mmm a / src / com / google / javascript / jscomp / RenameLabels . java <nl> ppp b / src / com / google / javascript / jscomp / RenameLabels . java <nl> String name = nameNode . getString ( ) ; <nl> LabelInfo li = getLabelInfo ( name ) ; <nl> / / This is a label . . . <nl> - if ( li . referenced | | ! removeUnused ) { <nl> + if ( li . referenced ) { <nl> String newName = getNameForId ( li . id ) ; <nl> if ( ! name . equals ( newName ) ) { <nl> / / . . . and it is used , give it the short name . <nl> 
1<ml>Closure_66.src.patch<ml>Closure_66.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> / / Object literal keys are handled with OBJECTLIT <nl> if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { <nl> ensureTyped ( t , n , STRING_TYPE ) ; <nl> - } else { <nl> / / Object literal keys are not typeable <nl> - typeable = false ; <nl> } <nl> break ; <nl> 
1<ml>Closure_83.src.patch<ml>Closure_83.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> ppp b / src / com / google / javascript / jscomp / CommandLineRunner . java <nl> @ Override <nl> public int parseArguments ( Parameters params ) throws CmdLineException { <nl> - String param = null ; <nl> - try { <nl> - param = params . getParameter ( 0 ) ; <nl> - } catch ( CmdLineException e ) { } <nl> + String param = params . getParameter ( 0 ) ; <nl> if ( param = = null ) { <nl> setter . addValue ( true ) ; <nl> 
1<ml>Closure_30.src.patch<ml>Closure_30.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> ppp b / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java <nl> @ Override <nl> public void process ( Node externs , Node root ) { <nl> - ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; <nl> + ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; <nl> } <nl> @ Override <nl> mmm a / src / com / google / javascript / jscomp / MustBeReachingVariableDef . java <nl> ppp b / src / com / google / javascript / jscomp / MustBeReachingVariableDef . java <nl> private static class Definition { <nl> final Node node ; <nl> final Set < Var > depends = Sets . newHashSet ( ) ; <nl> - private boolean unknownDependencies = false ; <nl> Definition ( Node node ) { <nl> this . node = node ; <nl> new AbstractCfgNodeTraversalCallback ( ) { <nl> @ Override <nl> public void visit ( NodeTraversal t , Node n , Node parent ) { <nl> - if ( n . isName ( ) ) { <nl> + if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { <nl> Var dep = jsScope . getVar ( n . getString ( ) ) ; <nl> - if ( dep = = null ) { <nl> - def . unknownDependencies = true ; <nl> - } else { <nl> def . depends . add ( dep ) ; <nl> - } <nl> } <nl> } <nl> } ) ; <nl> GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; <nl> FlowState < MustDef > state = n . getAnnotation ( ) ; <nl> Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; <nl> - if ( def . unknownDependencies ) { <nl> - return true ; <nl> - } <nl> for ( Var s : def . depends ) { <nl> if ( s . scope ! = jsScope ) { <nl> 
1<ml>Closure_121.src.patch<ml>Closure_121.src.patch<ml>mmm a / src / com / google / javascript / jscomp / InlineVariables . java <nl> ppp b / src / com / google / javascript / jscomp / InlineVariables . java <nl> if ( ! maybeModifiedArguments & & <nl> ! staleVars . contains ( v ) & & <nl> referenceInfo . isWellDefined ( ) & & <nl> - referenceInfo . isAssignedOnceInLifetime ( ) & & <nl> + referenceInfo . isAssignedOnceInLifetime ( ) ) { <nl> / / Inlining the variable based solely on well - defined and assigned <nl> / / once is * NOT * correct . We relax the correctness requirement if <nl> / / the variable is declared constant . <nl> - ( isInlineableDeclaredConstant ( v , referenceInfo ) | | <nl> - referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { <nl> List < Reference > refs = referenceInfo . references ; <nl> for ( int i = 1 / * start from a read * / ; i < refs . size ( ) ; i + + ) { <nl> Node nameNode = refs . get ( i ) . getNode ( ) ; <nl> 
1<ml>Closure_24.src.patch<ml>Closure_24.src.patch<ml>mmm a / src / com / google / javascript / jscomp / ScopedAliases . java <nl> ppp b / src / com / google / javascript / jscomp / ScopedAliases . java <nl> Node n = v . getNode ( ) ; <nl> int type = n . getType ( ) ; <nl> Node parent = n . getParent ( ) ; <nl> - if ( parent . isVar ( ) & & <nl> - n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { <nl> + if ( parent . isVar ( ) ) { <nl> + if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { <nl> String name = n . getString ( ) ; <nl> Var aliasVar = scope . getVar ( name ) ; <nl> aliases . put ( name , aliasVar ) ; <nl> String qualifiedName = <nl> aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; <nl> transformation . addAlias ( name , qualifiedName ) ; <nl> - } else if ( v . isBleedingFunction ( ) ) { <nl> / / Bleeding functions already get a BAD_PARAMETERS error , so just <nl> / / do nothing . <nl> - } else if ( parent . getType ( ) = = Token . LP ) { <nl> / / Parameters of the scope function also get a BAD_PARAMETERS <nl> / / error . <nl> } else { <nl> / / TODO ( robbyw ) : Support using locals for private variables . <nl> report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; <nl> } <nl> + } <nl> } <nl> } <nl> 
1<ml>Closure_97.src.patch<ml>Closure_97.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> / / JavaScript handles zero shifts on signed numbers differently than <nl> / / Java as an Java int can not represent the unsigned 32 - bit number <nl> / / where JavaScript can so use a long here . <nl> - long lvalLong = lvalInt & 0xffffffffL ; <nl> - result = lvalLong > > > rvalInt ; <nl> + result = lvalInt > > > rvalInt ; <nl> break ; <nl> default : <nl> throw new AssertionError ( " Unknown shift operator : " + <nl> 
1<ml>Closure_114.src.patch<ml>Closure_114.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NameAnalyzer . java <nl> ppp b / src / com / google / javascript / jscomp / NameAnalyzer . java <nl> } else { <nl> recordDepScope ( nameNode , ns ) ; <nl> } <nl> - } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { <nl> + } else { <nl> / / The rhs of the assignment is the caller , so it ' s used by the <nl> / / context . Don ' t associate it w / the lhs . <nl> / / FYI : this fixes only the specific case where the assignment is the <nl> 
1<ml>Closure_11.src.patch<ml>Closure_11.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeCheck . java <nl> ppp b / src / com / google / javascript / jscomp / TypeCheck . java <nl> if ( childType . isDict ( ) ) { <nl> report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , " ' . ' " , " dict " ) ; <nl> + } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { <nl> + return ; <nl> } else if ( validator . expectNotNullOrUndefined ( t , n , childType , <nl> " No properties on this expression " , getNativeType ( OBJECT_TYPE ) ) ) { <nl> checkPropertyAccess ( childType , property . getString ( ) , t , n ) ; <nl> 
1<ml>Closure_100.src.patch<ml>Closure_100.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CheckGlobalThis . java <nl> ppp b / src / com / google / javascript / jscomp / CheckGlobalThis . java <nl> / / var a = function ( ) { } ; / / or <nl> / / function a ( ) { } / / or <nl> / / a . x = function ( ) { } ; <nl> - int pType = parent . getType ( ) ; <nl> - if ( ! ( pType = = Token . BLOCK | | <nl> - pType = = Token . SCRIPT | | <nl> - pType = = Token . NAME | | <nl> - pType = = Token . ASSIGN ) ) { <nl> - return false ; <nl> - } <nl> } <nl> if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { <nl> } <nl> / / Also report a THIS with a property access . <nl> - return parent ! = null & & NodeUtil . isGet ( parent ) ; <nl> + return false ; <nl> } <nl> / * * <nl> 
1<ml>Closure_74.src.patch<ml>Closure_74.src.patch<ml>mmm a / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> ppp b / src / com / google / javascript / jscomp / PeepholeFoldConstants . java <nl> & & right . getString ( ) . equals ( " undefined " ) ) <nl> | | ( Token . VOID = = right . getType ( ) <nl> & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; <nl> - int lhType = getNormalizedNodeType ( left ) ; <nl> - int rhType = getNormalizedNodeType ( right ) ; <nl> + int lhType = left . getType ( ) ; <nl> + int rhType = right . getType ( ) ; <nl> switch ( lhType ) { <nl> case Token . VOID : <nl> if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) { <nl> / * * <nl> * @ return Translate NOT expressions into TRUE or FALSE when possible . <nl> * / <nl> - private int getNormalizedNodeType ( Node n ) { <nl> - int type = n . getType ( ) ; <nl> - if ( type = = Token . NOT ) { <nl> - TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; <nl> - switch ( value ) { <nl> - case TRUE : <nl> - return Token . TRUE ; <nl> - case FALSE : <nl> - return Token . FALSE ; <nl> - } <nl> - } <nl> - return type ; <nl> - } <nl> / * * <nl> * The result of the comparison as a Boolean or null if the <nl> 
1<ml>Closure_60.src.patch<ml>Closure_60.src.patch<ml>mmm a / src / com / google / javascript / jscomp / NodeUtil . java <nl> ppp b / src / com / google / javascript / jscomp / NodeUtil . java <nl> / / ignoring side - effects <nl> return TernaryValue . TRUE ; <nl> - case Token . VOID : <nl> - return TernaryValue . FALSE ; <nl> default : <nl> return getPureBooleanValue ( n ) ; <nl> return TernaryValue . FALSE ; <nl> case Token . VOID : <nl> - if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { <nl> return TernaryValue . FALSE ; <nl> - } <nl> - break ; <nl> case Token . NAME : <nl> String name = n . getString ( ) ; <nl> 
1<ml>Closure_41.src.patch<ml>Closure_41.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FunctionTypeBuilder . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionTypeBuilder . java <nl> } <nl> / / Clone any remaining params that aren ' t in the function literal . <nl> - while ( oldParams . hasNext ( ) ) { <nl> - paramBuilder . newParameterFromNode ( oldParams . next ( ) ) ; <nl> - } <nl> parametersNode = paramBuilder . build ( ) ; <nl> } <nl> } <nl> / / Copy over any old parameters that aren ' t in the param list . <nl> - if ( ! isVarArgs ) { <nl> - while ( oldParameterType ! = null & & ! isVarArgs ) { <nl> - builder . newParameterFromNode ( oldParameterType ) ; <nl> - oldParameterType = oldParameterType . getNext ( ) ; <nl> - } <nl> - } <nl> if ( templateTypeName ! = null & & ! foundTemplateType ) { <nl> reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; <nl> 
1<ml>Closure_88.src.patch<ml>Closure_88.src.patch<ml>mmm a / src / com / google / javascript / jscomp / DeadAssignmentsElimination . java <nl> ppp b / src / com / google / javascript / jscomp / DeadAssignmentsElimination . java <nl> Node n , String variable ) { <nl> if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { <nl> if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { <nl> - Preconditions . checkState ( n . getParent ( ) . getType ( ) = = Token . ASSIGN ) ; <nl> / / The expression to which the assignment is made is evaluated before <nl> / / the RHS is evaluated ( normal left to right evaluation ) but the KILL <nl> / / occurs after the RHS is evaluated . <nl> - Node rhs = n . getNext ( ) ; <nl> - VariableLiveness state = isVariableReadBeforeKill ( rhs , variable ) ; <nl> - if ( state = = VariableLiveness . READ ) { <nl> - return state ; <nl> - } <nl> return VariableLiveness . KILL ; <nl> } else { <nl> return VariableLiveness . READ ; <nl> 
1<ml>Closure_55.src.patch<ml>Closure_55.src.patch<ml>mmm a / src / com / google / javascript / jscomp / FunctionRewriter . java <nl> ppp b / src / com / google / javascript / jscomp / FunctionRewriter . java <nl> } <nl> private static boolean isReduceableFunctionExpression ( Node n ) { <nl> - return NodeUtil . isFunctionExpression ( n ) <nl> - & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; <nl> + return NodeUtil . isFunctionExpression ( n ) ; <nl> } <nl> / * * <nl> 
1<ml>Closure_5.src.patch<ml>Closure_5.src.patch<ml>mmm a / src / com / google / javascript / jscomp / InlineObjectLiterals . java <nl> ppp b / src / com / google / javascript / jscomp / InlineObjectLiterals . java <nl> / / Deleting a property has different semantics from deleting <nl> / / a variable , so deleted properties should not be inlined . <nl> - if ( gramps . isDelProp ( ) ) { <nl> - return false ; <nl> - } <nl> / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has <nl> / / a blind spot . It assumes that if a property isn ' t defined on an <nl> 
1<ml>Closure_79.src.patch<ml>Closure_79.src.patch<ml>mmm a / src / com / google / javascript / jscomp / Normalize . java <nl> ppp b / src / com / google / javascript / jscomp / Normalize . java <nl> public void process ( Node externs , Node root ) { <nl> new NodeTraversal ( <nl> compiler , new NormalizeStatements ( compiler , assertOnChange ) ) <nl> - . traverseRoots ( externs , root ) ; <nl> + . traverse ( root ) ; <nl> if ( MAKE_LOCAL_NAMES_UNIQUE ) { <nl> MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; <nl> NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; <nl> mmm a / src / com / google / javascript / jscomp / VarCheck . java <nl> ppp b / src / com / google / javascript / jscomp / VarCheck . java <nl> getSynthesizedExternsRoot ( ) . addChildToBack ( <nl> new Node ( Token . VAR , nameNode ) ) ; <nl> varsToDeclareInExterns . remove ( varName ) ; <nl> - compiler . reportCodeChange ( ) ; <nl> } <nl> / * * <nl> 
1<ml>Closure_112.src.patch<ml>Closure_112.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypeInference . java <nl> ppp b / src / com / google / javascript / jscomp / TypeInference . java <nl> } <nl> / / Try to infer the template types <nl> - Map < TemplateType , JSType > inferred = Maps . filterKeys ( <nl> - inferTemplateTypesFromParameters ( fnType , n ) , <nl> - new Predicate < TemplateType > ( ) { <nl> - <nl> - @ Override <nl> - public boolean apply ( TemplateType key ) { <nl> - return keys . contains ( key ) ; <nl> - } } <nl> - ) ; <nl> + Map < TemplateType , JSType > inferred = <nl> + inferTemplateTypesFromParameters ( fnType , n ) ; <nl> + <nl> / / Replace all template types . If we couldn ' t find a replacement , we <nl> / / replace it with UNKNOWN . <nl> 
1<ml>Closure_17.src.patch<ml>Closure_17.src.patch<ml>mmm a / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> ppp b / src / com / google / javascript / jscomp / TypedScopeCreator . java <nl> if ( info . isConstant ( ) ) { <nl> JSType knownType = null ; <nl> if ( rValue ! = null ) { <nl> - JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; <nl> - if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { <nl> + if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { <nl> / / If rValue has a type - cast , we use the type in the type - cast . <nl> - return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; <nl> - } else if ( rValue . getJSType ( ) ! = null <nl> - & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { <nl> / / If rValue ' s type was already computed during scope creation , <nl> / / then we can safely use that . <nl> return rValue . getJSType ( ) ; <nl> 
1<ml>Closure_106.src.patch<ml>Closure_106.src.patch<ml>mmm a / src / com / google / javascript / jscomp / GlobalNamespace . java <nl> ppp b / src / com / google / javascript / jscomp / GlobalNamespace . java <nl> / / Don ' t try to collapse if the one global set is a twin reference . <nl> / / We could theoretically handle this case in CollapseProperties , but <nl> / / it ' s probably not worth the effort . <nl> - Preconditions . checkNotNull ( declaration ) ; <nl> - if ( declaration . getTwin ( ) ! = null ) { <nl> - return false ; <nl> - } <nl> if ( isClassOrEnum ) { <nl> return true ; <nl> mmm a / src / com / google / javascript / rhino / JSDocInfoBuilder . java <nl> ppp b / src / com / google / javascript / rhino / JSDocInfoBuilder . java <nl> * @ return { @ code true } if the description was recorded . <nl> * / <nl> public boolean recordBlockDescription ( String description ) { <nl> + if ( parseDocumentation ) { <nl> populated = true ; <nl> + } <nl> return currentInfo . documentBlock ( description ) ; <nl> } <nl> 
1<ml>Closure_36.src.patch<ml>Closure_36.src.patch<ml>mmm a / src / com / google / javascript / jscomp / InlineVariables . java <nl> ppp b / src / com / google / javascript / jscomp / InlineVariables . java <nl> / / issue 668 : Don ' t inline singleton getter methods <nl> / / calls as this confused class removing logic . <nl> - if ( convention . getSingletonGetterClassName ( callNode ) ! = null ) { <nl> - return false ; <nl> - } <nl> } <nl> } <nl> 
1<ml>Closure_127.src.patch<ml>Closure_127.src.patch<ml>mmm a / src / com / google / javascript / jscomp / UnreachableCodeElimination . java <nl> ppp b / src / com / google / javascript / jscomp / UnreachableCodeElimination . java <nl> outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; <nl> Node fallThrough = computeFollowing ( n ) ; <nl> Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; <nl> - if ( nextCfgNode = = fallThrough & & ! inFinally ( n . getParent ( ) , n ) ) { <nl> + if ( nextCfgNode = = fallThrough ) { <nl> removeNode ( n ) ; <nl> } <nl> } <nl> } <nl> } <nl> - private boolean inFinally ( Node parent , Node child ) { <nl> - if ( parent = = null | | parent . isFunction ( ) ) { <nl> - return false ; <nl> - } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { <nl> - return true ; <nl> - } else { <nl> - return inFinally ( parent . getParent ( ) , parent ) ; <nl> - } <nl> - } <nl> private Node computeFollowing ( Node n ) { <nl> Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; <nl> 
1<ml>Closure_85.src.patch<ml>Closure_85.src.patch<ml>mmm a / src / com / google / javascript / jscomp / UnreachableCodeElimination . java <nl> ppp b / src / com / google / javascript / jscomp / UnreachableCodeElimination . java <nl> return n ; <nl> } <nl> + if ( n . getParent ( ) = = null ) { <nl> + List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; <nl> + if ( outEdges . size ( ) = = 1 ) { <nl> + return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; <nl> + } <nl> + } <nl> switch ( n . getType ( ) ) { <nl> + case Token . BLOCK : <nl> + if ( n . hasChildren ( ) ) { <nl> + Node first = n . getFirstChild ( ) ; <nl> + return tryRemoveUnconditionalBranching ( first ) ; <nl> + } else { <nl> + return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; <nl> + } <nl> case Token . RETURN : <nl> if ( n . hasChildren ( ) ) { <nl> break ; <nl> ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { <nl> Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; <nl> - Node fallThrough = computeFollowing ( n ) ; <nl> + Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; <nl> Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; <nl> if ( nextCfgNode = = fallThrough ) { <nl> removeDeadExprStatementSafely ( n ) ; <nl> private Node computeFollowing ( Node n ) { <nl> Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; <nl> - while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { <nl> - if ( next . hasChildren ( ) ) { <nl> - next = next . getFirstChild ( ) ; <nl> - } else { <nl> - next = computeFollowing ( next ) ; <nl> - } <nl> - } <nl> return next ; <nl> } <nl> 
1<ml>Closure_91.src.patch<ml>Closure_91.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CheckGlobalThis . java <nl> ppp b / src / com / google / javascript / jscomp / CheckGlobalThis . java <nl> } <nl> / / Don ' t traverse functions that are getting lent to a prototype . <nl> - Node gramps = parent . getParent ( ) ; <nl> - if ( NodeUtil . isObjectLitKey ( parent , gramps ) ) { <nl> - JSDocInfo maybeLends = gramps . getJSDocInfo ( ) ; <nl> - if ( maybeLends ! = null & & <nl> - maybeLends . getLendsName ( ) ! = null & & <nl> - maybeLends . getLendsName ( ) . endsWith ( " . prototype " ) ) { <nl> - return false ; <nl> - } <nl> - } <nl> } <nl> if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { <nl> 
1<ml>Closure_58.src.patch<ml>Closure_58.src.patch<ml>mmm a / src / com / google / javascript / jscomp / LiveVariablesAnalysis . java <nl> ppp b / src / com / google / javascript / jscomp / LiveVariablesAnalysis . java <nl> / / for ( var x in y ) { . . . } <nl> lhs = lhs . getLastChild ( ) ; <nl> } <nl> - if ( NodeUtil . isName ( lhs ) ) { <nl> addToSetIfLocal ( lhs , kill ) ; <nl> addToSetIfLocal ( lhs , gen ) ; <nl> - } else { <nl> - computeGenKill ( lhs , gen , kill , conditional ) ; <nl> - } <nl> computeGenKill ( rhs , gen , kill , conditional ) ; <nl> } <nl> return ; <nl> 
1<ml>Closure_133.src.patch<ml>Closure_133.src.patch<ml>mmm a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> ppp b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java <nl> * / <nl> private String getRemainingJSDocLine ( ) { <nl> String result = stream . getRemainingJSDocLine ( ) ; <nl> - unreadToken = NO_UNREAD_TOKEN ; <nl> return result ; <nl> } <nl> 
1<ml>Closure_8.src.patch<ml>Closure_8.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CollapseVariableDeclarations . java <nl> ppp b / src / com / google / javascript / jscomp / CollapseVariableDeclarations . java <nl> Var var = s . getVar ( lhs . getString ( ) ) ; <nl> return var ! = null <nl> & & var . getScope ( ) = = s <nl> - & & ! isNamedParameter ( var ) <nl> & & ! blacklistedVars . contains ( var ) ; <nl> } <nl> } <nl> - private boolean isNamedParameter ( Var v ) { <nl> - return v . getParentNode ( ) . isParamList ( ) ; <nl> - } <nl> private void applyCollapses ( ) { <nl> for ( Collapse collapse : collapses ) { <nl> 
1<ml>Closure_22.src.patch<ml>Closure_22.src.patch<ml>mmm a / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> ppp b / src / com / google / javascript / jscomp / CheckSideEffects . java <nl> / / Do not try to remove a block or an expr result . We already handle <nl> / / these cases when we visit the child , and the peephole passes will <nl> / / fix up the tree in more clever ways when these are removed . <nl> - if ( n . isExprResult ( ) | | n . isBlock ( ) ) { <nl> + if ( parent . getType ( ) = = Token . COMMA ) { <nl> + Node gramps = parent . getParent ( ) ; <nl> + if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { <nl> + if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & " eval " . equals ( n . getNext ( ) . getString ( ) ) ) { <nl> return ; <nl> + } <nl> } <nl> / / This no - op statement was there so that JSDoc information could <nl> / / be attached to the name . This check should not complain about it . <nl> - if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { <nl> + if ( n = = parent . getLastChild ( ) ) { <nl> + for ( Node an : parent . getAncestors ( ) ) { <nl> + int ancestorType = an . getType ( ) ; <nl> + if ( ancestorType = = Token . COMMA ) <nl> + continue ; <nl> + if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) <nl> + return ; <nl> + else <nl> + break ; <nl> + } <nl> + } <nl> + } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { <nl> + if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | <nl> + n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { <nl> + } else { <nl> return ; <nl> + } <nl> } <nl> boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; <nl> boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; <nl> if ( ! isResultUsed & & <nl> ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { <nl> + if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { <nl> + return ; <nl> + } else if ( n . isExprResult ( ) ) { <nl> + return ; <nl> + } <nl> String msg = " This code lacks side - effects . Is there a bug ? " ; <nl> if ( n . isString ( ) ) { <nl> msg = " Is there a missing ' + ' on the previous line ? " ; <nl> 
1<ml>Lang_65.src.patch<ml>Lang_65.src.patch<ml>mmm a / src / java / org / apache / commons / lang / time / DateUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DateUtils . java <nl> throw new ArithmeticException ( " Calendar value too large for accurate calculations " ) ; <nl> } <nl> - if ( field = = Calendar . MILLISECOND ) { <nl> - return ; <nl> - } <nl> / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - <nl> / / see http : / / issues . apache . org / jira / browse / LANG - 59 <nl> / / Manually truncate milliseconds , seconds and minutes , rather than using <nl> / / Calendar methods . <nl> - Date date = val . getTime ( ) ; <nl> - long time = date . getTime ( ) ; <nl> - boolean done = false ; <nl> / / truncate milliseconds <nl> - int millisecs = val . get ( Calendar . MILLISECOND ) ; <nl> - if ( ! round | | millisecs < 500 ) { <nl> - time = time - millisecs ; <nl> - if ( field = = Calendar . SECOND ) { <nl> - done = true ; <nl> - } <nl> - } <nl> / / truncate seconds <nl> - int seconds = val . get ( Calendar . SECOND ) ; <nl> - if ( ! done & & ( ! round | | seconds < 30 ) ) { <nl> - time = time - ( seconds * 1000L ) ; <nl> - if ( field = = Calendar . MINUTE ) { <nl> - done = true ; <nl> - } <nl> - } <nl> / / truncate minutes <nl> - int minutes = val . get ( Calendar . MINUTE ) ; <nl> - if ( ! done & & ( ! round | | minutes < 30 ) ) { <nl> - time = time - ( minutes * 60000L ) ; <nl> - } <nl> / / reset time <nl> - if ( date . getTime ( ) ! = time ) { <nl> - date . setTime ( time ) ; <nl> - val . setTime ( date ) ; <nl> - } <nl> / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - <nl> boolean roundUp = false ; <nl> roundUp = offset > ( ( max - min ) / 2 ) ; <nl> } <nl> / / We need to remove this field <nl> - if ( offset ! = 0 ) { <nl> val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; <nl> - } <nl> } <nl> throw new IllegalArgumentException ( " The field " + field + " is not supported " ) ; <nl> 
1<ml>Lang_50.src.patch<ml>Lang_50.src.patch<ml>mmm a / src / java / org / apache / commons / lang / time / FastDateFormat . java <nl> ppp b / src / java / org / apache / commons / lang / time / FastDateFormat . java <nl> key = new Pair ( key , timeZone ) ; <nl> } <nl> - if ( locale = = null ) { <nl> - locale = Locale . getDefault ( ) ; <nl> + if ( locale ! = null ) { <nl> + key = new Pair ( key , locale ) ; <nl> } <nl> - key = new Pair ( key , locale ) ; <nl> FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; <nl> if ( format = = null ) { <nl> + if ( locale = = null ) { <nl> + locale = Locale . getDefault ( ) ; <nl> + } <nl> try { <nl> SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; <nl> String pattern = formatter . toPattern ( ) ; <nl> if ( timeZone ! = null ) { <nl> key = new Pair ( key , timeZone ) ; <nl> } <nl> - if ( locale = = null ) { <nl> - locale = Locale . getDefault ( ) ; <nl> + if ( locale ! = null ) { <nl> + key = new Pair ( key , locale ) ; <nl> } <nl> - key = new Pair ( key , locale ) ; <nl> FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; <nl> if ( format = = null ) { <nl> + if ( locale = = null ) { <nl> + locale = Locale . getDefault ( ) ; <nl> + } <nl> try { <nl> SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , <nl> locale ) ; <nl> 
1<ml>Lang_44.src.patch<ml>Lang_44.src.patch<ml>mmm a / src / java / org / apache / commons / lang / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / NumberUtils . java <nl> if ( val . length ( ) = = 0 ) { <nl> throw new NumberFormatException ( " \ " \ " is not a valid number . " ) ; <nl> } <nl> - if ( val . length ( ) = = 1 & & ! Character . isDigit ( val . charAt ( 0 ) ) ) { <nl> - throw new NumberFormatException ( val + " is not a valid number . " ) ; <nl> - } <nl> if ( val . startsWith ( " - - " ) ) { <nl> / / this is protection for poorness in java . lang . BigDecimal . <nl> / / it accepts this as a legal value , but it does not appear <nl> 
1<ml>Lang_12.src.patch<ml>Lang_12.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / RandomStringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / RandomStringUtils . java <nl> } else if ( count < 0 ) { <nl> throw new IllegalArgumentException ( " Requested random string length " + count + " is less than 0 . " ) ; <nl> } <nl> - if ( chars ! = null & & chars . length = = 0 ) { <nl> - throw new IllegalArgumentException ( " The chars array must not be empty " ) ; <nl> - } <nl> if ( start = = 0 & & end = = 0 ) { <nl> - if ( chars ! = null ) { <nl> - end = chars . length ; <nl> - } else { <nl> if ( ! letters & & ! numbers ) { <nl> end = Integer . MAX_VALUE ; <nl> } else { <nl> end = ' z ' + 1 ; <nl> start = ' ' ; <nl> } <nl> - } <nl> } <nl> char [ ] buffer = new char [ count ] ; <nl> 
1<ml>Lang_27.src.patch<ml>Lang_27.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> if ( decPos > - 1 ) { <nl> if ( expPos > - 1 ) { <nl> - if ( expPos < decPos | | expPos > str . length ( ) ) { <nl> + if ( expPos < decPos ) { <nl> throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> } <nl> dec = str . substring ( decPos + 1 , expPos ) ; <nl> mant = str . substring ( 0 , decPos ) ; <nl> } else { <nl> if ( expPos > - 1 ) { <nl> - if ( expPos > str . length ( ) ) { <nl> - throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> - } <nl> mant = str . substring ( 0 , expPos ) ; <nl> } else { <nl> mant = str ; <nl> 
1<ml>Lang_49.src.patch<ml>Lang_49.src.patch<ml>mmm a / src / java / org / apache / commons / lang / math / Fraction . java <nl> ppp b / src / java / org / apache / commons / lang / math / Fraction . java <nl> * @ return a new reduced fraction instance , or this if no simplification possible <nl> * / <nl> public Fraction reduce ( ) { <nl> - if ( numerator = = 0 ) { <nl> - return equals ( ZERO ) ? this : ZERO ; <nl> - } <nl> int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; <nl> if ( gcd = = 1 ) { <nl> return this ; <nl> 
1<ml>Lang_33.src.patch<ml>Lang_33.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / ClassUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / ClassUtils . java <nl> } <nl> Class < ? > [ ] classes = new Class [ array . length ] ; <nl> for ( int i = 0 ; i < array . length ; i + + ) { <nl> - classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; <nl> + classes [ i ] = array [ i ] . getClass ( ) ; <nl> } <nl> return classes ; <nl> } <nl> 
1<ml>Lang_56.src.patch<ml>Lang_56.src.patch<ml>mmm a / src / java / org / apache / commons / lang / time / FastDateFormat . java <nl> ppp b / src / java / org / apache / commons / lang / time / FastDateFormat . java <nl> / * * <nl> * The parsed rules . <nl> * / <nl> - private transient Rule [ ] mRules ; <nl> + private Rule [ ] mRules ; <nl> / * * <nl> * The estimated maximum length . <nl> * / <nl> - private transient int mMaxLengthEstimate ; <nl> + private int mMaxLengthEstimate ; <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> / * * <nl> / / Serializing <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> - private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { <nl> - in . defaultReadObject ( ) ; <nl> - init ( ) ; <nl> - } <nl> / / Rules <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
1<ml>Lang_38.src.patch<ml>Lang_38.src.patch<ml>mmm a / src / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> ppp b / src / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> * / <nl> public StringBuffer format ( Calendar calendar , StringBuffer buf ) { <nl> if ( mTimeZoneForced ) { <nl> - calendar . getTime ( ) ; / / / LANG - 538 <nl> calendar = ( Calendar ) calendar . clone ( ) ; <nl> calendar . setTimeZone ( mTimeZone ) ; <nl> } <nl> 
1<ml>Lang_42.src.patch<ml>Lang_42.src.patch<ml>mmm a / src / java / org / apache / commons / lang / Entities . java <nl> ppp b / src / java / org / apache / commons / lang / Entities . java <nl> public void escape ( Writer writer , String str ) throws IOException { <nl> int len = str . length ( ) ; <nl> for ( int i = 0 ; i < len ; i + + ) { <nl> - int c = Character . codePointAt ( str , i ) ; <nl> + char c = str . charAt ( i ) ; <nl> String entityName = this . entityName ( c ) ; <nl> if ( entityName = = null ) { <nl> - if ( c > = 0x010000 & & i < len - 1 ) { <nl> - writer . write ( " & # " ) ; <nl> - writer . write ( Integer . toString ( c , 10 ) ) ; <nl> - writer . write ( ' ; ' ) ; <nl> - i + + ; <nl> - } else if ( c > 0x7F ) { <nl> + if ( c > 0x7F ) { <nl> writer . write ( " & # " ) ; <nl> writer . write ( Integer . toString ( c , 10 ) ) ; <nl> writer . write ( ' ; ' ) ; <nl> 
1<ml>Lang_19.src.patch<ml>Lang_19.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / text / translate / NumericEntityUnescaper . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / text / translate / NumericEntityUnescaper . java <nl> public int translate ( CharSequence input , int index , Writer out ) throws IOException { <nl> int seqEnd = input . length ( ) ; <nl> / / Uses - 2 to ensure there is something after the & # <nl> - if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { <nl> + if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { <nl> int start = index + 2 ; <nl> boolean isHex = false ; <nl> isHex = true ; <nl> / / Check there ' s more than just an x after the & # <nl> - if ( start = = seqEnd ) { <nl> - return 0 ; <nl> - } <nl> } <nl> int end = start ; <nl> / / Note that this supports character codes without a ; on the end <nl> - while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | <nl> - ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | <nl> - ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) <nl> + while ( input . charAt ( end ) ! = ' ; ' ) <nl> { <nl> end + + ; <nl> } <nl> out . write ( entityValue ) ; <nl> } <nl> - boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; <nl> - return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; <nl> + return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; <nl> } <nl> return 0 ; <nl> } <nl> 
1<ml>Lang_63.src.patch<ml>Lang_63.src.patch<ml>mmm a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java <nl> days - = 1 ; <nl> } <nl> while ( days < 0 ) { <nl> - end . add ( Calendar . MONTH , - 1 ) ; <nl> - days + = end . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; <nl> + days + = 31 ; <nl> / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . <nl> / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is <nl> / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . <nl> / / Also it ' s contextual - if asked for no M in the format then I should probably <nl> / / be doing no calculating here . <nl> months - = 1 ; <nl> - end . add ( Calendar . MONTH , 1 ) ; <nl> } <nl> while ( months < 0 ) { <nl> months + = 12 ; <nl> years - = 1 ; <nl> } <nl> + milliseconds - = reduceAndCorrect ( start , end , Calendar . MILLISECOND , milliseconds ) ; <nl> + seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; <nl> + minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; <nl> + hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; <nl> + days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; <nl> + months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; <nl> + years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; <nl> / / This next block of code adds in values that <nl> / / aren ' t requested . This allows the user to ask for the <nl> } <nl> return buffer . toString ( ) ; <nl> } <nl> + static int reduceAndCorrect ( Calendar start , Calendar end , int field , int difference ) { <nl> + end . add ( field , - 1 * difference ) ; <nl> + int endValue = end . get ( field ) ; <nl> + int startValue = start . get ( field ) ; <nl> + if ( endValue < startValue ) { <nl> + int newdiff = startValue - endValue ; <nl> + end . add ( field , newdiff ) ; <nl> + return newdiff ; <nl> + } else { <nl> + return 0 ; <nl> + } <nl> + } <nl> static final Object y = " y " ; <nl> static final Object M = " M " ; <nl> 
1<ml>Lang_21.src.patch<ml>Lang_21.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / DateUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / DateUtils . java <nl> return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & <nl> cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & <nl> cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & <nl> - cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & <nl> + cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & <nl> cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & <nl> cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & <nl> cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & <nl> 
1<ml>Lang_35.src.patch<ml>Lang_35.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / ArrayUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / ArrayUtils . java <nl> } else if ( element ! = null ) { <nl> type = element . getClass ( ) ; <nl> } else { <nl> - throw new IllegalArgumentException ( " Arguments cannot both be null " ) ; <nl> + type = Object . class ; <nl> } <nl> @ SuppressWarnings ( " unchecked " ) / / type must be T <nl> T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; <nl> } else if ( element ! = null ) { <nl> clss = element . getClass ( ) ; <nl> } else { <nl> - throw new IllegalArgumentException ( " Array and element cannot both be null " ) ; <nl> + return ( T [ ] ) new Object [ ] { null } ; <nl> } <nl> @ SuppressWarnings ( " unchecked " ) / / the add method creates an array of type clss , which is type T <nl> final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; <nl> 
1<ml>Lang_14.src.patch<ml>Lang_14.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> if ( cs1 = = null | | cs2 = = null ) { <nl> return false ; <nl> } <nl> - if ( cs1 instanceof String & & cs2 instanceof String ) { <nl> return cs1 . equals ( cs2 ) ; <nl> - } <nl> - return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; <nl> } <nl> / * * <nl> 
1<ml>Lang_64.src.patch<ml>Lang_64.src.patch<ml>mmm a / src / java / org / apache / commons / lang / enums / ValuedEnum . java <nl> ppp b / src / java / org / apache / commons / lang / enums / ValuedEnum . java <nl> * @ throws NullPointerException if other is < code > null < / code > <nl> * / <nl> public int compareTo ( Object other ) { <nl> - if ( other = = this ) { <nl> - return 0 ; <nl> - } <nl> - if ( other . getClass ( ) ! = this . getClass ( ) ) { <nl> - if ( other . getClass ( ) . getName ( ) . equals ( this . getClass ( ) . getName ( ) ) ) { <nl> - return iValue - getValueInOtherClassLoader ( other ) ; <nl> - } <nl> - throw new ClassCastException ( <nl> - " Different enum class ' " + ClassUtils . getShortClassName ( other . getClass ( ) ) + " ' " ) ; <nl> - } <nl> return iValue - ( ( ValuedEnum ) other ) . iValue ; <nl> } <nl> * @ param other the object to determine the value for <nl> * @ return the value <nl> * / <nl> - private int getValueInOtherClassLoader ( Object other ) { <nl> - try { <nl> - Method mth = other . getClass ( ) . getMethod ( " getValue " , null ) ; <nl> - Integer value = ( Integer ) mth . invoke ( other , null ) ; <nl> - return value . intValue ( ) ; <nl> - } catch ( NoSuchMethodException e ) { <nl> / / ignore - should never happen <nl> - } catch ( IllegalAccessException e ) { <nl> / / ignore - should never happen <nl> - } catch ( InvocationTargetException e ) { <nl> / / ignore - should never happen <nl> - } <nl> - throw new IllegalStateException ( " This should not happen " ) ; <nl> - } <nl> / * * <nl> * < p > Human readable description of this < code > Enum < / code > item . < / p > <nl> 
1<ml>Lang_45.src.patch<ml>Lang_45.src.patch<ml>mmm a / src / java / org / apache / commons / lang / WordUtils . java <nl> ppp b / src / java / org / apache / commons / lang / WordUtils . java <nl> / / if the lower value is greater than the length of the string , <nl> / / set to the length of the string <nl> - if ( lower > str . length ( ) ) { <nl> - lower = str . length ( ) ; <nl> - } <nl> / / if the upper value is - 1 ( i . e . no limit ) or is greater <nl> / / than the length of the string , set to the length of the string <nl> if ( upper = = - 1 | | upper > str . length ( ) ) { <nl> 
1<ml>Lang_1.src.patch<ml>Lang_1.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> } <nl> } <nl> if ( pfxLen > 0 ) { / / we have a hex number <nl> - char firstSigDigit = 0 ; / / strip leading zeroes <nl> - for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { <nl> - firstSigDigit = str . charAt ( i ) ; <nl> - if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes <nl> - pfxLen + + ; <nl> - } else { <nl> - break ; <nl> - } <nl> - } <nl> final int hexDigits = str . length ( ) - pfxLen ; <nl> - if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long <nl> + if ( hexDigits > 16 ) { / / too many for Long <nl> return createBigInteger ( str ) ; <nl> } <nl> - if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int <nl> + if ( hexDigits > 8 ) { / / too many for an int <nl> return createLong ( str ) ; <nl> } <nl> return createInteger ( str ) ; <nl> 
1<ml>Lang_51.src.patch<ml>Lang_51.src.patch<ml>mmm a / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ppp b / src / java / org / apache / commons / lang / BooleanUtils . java <nl> ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & <nl> ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; <nl> } <nl> - return false ; <nl> } <nl> case 4 : { <nl> char ch = str . charAt ( 0 ) ; <nl> 
1<ml>Lang_13.src.patch<ml>Lang_13.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java <nl> * class here is a workaround , see the JIRA issue LANG - 626 . < / p > <nl> * / <nl> static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { <nl> - private static final Map < String , Class < ? > > primitiveTypes = <nl> - new HashMap < String , Class < ? > > ( ) ; <nl> private ClassLoader classLoader ; <nl> / * * <nl> super ( in ) ; <nl> this . classLoader = classLoader ; <nl> - primitiveTypes . put ( " byte " , byte . class ) ; <nl> - primitiveTypes . put ( " short " , short . class ) ; <nl> - primitiveTypes . put ( " int " , int . class ) ; <nl> - primitiveTypes . put ( " long " , long . class ) ; <nl> - primitiveTypes . put ( " float " , float . class ) ; <nl> - primitiveTypes . put ( " double " , double . class ) ; <nl> - primitiveTypes . put ( " boolean " , boolean . class ) ; <nl> - primitiveTypes . put ( " char " , char . class ) ; <nl> - primitiveTypes . put ( " void " , void . class ) ; <nl> } <nl> / * * <nl> try { <nl> return Class . forName ( name , false , classLoader ) ; <nl> } catch ( ClassNotFoundException ex ) { <nl> - try { <nl> return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> - } catch ( ClassNotFoundException cnfe ) { <nl> - Class < ? > cls = primitiveTypes . get ( name ) ; <nl> - if ( cls ! = null ) <nl> - return cls ; <nl> - else <nl> - throw cnfe ; <nl> - } <nl> } <nl> } <nl> 
1<ml>Lang_48.src.patch<ml>Lang_48.src.patch<ml>mmm a / src / java / org / apache / commons / lang / builder / EqualsBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / builder / EqualsBuilder . java <nl> } <nl> Class lhsClass = lhs . getClass ( ) ; <nl> if ( ! lhsClass . isArray ( ) ) { <nl> - if ( lhs instanceof java . math . BigDecimal ) { <nl> - isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; <nl> - } else { <nl> / / The simple case , not an array , just test the element <nl> isEquals = lhs . equals ( rhs ) ; <nl> - } <nl> } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { <nl> / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] <nl> this . setEquals ( false ) ; <nl> 
1<ml>Lang_32.src.patch<ml>Lang_32.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / builder / HashCodeBuilder . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / builder / HashCodeBuilder . java <nl> * <nl> * @ since 2 . 3 <nl> * / <nl> - private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; <nl> + private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) { <nl> + @ Override <nl> + protected Set < IDKey > initialValue ( ) { <nl> + return new HashSet < IDKey > ( ) ; <nl> + } <nl> + } ; <nl> / * <nl> * N . B . we cannot store the actual objects in a HashSet , as that would use the very hashCode ( ) <nl> * @ since 2 . 3 <nl> * / <nl> static boolean isRegistered ( Object value ) { <nl> - Set < IDKey > registry = getRegistry ( ) ; <nl> - return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; <nl> + return getRegistry ( ) . contains ( new IDKey ( value ) ) ; <nl> } <nl> / * * <nl> * The object to register . <nl> * / <nl> static void register ( Object value ) { <nl> - synchronized ( HashCodeBuilder . class ) { <nl> - if ( getRegistry ( ) = = null ) { <nl> - REGISTRY . set ( new HashSet < IDKey > ( ) ) ; <nl> - } <nl> - } <nl> getRegistry ( ) . add ( new IDKey ( value ) ) ; <nl> } <nl> * @ since 2 . 3 <nl> * / <nl> static void unregister ( Object value ) { <nl> - Set < IDKey > s = getRegistry ( ) ; <nl> - if ( s ! = null ) { <nl> - s . remove ( new IDKey ( value ) ) ; <nl> - synchronized ( HashCodeBuilder . class ) { <nl> - if ( s . isEmpty ( ) ) { <nl> - REGISTRY . remove ( ) ; <nl> - } <nl> - } <nl> - } <nl> + getRegistry ( ) . remove ( new IDKey ( value ) ) ; <nl> } <nl> / * * <nl> 
1<ml>Lang_26.src.patch<ml>Lang_26.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> * @ return the formatted string <nl> * / <nl> public String format ( Date date ) { <nl> - Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; <nl> + Calendar c = new GregorianCalendar ( mTimeZone ) ; <nl> c . setTime ( date ) ; <nl> return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; <nl> } <nl> 
1<ml>Lang_39.src.patch<ml>Lang_39.src.patch<ml>mmm a / src / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / java / org / apache / commons / lang3 / StringUtils . java <nl> / / count the replacement text elements that are larger than their corresponding text being replaced <nl> for ( int i = 0 ; i < searchList . length ; i + + ) { <nl> - if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { <nl> - continue ; <nl> - } <nl> int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; <nl> if ( greater > 0 ) { <nl> increase + = 3 * greater ; / / assume 3 matches <nl> 
1<ml>Lang_43.src.patch<ml>Lang_43.src.patch<ml>mmm a / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java <nl> ppp b / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java <nl> int start = pos . getIndex ( ) ; <nl> char [ ] c = pattern . toCharArray ( ) ; <nl> if ( escapingOn & & c [ start ] = = QUOTE ) { <nl> - next ( pos ) ; <nl> return appendTo = = null ? null : appendTo . append ( QUOTE ) ; <nl> } <nl> int lastHold = start ; <nl> 
1<ml>Lang_7.src.patch<ml>Lang_7.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> if ( StringUtils . isBlank ( str ) ) { <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> + if ( str . startsWith ( " - - " ) ) { <nl> + return null ; <nl> + } <nl> if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> int hexDigits = str . length ( ) - 2 ; / / drop 0x <nl> if ( str . startsWith ( " - " ) ) { / / drop - <nl> if ( StringUtils . isBlank ( str ) ) { <nl> throw new NumberFormatException ( " A blank string is not a valid number " ) ; <nl> } <nl> - if ( str . trim ( ) . startsWith ( " - - " ) ) { <nl> / / this is protection for poorness in java . lang . BigDecimal . <nl> / / it accepts this as a legal value , but it does not appear <nl> / / to be in specification of class . OS X Java parses it to <nl> / / a wrong value . <nl> - throw new NumberFormatException ( str + " is not a valid number . " ) ; <nl> - } <nl> return new BigDecimal ( str ) ; <nl> } <nl> 
1<ml>Lang_18.src.patch<ml>Lang_18.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java <nl> rule = new TextField ( Calendar . ERA , ERAs ) ; <nl> break ; <nl> case ' y ' : / / year ( number ) <nl> - if ( tokenLen = = 2 ) { <nl> - rule = TwoDigitYearField . INSTANCE ; <nl> + if ( tokenLen > = 4 ) { <nl> + rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; <nl> } else { <nl> - rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; <nl> + rule = TwoDigitYearField . INSTANCE ; <nl> } <nl> break ; <nl> case ' M ' : / / month in year ( text and number ) <nl> 
1<ml>Lang_62.src.patch<ml>Lang_62.src.patch<ml>mmm a / src / java / org / apache / commons / lang / Entities . java <nl> ppp b / src / java / org / apache / commons / lang / Entities . java <nl> } else { <nl> entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; <nl> } <nl> - if ( entityValue > 0xFFFF ) { <nl> - entityValue = - 1 ; <nl> - } <nl> } catch ( NumberFormatException ex ) { <nl> entityValue = - 1 ; <nl> } <nl> case ' X ' : <nl> case ' x ' : { <nl> entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; <nl> - break ; <nl> } <nl> default : { <nl> entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; <nl> } <nl> } <nl> - if ( entityValue > 0xFFFF ) { <nl> - entityValue = - 1 ; <nl> - } <nl> } catch ( NumberFormatException e ) { <nl> - entityValue = - 1 ; <nl> } <nl> } <nl> } else { / / escaped value content is an entity name <nl> 
1<ml>Lang_34.src.patch<ml>Lang_34.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / builder / ToStringStyle . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / builder / ToStringStyle . java <nl> * @ return Set the registry of objects being traversed <nl> * / <nl> static Map < Object , Object > getRegistry ( ) { <nl> - return REGISTRY . get ( ) ; <nl> + return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; <nl> } <nl> / * * <nl> * / <nl> static boolean isRegistered ( Object value ) { <nl> Map < Object , Object > m = getRegistry ( ) ; <nl> - return m ! = null & & m . containsKey ( value ) ; <nl> + return m . containsKey ( value ) ; <nl> } <nl> / * * <nl> 
1<ml>Lang_20.src.patch<ml>Lang_20.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; <nl> + StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> return EMPTY ; <nl> } <nl> - StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; <nl> + StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; <nl> for ( int i = startIndex ; i < endIndex ; i + + ) { <nl> if ( i > startIndex ) { <nl> 
1<ml>Lang_15.src.patch<ml>Lang_15.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / reflect / TypeUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / reflect / TypeUtils . java <nl> toClass , typeVarAssigns ) ; <nl> / / now to check each type argument <nl> - for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { <nl> - Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; <nl> - Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; <nl> + for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { <nl> + Type toTypeArg = entry . getValue ( ) ; <nl> + Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; <nl> / / parameters must either be absent from the subject type , within <nl> / / the bounds of the wildcard type , or be an exact match to the <nl> : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; <nl> / / has target class been reached ? <nl> - if ( toClass . equals ( cls ) ) { <nl> + if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { <nl> return typeVarAssigns ; <nl> } <nl> 
1<ml>Lang_28.src.patch<ml>Lang_28.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / text / translate / NumericEntityUnescaper . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / text / translate / NumericEntityUnescaper . java <nl> return 0 ; <nl> } <nl> - if ( entityValue > 0xFFFF ) { <nl> - char [ ] chrs = Character . toChars ( entityValue ) ; <nl> - out . write ( chrs [ 0 ] ) ; <nl> - out . write ( chrs [ 1 ] ) ; <nl> - } else { <nl> out . write ( entityValue ) ; <nl> - } <nl> return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; <nl> } <nl> return 0 ; <nl> 
1<ml>Lang_2.src.patch<ml>Lang_2.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / LocaleUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / LocaleUtils . java <nl> if ( str = = null ) { <nl> return null ; <nl> } <nl> - if ( str . contains ( " # " ) ) { / / LANG - 879 - Cannot handle Java 7 script & extensions <nl> - throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> - } <nl> final int len = str . length ( ) ; <nl> if ( len < 2 ) { <nl> throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> 
1<ml>Lang_52.src.patch<ml>Lang_52.src.patch<ml>mmm a / src / java / org / apache / commons / lang / StringEscapeUtils . java <nl> ppp b / src / java / org / apache / commons / lang / StringEscapeUtils . java <nl> out . write ( ' \ \ ' ) ; <nl> out . write ( ' \ \ ' ) ; <nl> break ; <nl> - case ' / ' : <nl> - out . write ( ' \ \ ' ) ; <nl> - out . write ( ' / ' ) ; <nl> - break ; <nl> default : <nl> out . write ( ch ) ; <nl> break ; <nl> 
1<ml>Lang_46.src.patch<ml>Lang_46.src.patch<ml>mmm a / src / java / org / apache / commons / lang / StringEscapeUtils . java <nl> ppp b / src / java / org / apache / commons / lang / StringEscapeUtils . java <nl> * @ return String with escaped values , < code > null < / code > if null string input <nl> * / <nl> public static String escapeJava ( String str ) { <nl> - return escapeJavaStyleString ( str , false , false ) ; <nl> + return escapeJavaStyleString ( str , false ) ; <nl> } <nl> / * * <nl> * @ throws IOException if error occurs on underlying Writer <nl> * / <nl> public static void escapeJava ( Writer out , String str ) throws IOException { <nl> - escapeJavaStyleString ( out , str , false , false ) ; <nl> + escapeJavaStyleString ( out , str , false ) ; <nl> } <nl> / * * <nl> * @ return String with escaped values , < code > null < / code > if null string input <nl> * / <nl> public static String escapeJavaScript ( String str ) { <nl> - return escapeJavaStyleString ( str , true , true ) ; <nl> + return escapeJavaStyleString ( str , true ) ; <nl> } <nl> / * * <nl> * @ throws IOException if error occurs on underlying Writer <nl> * * / <nl> public static void escapeJavaScript ( Writer out , String str ) throws IOException { <nl> - escapeJavaStyleString ( out , str , true , true ) ; <nl> + escapeJavaStyleString ( out , str , true ) ; <nl> } <nl> / * * <nl> * @ param escapeForwardSlash TODO <nl> * @ return the escaped string <nl> * / <nl> - private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { <nl> + private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { <nl> if ( str = = null ) { <nl> return null ; <nl> } <nl> try { <nl> StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; <nl> - escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; <nl> + escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; <nl> return writer . toString ( ) ; <nl> } catch ( IOException ioe ) { <nl> / / this should never ever happen while writing to a StringWriter <nl> * @ param escapeForwardSlash TODO <nl> * @ throws IOException if an IOException occurs <nl> * / <nl> - private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , <nl> - boolean escapeForwardSlash ) throws IOException { <nl> + private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { <nl> if ( out = = null ) { <nl> throw new IllegalArgumentException ( " The Writer must not be null " ) ; <nl> } <nl> out . write ( ' \ \ ' ) ; <nl> break ; <nl> case ' / ' : <nl> - if ( escapeForwardSlash ) { <nl> out . write ( ' \ \ ' ) ; <nl> - } <nl> out . write ( ' / ' ) ; <nl> break ; <nl> default : <nl> 
1<ml>Lang_31.src.patch<ml>Lang_31.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> } <nl> int csLength = cs . length ( ) ; <nl> int searchLength = searchChars . length ; <nl> - int csLastIndex = csLength - 1 ; <nl> - int searchLastIndex = searchLength - 1 ; <nl> for ( int i = 0 ; i < csLength ; i + + ) { <nl> char ch = cs . charAt ( i ) ; <nl> for ( int j = 0 ; j < searchLength ; j + + ) { <nl> if ( searchChars [ j ] = = ch ) { <nl> - if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { <nl> / / ch is a supplementary character <nl> - if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { <nl> - return true ; <nl> - } <nl> - } else { <nl> / / ch is in the Basic Multilingual Plane <nl> return true ; <nl> - } <nl> } <nl> } <nl> } <nl> 
1<ml>Lang_10.src.patch<ml>Lang_10.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> * @ return The < code > StringBuilder < / code > <nl> * / <nl> private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { <nl> + boolean wasWhite = false ; <nl> for ( int i = 0 ; i < value . length ( ) ; + + i ) { <nl> char c = value . charAt ( i ) ; <nl> + if ( Character . isWhitespace ( c ) ) { <nl> + if ( ! wasWhite ) { <nl> + wasWhite = true ; <nl> + regex . append ( " \ \ s * + " ) ; <nl> + } <nl> + continue ; <nl> + } <nl> + wasWhite = false ; <nl> switch ( c ) { <nl> case ' \ ' ' : <nl> if ( unquote ) { <nl> 
1<ml>Lang_61.src.patch<ml>Lang_61.src.patch<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> return - 1 ; <nl> } <nl> char [ ] thisBuf = buffer ; <nl> - int len = size - strLen + 1 ; <nl> + int len = thisBuf . length - strLen ; <nl> outer : <nl> for ( int i = startIndex ; i < len ; i + + ) { <nl> for ( int j = 0 ; j < strLen ; j + + ) { <nl> 
1<ml>Lang_54.src.patch<ml>Lang_54.src.patch<ml>mmm a / src / java / org / apache / commons / lang / LocaleUtils . java <nl> ppp b / src / java / org / apache / commons / lang / LocaleUtils . java <nl> throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> } <nl> char ch3 = str . charAt ( 3 ) ; <nl> - if ( ch3 = = ' _ ' ) { <nl> - return new Locale ( str . substring ( 0 , 2 ) , " " , str . substring ( 4 ) ) ; <nl> - } <nl> char ch4 = str . charAt ( 4 ) ; <nl> if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { <nl> throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> 
1<ml>Lang_4.src.patch<ml>Lang_4.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / text / translate / LookupTranslator . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / text / translate / LookupTranslator . java <nl> * / <nl> public class LookupTranslator extends CharSequenceTranslator { <nl> - private final HashMap < String , CharSequence > lookupMap ; <nl> + private final HashMap < CharSequence , CharSequence > lookupMap ; <nl> private final int shortest ; <nl> private final int longest ; <nl> * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] <nl> * / <nl> public LookupTranslator ( final CharSequence [ ] . . . lookup ) { <nl> - lookupMap = new HashMap < String , CharSequence > ( ) ; <nl> + lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; <nl> int _shortest = Integer . MAX_VALUE ; <nl> int _longest = 0 ; <nl> if ( lookup ! = null ) { <nl> for ( final CharSequence [ ] seq : lookup ) { <nl> - this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; <nl> + this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; <nl> final int sz = seq [ 0 ] . length ( ) ; <nl> if ( sz < _shortest ) { <nl> _shortest = sz ; <nl> / / descend so as to get a greedy algorithm <nl> for ( int i = max ; i > = shortest ; i - - ) { <nl> final CharSequence subSeq = input . subSequence ( index , index + i ) ; <nl> - final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; <nl> + final CharSequence result = lookupMap . get ( subSeq ) ; <nl> if ( result ! = null ) { <nl> out . write ( result . toString ( ) ) ; <nl> return i ; <nl> 
1<ml>Lang_40.src.patch<ml>Lang_40.src.patch<ml>mmm a / src / java / org / apache / commons / lang / StringUtils . java <nl> ppp b / src / java / org / apache / commons / lang / StringUtils . java <nl> if ( str = = null | | searchStr = = null ) { <nl> return false ; <nl> } <nl> - int len = searchStr . length ( ) ; <nl> - int max = str . length ( ) - len ; <nl> - for ( int i = 0 ; i < = max ; i + + ) { <nl> - if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { <nl> - return true ; <nl> - } <nl> - } <nl> - return false ; <nl> + return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; <nl> } <nl> / / IndexOfAny chars <nl> 
1<ml>Lang_16.src.patch<ml>Lang_16.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> / / a wrong value . <nl> return null ; <nl> } <nl> - if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <nl> + if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) ) { <nl> return createInteger ( str ) ; <nl> } <nl> char lastChar = str . charAt ( str . length ( ) - 1 ) ; <nl> 
1<ml>Lang_9.src.patch<ml>Lang_9.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java <nl> currentFormatField = nextFormatField ; <nl> currentStrategy = nextStrategy ; <nl> } <nl> - if ( patternMatcher . regionStart ( ) ! = patternMatcher . regionEnd ( ) ) { <nl> - throw new IllegalArgumentException ( " Failed to parse \ " " + pattern + " \ " ; gave up at index " + patternMatcher . regionStart ( ) ) ; <nl> - } <nl> if ( currentStrategy . addRegex ( this , regex ) ) { <nl> collector . add ( currentStrategy ) ; <nl> } <nl> 
1<ml>Lang_23.src.patch<ml>Lang_23.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / text / ExtendedMessageFormat . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / text / ExtendedMessageFormat . java <nl> * / <nl> public class ExtendedMessageFormat extends MessageFormat { <nl> private static final long serialVersionUID = - 2362048321261811743L ; <nl> - private static final int HASH_SEED = 31 ; <nl> private static final String DUMMY_PATTERN = " " ; <nl> private static final String ESCAPED_QUOTE = " ' ' " ; <nl> * @ param obj the object to compare to <nl> * @ return true if this object equals the other , otherwise false <nl> * / <nl> - @ Override <nl> - public boolean equals ( Object obj ) { <nl> - if ( obj = = this ) { <nl> - return true ; <nl> - } <nl> - if ( obj = = null ) { <nl> - return false ; <nl> - } <nl> - if ( ! super . equals ( obj ) ) { <nl> - return false ; <nl> - } <nl> - if ( ObjectUtils . notEqual ( getClass ( ) , obj . getClass ( ) ) ) { <nl> - return false ; <nl> - } <nl> - ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ; <nl> - if ( ObjectUtils . notEqual ( toPattern , rhs . toPattern ) ) { <nl> - return false ; <nl> - } <nl> - if ( ObjectUtils . notEqual ( registry , rhs . registry ) ) { <nl> - return false ; <nl> - } <nl> - return true ; <nl> - } <nl> / * * <nl> * Return the hashcode . <nl> * <nl> * @ return the hashcode <nl> * / <nl> - @ Override <nl> - public int hashCode ( ) { <nl> - int result = super . hashCode ( ) ; <nl> - result = HASH_SEED * result + ObjectUtils . hashCode ( registry ) ; <nl> - result = HASH_SEED * result + ObjectUtils . hashCode ( toPattern ) ; <nl> - return result ; <nl> - } <nl> / * * <nl> * Get a custom format from a format description . <nl> 
1<ml>Lang_37.src.patch<ml>Lang_37.src.patch<ml>mmm a / src / java / org / apache / commons / lang3 / ArrayUtils . java <nl> ppp b / src / java / org / apache / commons / lang3 / ArrayUtils . java <nl> final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; <nl> T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; <nl> System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; <nl> - try { <nl> System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; <nl> - } catch ( ArrayStoreException ase ) { <nl> / / Check if problem is incompatible types <nl> - final Class < ? > type2 = array2 . getClass ( ) . getComponentType ( ) ; <nl> - if ( ! type1 . isAssignableFrom ( type2 ) ) { <nl> - throw new IllegalArgumentException ( " Cannot store " + type2 . getName ( ) + " in an array of " + type1 . getName ( ) ) ; <nl> - } <nl> - throw ase ; / / No , so rethrow original <nl> - } <nl> return joinedArray ; <nl> } <nl> 
1<ml>Lang_47.src.patch<ml>Lang_47.src.patch<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> if ( width > 0 ) { <nl> ensureCapacity ( size + width ) ; <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> - if ( str = = null ) { <nl> - str = " " ; <nl> - } <nl> int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> str . getChars ( strLen - width , strLen , buffer , size ) ; <nl> if ( width > 0 ) { <nl> ensureCapacity ( size + width ) ; <nl> String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; <nl> - if ( str = = null ) { <nl> - str = " " ; <nl> - } <nl> int strLen = str . length ( ) ; <nl> if ( strLen > = width ) { <nl> str . getChars ( 0 , width , buffer , size ) ; <nl> 
1<ml>Lang_29.src.patch<ml>Lang_29.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / SystemUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / SystemUtils . java <nl> * <nl> * @ return the version , for example 131 for Java 1 . 3 . 1 <nl> * / <nl> - static int toJavaVersionInt ( String version ) { <nl> + static float toJavaVersionInt ( String version ) { <nl> return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; <nl> } <nl> 
1<ml>Lang_3.src.patch<ml>Lang_3.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> / / Must be a Float , Double , BigDecimal <nl> final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; <nl> try { <nl> - if ( numDecimals < = 7 ) { / / If number has 7 or fewer digits past the decimal point then make it a float <nl> final Float f = createFloat ( str ) ; <nl> if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { <nl> return f ; <nl> } <nl> - } <nl> } catch ( final NumberFormatException nfe ) { / / NOPMD <nl> / / ignore the bad number <nl> } <nl> try { <nl> - if ( numDecimals < = 16 ) { / / If number has between 8 and 16 digits past the decimal point then make it a double <nl> final Double d = createDouble ( str ) ; <nl> if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { <nl> return d ; <nl> } <nl> - } <nl> } catch ( final NumberFormatException nfe ) { / / NOPMD <nl> / / ignore the bad number <nl> } <nl> 
1<ml>Lang_53.src.patch<ml>Lang_53.src.patch<ml>mmm a / src / java / org / apache / commons / lang / time / DateUtils . java <nl> ppp b / src / java / org / apache / commons / lang / time / DateUtils . java <nl> int millisecs = val . get ( Calendar . MILLISECOND ) ; <nl> if ( ! round | | millisecs < 500 ) { <nl> time = time - millisecs ; <nl> - } <nl> if ( field = = Calendar . SECOND ) { <nl> done = true ; <nl> + } <nl> } <nl> / / truncate seconds <nl> int seconds = val . get ( Calendar . SECOND ) ; <nl> if ( ! done & & ( ! round | | seconds < 30 ) ) { <nl> time = time - ( seconds * 1000L ) ; <nl> - } <nl> if ( field = = Calendar . MINUTE ) { <nl> done = true ; <nl> + } <nl> } <nl> / / truncate minutes <nl> 
1<ml>Lang_30.src.patch<ml>Lang_30.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / StringUtils . java <nl> return INDEX_NOT_FOUND ; <nl> } <nl> int csLen = cs . length ( ) ; <nl> - int csLast = csLen - 1 ; <nl> int searchLen = searchChars . length ; <nl> - int searchLast = searchLen - 1 ; <nl> for ( int i = 0 ; i < csLen ; i + + ) { <nl> char ch = cs . charAt ( i ) ; <nl> for ( int j = 0 ; j < searchLen ; j + + ) { <nl> if ( searchChars [ j ] = = ch ) { <nl> - if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { <nl> / / ch is a supplementary character <nl> - if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { <nl> - return i ; <nl> - } <nl> - } else { <nl> return i ; <nl> - } <nl> } <nl> } <nl> } <nl> * < code > false < / code > if no match or null input <nl> * @ since 2 . 4 <nl> * / <nl> - public static boolean containsAny ( String cs , char [ ] searchChars ) { <nl> + public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { <nl> if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { <nl> return false ; <nl> } <nl> char ch = cs . charAt ( i ) ; <nl> for ( int j = 0 ; j < searchLength ; j + + ) { <nl> if ( searchChars [ j ] = = ch ) { <nl> - if ( Character . isHighSurrogate ( ch ) ) { <nl> - if ( j = = searchLast ) { <nl> + if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { <nl> / / missing low surrogate , fine , like String . indexOf ( String ) <nl> - return true ; <nl> - } <nl> - if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { <nl> + if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { <nl> return true ; <nl> } <nl> } else { <nl> * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input <nl> * @ since 2 . 4 <nl> * / <nl> - public static boolean containsAny ( String cs , String searchChars ) { <nl> + public static boolean containsAny ( CharSequence cs , String searchChars ) { <nl> if ( searchChars = = null ) { <nl> return false ; <nl> } <nl> return INDEX_NOT_FOUND ; <nl> } <nl> int csLen = cs . length ( ) ; <nl> - int csLast = csLen - 1 ; <nl> int searchLen = searchChars . length ; <nl> - int searchLast = searchLen - 1 ; <nl> outer : <nl> for ( int i = 0 ; i < csLen ; i + + ) { <nl> char ch = cs . charAt ( i ) ; <nl> for ( int j = 0 ; j < searchLen ; j + + ) { <nl> if ( searchChars [ j ] = = ch ) { <nl> - if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { <nl> - if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { <nl> - continue outer ; <nl> - } <nl> - } else { <nl> continue outer ; <nl> - } <nl> } <nl> } <nl> return i ; <nl> int strLen = str . length ( ) ; <nl> for ( int i = 0 ; i < strLen ; i + + ) { <nl> char ch = str . charAt ( i ) ; <nl> - boolean chFound = searchChars . indexOf ( ch ) > = 0 ; <nl> - if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { <nl> - char ch2 = str . charAt ( i + 1 ) ; <nl> - if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { <nl> + if ( searchChars . indexOf ( ch ) < 0 ) { <nl> return i ; <nl> - } <nl> - } else { <nl> - if ( ! chFound ) { <nl> - return i ; <nl> - } <nl> } <nl> } <nl> return INDEX_NOT_FOUND ; <nl> return true ; <nl> } <nl> int csLen = cs . length ( ) ; <nl> - int csLast = csLen - 1 ; <nl> int searchLen = searchChars . length ; <nl> - int searchLast = searchLen - 1 ; <nl> for ( int i = 0 ; i < csLen ; i + + ) { <nl> char ch = cs . charAt ( i ) ; <nl> for ( int j = 0 ; j < searchLen ; j + + ) { <nl> if ( searchChars [ j ] = = ch ) { <nl> - if ( Character . isHighSurrogate ( ch ) ) { <nl> - if ( j = = searchLast ) { <nl> / / missing low surrogate , fine , like String . indexOf ( String ) <nl> - return false ; <nl> - } <nl> - if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { <nl> - return false ; <nl> - } <nl> - } else { <nl> / / ch is in the Basic Multilingual Plane <nl> return false ; <nl> - } <nl> } <nl> } <nl> } <nl> 
1<ml>Lang_24.src.patch<ml>Lang_24.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> if ( chars [ i ] = = ' l ' <nl> | | chars [ i ] = = ' L ' ) { <nl> / / not allowing L with an exponent or decimal point <nl> - return foundDigit & & ! hasExp & & ! hasDecPoint ; <nl> + return foundDigit & & ! hasExp ; <nl> } <nl> / / last character is illegal <nl> return false ; <nl> 
1<ml>Lang_11.src.patch<ml>Lang_11.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / RandomStringUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / RandomStringUtils . java <nl> start = ' ' ; <nl> } <nl> } <nl> - } else { <nl> - if ( end < = start ) { <nl> - throw new IllegalArgumentException ( " Parameter end ( " + end + " ) must be greater than start ( " + start + " ) " ) ; <nl> - } <nl> } <nl> char [ ] buffer = new char [ count ] ; <nl> 
1<ml>Lang_60.src.patch<ml>Lang_60.src.patch<ml>mmm a / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> ppp b / src / java / org / apache / commons / lang / text / StrBuilder . java <nl> * / <nl> public boolean contains ( char ch ) { <nl> char [ ] thisBuf = buffer ; <nl> - for ( int i = 0 ; i < this . size ; i + + ) { <nl> + for ( int i = 0 ; i < thisBuf . length ; i + + ) { <nl> if ( thisBuf [ i ] = = ch ) { <nl> return true ; <nl> } <nl> return - 1 ; <nl> } <nl> char [ ] thisBuf = buffer ; <nl> - for ( int i = startIndex ; i < size ; i + + ) { <nl> + for ( int i = startIndex ; i < thisBuf . length ; i + + ) { <nl> if ( thisBuf [ i ] = = ch ) { <nl> return i ; <nl> } <nl> 
1<ml>Lang_41.src.patch<ml>Lang_41.src.patch<ml>mmm a / src / java / org / apache / commons / lang / ClassUtils . java <nl> ppp b / src / java / org / apache / commons / lang / ClassUtils . java <nl> return StringUtils . EMPTY ; <nl> } <nl> - StringBuffer arrayPrefix = new StringBuffer ( ) ; <nl> / / Handle array encoding <nl> - if ( className . startsWith ( " [ " ) ) { <nl> - while ( className . charAt ( 0 ) = = ' [ ' ) { <nl> - className = className . substring ( 1 ) ; <nl> - arrayPrefix . append ( " [ ] " ) ; <nl> - } <nl> / / Strip Object type encoding <nl> - if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { <nl> - className = className . substring ( 1 , className . length ( ) - 1 ) ; <nl> - } <nl> - } <nl> - if ( reverseAbbreviationMap . containsKey ( className ) ) { <nl> - className = reverseAbbreviationMap . get ( className ) ; <nl> - } <nl> int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; <nl> int innerIdx = className . indexOf ( <nl> if ( innerIdx ! = - 1 ) { <nl> out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; <nl> } <nl> - return out + arrayPrefix ; <nl> + return out ; <nl> } <nl> / / Package name <nl> * @ return the package name or an empty string <nl> * / <nl> public static String getPackageName ( String className ) { <nl> - if ( className = = null | | className . length ( ) = = 0 ) { <nl> + if ( className = = null ) { <nl> return StringUtils . EMPTY ; <nl> } <nl> / / Strip array encoding <nl> - while ( className . charAt ( 0 ) = = ' [ ' ) { <nl> - className = className . substring ( 1 ) ; <nl> - } <nl> / / Strip Object type encoding <nl> - if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { <nl> - className = className . substring ( 1 ) ; <nl> - } <nl> int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; <nl> if ( i = = - 1 ) { <nl> 
1<ml>Lang_55.src.patch<ml>Lang_55.src.patch<ml>mmm a / src / java / org / apache / commons / lang / time / StopWatch . java <nl> ppp b / src / java / org / apache / commons / lang / time / StopWatch . java <nl> if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { <nl> throw new IllegalStateException ( " Stopwatch is not running . " ) ; <nl> } <nl> - if ( this . runningState = = STATE_RUNNING ) { <nl> stopTime = System . currentTimeMillis ( ) ; <nl> - } <nl> this . runningState = STATE_STOPPED ; <nl> } <nl> 
1<ml>Lang_5.src.patch<ml>Lang_5.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / LocaleUtils . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / LocaleUtils . java <nl> throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> } <nl> final char ch0 = str . charAt ( 0 ) ; <nl> - if ( ch0 = = ' _ ' ) { <nl> - if ( len < 3 ) { <nl> - throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> - } <nl> - final char ch1 = str . charAt ( 1 ) ; <nl> - final char ch2 = str . charAt ( 2 ) ; <nl> - if ( ! Character . isUpperCase ( ch1 ) | | ! Character . isUpperCase ( ch2 ) ) { <nl> - throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> - } <nl> - if ( len = = 3 ) { <nl> - return new Locale ( " " , str . substring ( 1 , 3 ) ) ; <nl> - } <nl> - if ( len < 5 ) { <nl> - throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> - } <nl> - if ( str . charAt ( 3 ) ! = ' _ ' ) { <nl> - throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> - } <nl> - return new Locale ( " " , str . substring ( 1 , 3 ) , str . substring ( 4 ) ) ; <nl> - } else { <nl> final char ch1 = str . charAt ( 1 ) ; <nl> if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { <nl> throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> throw new IllegalArgumentException ( " Invalid locale format : " + str ) ; <nl> } <nl> return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
1<ml>Lang_17.src.patch<ml>Lang_17.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java <nl> return ; <nl> } <nl> int pos = 0 ; <nl> - int len = input . length ( ) ; <nl> + int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; <nl> while ( pos < len ) { <nl> int consumed = translate ( input , pos , out ) ; <nl> if ( consumed = = 0 ) { <nl> char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; <nl> out . write ( c ) ; <nl> - pos + = c . length ; <nl> - continue ; <nl> } <nl> + else { <nl> / / / / contract with translators is that they have to understand codepoints <nl> / / / / and they just took care of a surrogate pair <nl> for ( int pt = 0 ; pt < consumed ; pt + + ) { <nl> + if ( pos < len - 2 ) { <nl> pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; <nl> + } else { <nl> + pos + + ; <nl> + } <nl> + } <nl> + pos - - ; <nl> } <nl> + pos + + ; <nl> } <nl> } <nl> 
1<ml>Lang_36.src.patch<ml>Lang_36.src.patch<ml>mmm a / src / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang3 / math / NumberUtils . java <nl> } <nl> dec = null ; <nl> } <nl> - if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { <nl> + if ( ! Character . isDigit ( lastChar ) ) { <nl> if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { <nl> exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; <nl> } else { <nl> / / can ' t have an E at the last byte <nl> return false ; <nl> } <nl> - if ( chars [ i ] = = ' . ' ) { <nl> - if ( hasDecPoint | | hasExp ) { <nl> - / / two decimal points or dec in exponent <nl> - return false ; <nl> - } <nl> - / / single trailing decimal point after non - exponent is ok <nl> - return foundDigit ; <nl> - } <nl> if ( ! allowSigns <nl> & & ( chars [ i ] = = ' d ' <nl> | | chars [ i ] = = ' D ' <nl> 
1<ml>Lang_58.src.patch<ml>Lang_58.src.patch<ml>mmm a / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> ppp b / src / java / org / apache / commons / lang / math / NumberUtils . java <nl> case ' L ' : <nl> if ( dec = = null <nl> & & exp = = null <nl> - & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { <nl> + & & isDigits ( numeric . substring ( 1 ) ) <nl> + & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { <nl> try { <nl> return createLong ( numeric ) ; <nl> } catch ( NumberFormatException nfe ) { <nl> 
1<ml>Lang_8.src.patch<ml>Lang_8.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / time / FastDatePrinter . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / time / FastDatePrinter . java <nl> private static class TimeZoneNameRule implements Rule { <nl> private final Locale mLocale ; <nl> private final int mStyle ; <nl> + private final TimeZone zone ; <nl> private final String mStandard ; <nl> private final String mDaylight ; <nl> TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { <nl> mLocale = locale ; <nl> mStyle = style ; <nl> + zone = timeZone ; <nl> mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; <nl> mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; <nl> * / <nl> @ Override <nl> public void appendTo ( StringBuffer buffer , Calendar calendar ) { <nl> - TimeZone zone = calendar . getTimeZone ( ) ; <nl> if ( zone . useDaylightTime ( ) <nl> & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { <nl> buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ; <nl> 
1<ml>Lang_22.src.patch<ml>Lang_22.src.patch<ml>mmm a / src / main / java / org / apache / commons / lang3 / math / Fraction . java <nl> ppp b / src / main / java / org / apache / commons / lang3 / math / Fraction . java <nl> * / <nl> private static int greatestCommonDivisor ( int u , int v ) { <nl> / / From Commons Math : <nl> - if ( ( u = = 0 ) | | ( v = = 0 ) ) { <nl> - if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { <nl> - throw new ArithmeticException ( " overflow : gcd is 2 ^ 31 " ) ; <nl> - } <nl> - return Math . abs ( u ) + Math . abs ( v ) ; <nl> - } <nl> / / if either operand is abs 1 , return 1 : <nl> - if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { <nl> + if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { <nl> return 1 ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> 
1<ml>Math_65.src.patch<ml>Math_65.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / general / AbstractLeastSquaresOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / general / AbstractLeastSquaresOptimizer . java <nl> * @ return RMS value <nl> * / <nl> public double getRMS ( ) { <nl> - return Math . sqrt ( getChiSquare ( ) / rows ) ; <nl> + double criterion = 0 ; <nl> + for ( int i = 0 ; i < rows ; + + i ) { <nl> + final double residual = residuals [ i ] ; <nl> + criterion + = residual * residual * residualsWeights [ i ] ; <nl> + } <nl> + return Math . sqrt ( criterion / rows ) ; <nl> } <nl> / * * <nl> double chiSquare = 0 ; <nl> for ( int i = 0 ; i < rows ; + + i ) { <nl> final double residual = residuals [ i ] ; <nl> - chiSquare + = residual * residual * residualsWeights [ i ] ; <nl> + chiSquare + = residual * residual / residualsWeights [ i ] ; <nl> } <nl> return chiSquare ; <nl> } <nl> 
1<ml>Math_71.src.patch<ml>Math_71.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> / / it is so small ( much probably exactly 0 due to limited accuracy ) <nl> / / that the code above would fail handling it . <nl> / / So we set up an artificial 0 size step by copying states <nl> - interpolator . storeTime ( stepStart ) ; <nl> - System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; <nl> - hNew = 0 ; <nl> - stepSize = 0 ; <nl> loop = false ; <nl> } else { <nl> / / reject the step to match exactly the next switch time <nl> mmm a / src / main / java / org / apache / commons / math / ode / nonstiff / RungeKuttaIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / RungeKuttaIntegrator . java <nl> / / it is so small ( much probably exactly 0 due to limited accuracy ) <nl> / / that the code above would fail handling it . <nl> / / So we set up an artificial 0 size step by copying states <nl> - interpolator . storeTime ( stepStart ) ; <nl> - System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; <nl> - stepSize = 0 ; <nl> loop = false ; <nl> } else { <nl> / / reject the step to match exactly the next switch time <nl> 
1<ml>Math_50.src.patch<ml>Math_50.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> break ; <nl> case REGULA_FALSI : <nl> / / Nothing . <nl> + if ( x = = x1 ) { <nl> + x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; <nl> + f0 = computeObjectiveValue ( x0 ) ; <nl> + } <nl> break ; <nl> default : <nl> / / Should never happen . <nl> 
1<ml>Math_99.src.patch<ml>Math_99.src.patch<ml>mmm a / src / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / java / org / apache / commons / math / util / MathUtils . java <nl> int u = p ; <nl> int v = q ; <nl> if ( ( u = = 0 ) | | ( v = = 0 ) ) { <nl> - if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { <nl> - throw MathRuntimeException . createArithmeticException ( <nl> - " overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 " , <nl> - new Object [ ] { p , q } ) ; <nl> - } <nl> return ( Math . abs ( u ) + Math . abs ( v ) ) ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> return 0 ; <nl> } <nl> int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; <nl> - if ( lcm = = Integer . MIN_VALUE ) { <nl> - throw new ArithmeticException ( " overflow : lcm is 2 ^ 31 " ) ; <nl> - } <nl> return lcm ; <nl> } <nl> 
1<ml>Math_44.src.patch<ml>Math_44.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / ode / AbstractIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / AbstractIntegrator . java <nl> double previousT = interpolator . getGlobalPreviousTime ( ) ; <nl> final double currentT = interpolator . getGlobalCurrentTime ( ) ; <nl> + resetOccurred = false ; <nl> / / initialize the events states if needed <nl> if ( ! statesInitialized ) { <nl> if ( isLastStep ) { <nl> / / the event asked to stop integration <nl> System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; <nl> - for ( final EventState remaining : occuringEvents ) { <nl> - remaining . stepAccepted ( eventT , eventY ) ; <nl> - } <nl> return eventT ; <nl> } <nl> System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; <nl> computeDerivatives ( eventT , y , yDot ) ; <nl> resetOccurred = true ; <nl> - for ( final EventState remaining : occuringEvents ) { <nl> - remaining . stepAccepted ( eventT , eventY ) ; <nl> - } <nl> return eventT ; <nl> } <nl> 
1<ml>Math_68.src.patch<ml>Math_68.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> setMaxIterations ( 1000 ) ; <nl> / / default values for the tuning parameters <nl> - setConvergenceChecker ( null ) ; <nl> setInitialStepBoundFactor ( 100 . 0 ) ; <nl> setCostRelativeTolerance ( 1 . 0e - 10 ) ; <nl> setParRelativeTolerance ( 1 . 0e - 10 ) ; <nl> / / outer loop <nl> lmPar = 0 ; <nl> boolean firstIteration = true ; <nl> - VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; <nl> while ( true ) { <nl> incrementIterationsCounter ( ) ; <nl> / / compute the Q . R . decomposition of the jacobian matrix <nl> - VectorialPointValuePair previous = current ; <nl> updateJacobian ( ) ; <nl> qrDecomposition ( ) ; <nl> } <nl> if ( maxCosine < = orthoTolerance ) { <nl> / / convergence has been reached <nl> - return current ; <nl> + return new VectorialPointValuePair ( point , objective ) ; <nl> } <nl> / / rescale if necessary <nl> / / evaluate the function at x + p and calculate its norm <nl> updateResidualsAndCost ( ) ; <nl> - current = new VectorialPointValuePair ( point , objective ) ; <nl> / / compute the scaled actual reduction <nl> double actRed = - 1 . 0 ; <nl> } <nl> / / tests for convergence . <nl> - if ( checker ! = null ) { <nl> / / we use the vectorial convergence checker <nl> - if ( checker . converged ( getIterations ( ) , previous , current ) ) { <nl> - return current ; <nl> - } <nl> - } else { <nl> / / we use the Levenberg - Marquardt specific convergence parameters <nl> if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & <nl> ( preRed < = costRelativeTolerance ) & & <nl> ( ratio < = 2 . 0 ) ) | | <nl> ( delta < = parRelativeTolerance * xNorm ) ) { <nl> - return current ; <nl> + return new VectorialPointValuePair ( point , objective ) ; <nl> } <nl> - } <nl> / / tests for termination and stringent tolerances <nl> / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 ) <nl> 
1<ml>Math_103.src.patch<ml>Math_103.src.patch<ml>mmm a / src / java / org / apache / commons / math / distribution / NormalDistributionImpl . java <nl> ppp b / src / java / org / apache / commons / math / distribution / NormalDistributionImpl . java <nl> * convergence exception is caught and 0 or 1 is returned . <nl> * / <nl> public double cumulativeProbability ( double x ) throws MathException { <nl> - try { <nl> return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / <nl> ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; <nl> - } catch ( MaxIterationsExceededException ex ) { <nl> - if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 <nl> - return 0 . 0d ; <nl> - } else if ( x > ( mean + 20 * standardDeviation ) ) { <nl> - return 1 . 0d ; <nl> - } else { <nl> - throw ex ; <nl> - } <nl> - } <nl> } <nl> / * * <nl> 
1<ml>Math_12.src.patch<ml>Math_12.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / random / BitsStreamGenerator . java <nl> ppp b / src / main / java / org / apache / commons / math3 / random / BitsStreamGenerator . java <nl> * / <nl> package org . apache . commons . math3 . random ; <nl> - import java . io . Serializable ; <nl> import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; <nl> import org . apache . commons . math3 . util . FastMath ; <nl> * @ since 2 . 0 <nl> * / <nl> public abstract class BitsStreamGenerator <nl> - implements RandomGenerator , <nl> - Serializable { <nl> + implements RandomGenerator { <nl> / * * Serializable version identifier * / <nl> - private static final long serialVersionUID = 20130104L ; <nl> / * * Next gaussian . * / <nl> private double nextGaussian ; <nl> 
1<ml>Math_27.src.patch<ml>Math_27.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / fraction / Fraction . java <nl> ppp b / src / main / java / org / apache / commons / math3 / fraction / Fraction . java <nl> * @ return the fraction percentage as a < tt > double < / tt > . <nl> * / <nl> public double percentageValue ( ) { <nl> - return 100 * doubleValue ( ) ; <nl> + return multiply ( 100 ) . doubleValue ( ) ; <nl> } <nl> / * * <nl> 
1<ml>Math_94.src.patch<ml>Math_94.src.patch<ml>mmm a / src / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / java / org / apache / commons / math / util / MathUtils . java <nl> * @ since 1 . 1 <nl> * / <nl> public static int gcd ( int u , int v ) { <nl> - if ( ( u = = 0 ) | | ( v = = 0 ) ) { <nl> + if ( u * v = = 0 ) { <nl> return ( Math . abs ( u ) + Math . abs ( v ) ) ; <nl> } <nl> / / keep u and v negative , as negative integers range down to <nl> 
1<ml>Math_80.src.patch<ml>Math_80.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> private boolean flipIfWarranted ( final int n , final int step ) { <nl> if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { <nl> / / flip array <nl> - int j = 4 * ( n - 1 ) ; <nl> + int j = 4 * n - 1 ; <nl> for ( int i = 0 ; i < j ; i + = 4 ) { <nl> for ( int k = 0 ; k < 4 ; k + = step ) { <nl> final double tmp = work [ i + k ] ; <nl> 
1<ml>Math_49.src.patch<ml>Math_49.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> public OpenMapRealVector ebeDivide ( RealVector v ) { <nl> checkVectorDimensions ( v . getDimension ( ) ) ; <nl> OpenMapRealVector res = new OpenMapRealVector ( this ) ; <nl> - Iterator iter = entries . iterator ( ) ; <nl> + Iterator iter = res . entries . iterator ( ) ; <nl> while ( iter . hasNext ( ) ) { <nl> iter . advance ( ) ; <nl> res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; <nl> public OpenMapRealVector ebeDivide ( double [ ] v ) { <nl> checkVectorDimensions ( v . length ) ; <nl> OpenMapRealVector res = new OpenMapRealVector ( this ) ; <nl> - Iterator iter = entries . iterator ( ) ; <nl> + Iterator iter = res . entries . iterator ( ) ; <nl> while ( iter . hasNext ( ) ) { <nl> iter . advance ( ) ; <nl> res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; <nl> public OpenMapRealVector ebeMultiply ( RealVector v ) { <nl> checkVectorDimensions ( v . getDimension ( ) ) ; <nl> OpenMapRealVector res = new OpenMapRealVector ( this ) ; <nl> - Iterator iter = entries . iterator ( ) ; <nl> + Iterator iter = res . entries . iterator ( ) ; <nl> while ( iter . hasNext ( ) ) { <nl> iter . advance ( ) ; <nl> res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; <nl> public OpenMapRealVector ebeMultiply ( double [ ] v ) { <nl> checkVectorDimensions ( v . length ) ; <nl> OpenMapRealVector res = new OpenMapRealVector ( this ) ; <nl> - Iterator iter = entries . iterator ( ) ; <nl> + Iterator iter = res . entries . iterator ( ) ; <nl> while ( iter . hasNext ( ) ) { <nl> iter . advance ( ) ; <nl> res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ; <nl> 
1<ml>Math_33.src.patch<ml>Math_33.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java <nl> / / positive cost non - artificial variables <nl> for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { <nl> final double entry = tableau . getEntry ( 0 , i ) ; <nl> - if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { <nl> + if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { <nl> columnsToDrop . add ( i ) ; <nl> } <nl> } <nl> 
1<ml>Math_56.src.patch<ml>Math_56.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / util / MultidimensionalCounter . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MultidimensionalCounter . java <nl> indices [ i ] = idx ; <nl> } <nl> - indices [ last ] = index - count ; <nl> + int idx = 1 ; <nl> + while ( count < index ) { <nl> + count + = idx ; <nl> + + + idx ; <nl> + } <nl> + - - idx ; <nl> + indices [ last ] = idx ; <nl> return indices ; <nl> } <nl> 
1<ml>Math_6.src.patch<ml>Math_6.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java <nl> this . checker = checker ; <nl> evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; <nl> - iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; <nl> + iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; <nl> } <nl> / * * <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / gradient / NonLinearConjugateGradientOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / gradient / NonLinearConjugateGradientOptimizer . java <nl> } <nl> PointValuePair current = null ; <nl> + int iter = 0 ; <nl> int maxEval = getMaxEvaluations ( ) ; <nl> while ( true ) { <nl> - incrementIterationCount ( ) ; <nl> + + + iter ; <nl> final double objective = computeObjectiveValue ( point ) ; <nl> PointValuePair previous = current ; <nl> current = new PointValuePair ( point , objective ) ; <nl> if ( previous ! = null ) { <nl> - if ( checker . converged ( getIterations ( ) , previous , current ) ) { <nl> + if ( checker . converged ( iter , previous , current ) ) { <nl> / / We have found an optimum . <nl> return current ; <nl> } <nl> steepestDescent = newSteepestDescent ; <nl> / / Compute conjugate search direction . <nl> - if ( getIterations ( ) % n = = 0 | | <nl> + if ( iter % n = = 0 | | <nl> beta < 0 ) { <nl> / / Break conjugation : reset search direction . <nl> searchDirection = steepestDescent . clone ( ) ; <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / noderiv / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / noderiv / CMAESOptimizer . java <nl> generationLoop : <nl> for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { <nl> - incrementIterationCount ( ) ; <nl> / / Generate and evaluate lambda offspring <nl> final RealMatrix arz = randn1 ( dimension , lambda ) ; <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / noderiv / PowellOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / noderiv / PowellOptimizer . java <nl> double [ ] x = guess ; <nl> double fVal = computeObjectiveValue ( x ) ; <nl> double [ ] x1 = x . clone ( ) ; <nl> + int iter = 0 ; <nl> while ( true ) { <nl> - incrementIterationCount ( ) ; <nl> + + + iter ; <nl> double fX = fVal ; <nl> double fX2 = 0 ; <nl> final PointValuePair current = new PointValuePair ( x , fVal ) ; <nl> if ( ! stop ) { / / User - defined stopping criteria . <nl> if ( checker ! = null ) { <nl> - stop = checker . converged ( getIterations ( ) , previous , current ) ; <nl> + stop = checker . converged ( iter , previous , current ) ; <nl> } <nl> } <nl> if ( stop ) { <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / noderiv / SimplexOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / scalar / noderiv / SimplexOptimizer . java <nl> int iteration = 0 ; <nl> final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; <nl> while ( true ) { <nl> - if ( getIterations ( ) > 0 ) { <nl> + if ( iteration > 0 ) { <nl> boolean converged = true ; <nl> for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { <nl> PointValuePair prev = previous [ i ] ; <nl> previous = simplex . getPoints ( ) ; <nl> simplex . iterate ( evalFunc , comparator ) ; <nl> - incrementIterationCount ( ) ; <nl> + + + iteration ; <nl> } <nl> } <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / jacobian / GaussNewtonOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / jacobian / GaussNewtonOptimizer . java <nl> / / iterate until convergence is reached <nl> PointVectorValuePair current = null ; <nl> + int iter = 0 ; <nl> for ( boolean converged = false ; ! converged ; ) { <nl> - incrementIterationCount ( ) ; <nl> + + + iter ; <nl> / / evaluate the objective function and its jacobian <nl> PointVectorValuePair previous = current ; <nl> / / Check convergence . <nl> if ( previous ! = null ) { <nl> - converged = checker . converged ( getIterations ( ) , previous , current ) ; <nl> + converged = checker . converged ( iter , previous , current ) ; <nl> if ( converged ) { <nl> setCost ( computeCost ( currentResiduals ) ) ; <nl> return current ; <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / jacobian / LevenbergMarquardtOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / jacobian / LevenbergMarquardtOptimizer . java <nl> / / Outer loop . <nl> lmPar = 0 ; <nl> boolean firstIteration = true ; <nl> + int iter = 0 ; <nl> final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; <nl> while ( true ) { <nl> - incrementIterationCount ( ) ; <nl> - <nl> + + + iter ; <nl> final PointVectorValuePair previous = current ; <nl> / / QR decomposition of the jacobian matrix <nl> / / tests for convergence . <nl> if ( checker ! = null ) { <nl> / / we use the vectorial convergence checker <nl> - if ( checker . converged ( getIterations ( ) , previous , current ) ) { <nl> + if ( checker . converged ( iter , previous , current ) ) { <nl> setCost ( currentCost ) ; <nl> return current ; <nl> } <nl> 
1<ml>Math_38.src.patch<ml>Math_38.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / direct / BOBYQAOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / direct / BOBYQAOptimizer . java <nl> final int tmp2 = jpt ; <nl> jpt = ipt - n ; <nl> ipt = tmp2 ; <nl> - / / throw new PathIsExploredException ( ) ; / / XXX <nl> + throw new PathIsExploredException ( ) ; / / XXX <nl> } <nl> - final int iptMinus1 = ipt - 1 ; <nl> - final int jptMinus1 = jpt - 1 ; <nl> + final int iptMinus1 = ipt ; <nl> + final int jptMinus1 = jpt ; <nl> interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; <nl> interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; <nl> } <nl> final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; <nl> final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; <nl> modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; <nl> - / / throw new PathIsExploredException ( ) ; / / XXX <nl> + throw new PathIsExploredException ( ) ; / / XXX <nl> } <nl> } while ( getEvaluations ( ) < npt ) ; <nl> } / / prelim <nl> 
1<ml>Math_42.src.patch<ml>Math_42.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> continue ; <nl> } <nl> Integer basicRow = getBasicRow ( colIndex ) ; <nl> - if ( basicRow ! = null & & basicRow = = 0 ) { <nl> / / if the basic row is found to be the objective function row <nl> / / set the coefficient to 0 - > this case handles unconstrained <nl> / / variables that are still part of the objective function <nl> - coefficients [ i ] = 0 ; <nl> - } else if ( basicRows . contains ( basicRow ) ) { <nl> + if ( basicRows . contains ( basicRow ) ) { <nl> / / if multiple variables can take a given value <nl> / / then we choose the first and set the rest equal to 0 <nl> coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ; <nl> 
1<ml>Math_19.src.patch<ml>Math_19.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> boundaries [ 1 ] = uB ; <nl> / / Abort early if the normalization will overflow ( cf . " encode " method ) . <nl> - for ( int i = 0 ; i < lB . length ; i + + ) { <nl> - if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { <nl> - final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; <nl> - final NumberIsTooLargeException e <nl> - = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , <nl> - max , <nl> - true ) ; <nl> - e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; <nl> - e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ; <nl> - <nl> - throw e ; <nl> - } <nl> - } <nl> } <nl> } else { <nl> / / Convert API to internal handling of boundaries . <nl> 
1<ml>Math_63.src.patch<ml>Math_63.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / main / java / org / apache / commons / math / util / MathUtils . java <nl> * @ return { @ code true } if the values are equal . <nl> * / <nl> public static boolean equals ( double x , double y ) { <nl> - return equals ( x , y , 1 ) ; <nl> + return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; <nl> } <nl> / * * <nl> 
1<ml>Math_77.src.patch<ml>Math_77.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / linear / ArrayRealVector . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / ArrayRealVector . java <nl> public double getLInfNorm ( ) { <nl> double max = 0 ; <nl> for ( double a : data ) { <nl> - max = Math . max ( max , Math . abs ( a ) ) ; <nl> + max + = Math . max ( max , Math . abs ( a ) ) ; <nl> } <nl> return max ; <nl> } <nl> mmm a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java <nl> return max ; <nl> } <nl> + public double getLInfNorm ( ) { <nl> + double max = 0 ; <nl> + Iterator iter = entries . iterator ( ) ; <nl> + while ( iter . hasNext ( ) ) { <nl> + iter . advance ( ) ; <nl> + max + = iter . value ( ) ; <nl> + } <nl> + return max ; <nl> + } <nl> / * * <nl> * Optimized method to compute LInfDistance . <nl> * @ param v The vector to compute from <nl> 
1<ml>Math_92.src.patch<ml>Math_92.src.patch<ml>mmm a / src / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / java / org / apache / commons / math / util / MathUtils . java <nl> if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { <nl> return n ; <nl> } <nl> + long result = Math . round ( binomialCoefficientDouble ( n , k ) ) ; <nl> + if ( result = = Long . MAX_VALUE ) { <nl> + throw new ArithmeticException ( <nl> + " result too large to represent in a long integer " ) ; <nl> + } <nl> / / Use symmetry for large k <nl> - if ( k > n / 2 ) <nl> - return binomialCoefficient ( n , n - k ) ; <nl> / / We use the formula <nl> / / ( n choose k ) = n ! / ( n - k ) ! / k ! <nl> / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) <nl> / / which could be written <nl> / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k <nl> - long result = 1 ; <nl> - if ( n < = 61 ) { <nl> / / For n < = 61 , the naive implementation cannot overflow . <nl> - for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { <nl> - result = result * i / j ; <nl> - } <nl> - } else if ( n < = 66 ) { <nl> / / For n > 61 but n < = 66 , the result cannot overflow , <nl> / / but we must take care not to overflow intermediate values . <nl> - for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { <nl> / / We know that ( result * i ) is divisible by j , <nl> / / but ( result * i ) may overflow , so we split j : <nl> / / Filter out the gcd , d , so j / d and i / d are integer . <nl> / / result is divisible by ( j / d ) because ( j / d ) <nl> / / is relative prime to ( i / d ) and is a divisor of <nl> / / result * ( i / d ) . <nl> - long d = gcd ( i , j ) ; <nl> - result = ( result / ( j / d ) ) * ( i / d ) ; <nl> - } <nl> - } else { <nl> / / For n > 66 , a result overflow might occur , so we check <nl> / / the multiplication , taking care to not overflow <nl> / / unnecessary . <nl> - for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { <nl> - long d = gcd ( i , j ) ; <nl> - result = mulAndCheck ( ( result / ( j / d ) ) , ( i / d ) ) ; <nl> - } <nl> - } <nl> return result ; <nl> } <nl> * @ throws IllegalArgumentException if preconditions are not met . <nl> * / <nl> public static double binomialCoefficientDouble ( final int n , final int k ) { <nl> - if ( n < k ) { <nl> - throw new IllegalArgumentException ( <nl> - " must have n > = k for binomial coefficient ( n , k ) " ) ; <nl> - } <nl> - if ( n < 0 ) { <nl> - throw new IllegalArgumentException ( <nl> - " must have n > = 0 for binomial coefficient ( n , k ) " ) ; <nl> - } <nl> - if ( ( n = = k ) | | ( k = = 0 ) ) { <nl> - return 1d ; <nl> - } <nl> - if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { <nl> - return n ; <nl> - } <nl> - if ( k > n / 2 ) { <nl> - return binomialCoefficientDouble ( n , n - k ) ; <nl> - } <nl> - if ( n < 67 ) { <nl> - return binomialCoefficient ( n , k ) ; <nl> - } <nl> - double result = 1d ; <nl> - for ( int i = 1 ; i < = k ; i + + ) { <nl> - result * = ( double ) ( n - k + i ) / ( double ) i ; <nl> - } <nl> - return Math . floor ( result + 0 . 5 ) ; <nl> + return Math . floor ( Math . exp ( binomialCoefficientLog ( n , k ) ) + 0 . 5 ) ; <nl> } <nl> / * * <nl> * For values small enough to do exact integer computation , <nl> * return the log of the exact value <nl> * / <nl> - if ( n < 67 ) { <nl> - return Math . log ( binomialCoefficient ( n , k ) ) ; <nl> - } <nl> / * <nl> * Return the log of binomialCoefficientDouble for values that will not <nl> * overflow binomialCoefficientDouble <nl> * / <nl> - if ( n < 1030 ) { <nl> - return Math . log ( binomialCoefficientDouble ( n , k ) ) ; <nl> - } <nl> / * <nl> * Sum logs for values that could overflow <nl> 
1<ml>Math_21.src.patch<ml>Math_21.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / linear / RectangularCholeskyDecomposition . java <nl> ppp b / src / main / java / org / apache / commons / math3 / linear / RectangularCholeskyDecomposition . java <nl> final double [ ] [ ] c = matrix . getData ( ) ; <nl> final double [ ] [ ] b = new double [ order ] [ order ] ; <nl> + int [ ] swap = new int [ order ] ; <nl> int [ ] index = new int [ order ] ; <nl> for ( int i = 0 ; i < order ; + + i ) { <nl> for ( boolean loop = true ; loop ; ) { <nl> / / find maximal diagonal element <nl> - int swapR = r ; <nl> + swap [ r ] = r ; <nl> for ( int i = r + 1 ; i < order ; + + i ) { <nl> int ii = index [ i ] ; <nl> - int isr = index [ swapR ] ; <nl> - if ( c [ ii ] [ ii ] > c [ isr ] [ isr ] ) { <nl> - swapR = i ; <nl> + int isi = index [ swap [ i ] ] ; <nl> + if ( c [ ii ] [ ii ] > c [ isi ] [ isi ] ) { <nl> + swap [ r ] = i ; <nl> } <nl> } <nl> / / swap elements <nl> - if ( swapR ! = r ) { <nl> - final int tmpIndex = index [ r ] ; <nl> - index [ r ] = index [ swapR ] ; <nl> - index [ swapR ] = tmpIndex ; <nl> - final double [ ] tmpRow = b [ r ] ; <nl> - b [ r ] = b [ swapR ] ; <nl> - b [ swapR ] = tmpRow ; <nl> + if ( swap [ r ] ! = r ) { <nl> + int tmp = index [ r ] ; <nl> + index [ r ] = index [ swap [ r ] ] ; <nl> + index [ swap [ r ] ] = tmp ; <nl> } <nl> / / check diagonal element <nl> final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; <nl> b [ r ] [ r ] = sqrt ; <nl> final double inverse = 1 / sqrt ; <nl> - final double inverse2 = 1 / c [ ir ] [ ir ] ; <nl> for ( int i = r + 1 ; i < order ; + + i ) { <nl> final int ii = index [ i ] ; <nl> final double e = inverse * c [ ii ] [ ir ] ; <nl> b [ i ] [ r ] = e ; <nl> - c [ ii ] [ ii ] - = c [ ii ] [ ir ] * c [ ii ] [ ir ] * inverse2 ; <nl> + c [ ii ] [ ii ] - = e * e ; <nl> for ( int j = r + 1 ; j < i ; + + j ) { <nl> final int ij = index [ j ] ; <nl> final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ; <nl> 
1<ml>Math_35.src.patch<ml>Math_35.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java <nl> ppp b / src / main / java / org / apache / commons / math3 / genetics / ElitisticListPopulation . java <nl> final int populationLimit , <nl> final double elitismRate ) { <nl> super ( chromosomes , populationLimit ) ; <nl> - setElitismRate ( elitismRate ) ; <nl> + this . elitismRate = elitismRate ; <nl> } <nl> / * * <nl> * / <nl> public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { <nl> super ( populationLimit ) ; <nl> - setElitismRate ( elitismRate ) ; <nl> + this . elitismRate = elitismRate ; <nl> } <nl> / * * <nl> 
1<ml>Math_86.src.patch<ml>Math_86.src.patch<ml>mmm a / src / java / org / apache / commons / math / linear / CholeskyDecompositionImpl . java <nl> ppp b / src / java / org / apache / commons / math / linear / CholeskyDecompositionImpl . java <nl> final double [ ] lI = lTData [ i ] ; <nl> + if ( lTData [ i ] [ i ] < absolutePositivityThreshold ) { <nl> + throw new NotPositiveDefiniteMatrixException ( ) ; <nl> + } <nl> / / check off - diagonal elements ( and reset them to 0 ) <nl> for ( int j = i + 1 ; j < order ; + + j ) { <nl> final double [ ] lJ = lTData [ j ] ; <nl> final double [ ] ltI = lTData [ i ] ; <nl> / / check diagonal element <nl> - if ( ltI [ i ] < absolutePositivityThreshold ) { <nl> - throw new NotPositiveDefiniteMatrixException ( ) ; <nl> - } <nl> ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; <nl> final double inverse = 1 . 0 / ltI [ i ] ; <nl> 
1<ml>Math_105.src.patch<ml>Math_105.src.patch<ml>mmm a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java <nl> ppp b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java <nl> * @ return sum of squared errors associated with the regression model <nl> * / <nl> public double getSumSquaredErrors ( ) { <nl> - return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; <nl> + return sumYY - sumXY * sumXY / sumXX ; <nl> } <nl> / * * <nl> 
1<ml>Math_14.src.patch<ml>Math_14.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / Weight . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / Weight . java <nl> * / <nl> public Weight ( double [ ] weight ) { <nl> final int dim = weight . length ; <nl> - weightMatrix = new DiagonalMatrix ( weight ) ; <nl> + weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; <nl> + for ( int i = 0 ; i < dim ; i + + ) { <nl> + weightMatrix . setEntry ( i , i , weight [ i ] ) ; <nl> + } <nl> } <nl> / * * <nl> mmm a / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / jacobian / AbstractLeastSquaresOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optim / nonlinear / vector / jacobian / AbstractLeastSquaresOptimizer . java <nl> * @ return the square - root of the weight matrix . <nl> * / <nl> private RealMatrix squareRoot ( RealMatrix m ) { <nl> - if ( m instanceof DiagonalMatrix ) { <nl> - final int dim = m . getRowDimension ( ) ; <nl> - final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; <nl> - for ( int i = 0 ; i < dim ; i + + ) { <nl> - sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; <nl> - } <nl> - return sqrtM ; <nl> - } else { <nl> final EigenDecomposition dec = new EigenDecomposition ( m ) ; <nl> return dec . getSquareRoot ( ) ; <nl> - } <nl> } <nl> } <nl> 
1<ml>Math_64.src.patch<ml>Math_64.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java <nl> double [ ] diag = new double [ cols ] ; <nl> double [ ] oldX = new double [ cols ] ; <nl> double [ ] oldRes = new double [ rows ] ; <nl> - double [ ] oldObj = new double [ rows ] ; <nl> - double [ ] qtf = new double [ rows ] ; <nl> double [ ] work1 = new double [ cols ] ; <nl> double [ ] work2 = new double [ cols ] ; <nl> double [ ] work3 = new double [ cols ] ; <nl> boolean firstIteration = true ; <nl> VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; <nl> while ( true ) { <nl> - for ( int i = 0 ; i < rows ; i + + ) { <nl> - qtf [ i ] = residuals [ i ] ; <nl> - } <nl> incrementIterationsCounter ( ) ; <nl> / / compute the Q . R . decomposition of the jacobian matrix <nl> qrDecomposition ( ) ; <nl> / / compute Qt . res <nl> - qTy ( qtf ) ; <nl> + qTy ( residuals ) ; <nl> / / now we don ' t need Q anymore , <nl> / / so let jacobian contain the R matrix with its diagonal elements <nl> for ( int k = 0 ; k < solvedCols ; + + k ) { <nl> if ( s ! = 0 ) { <nl> double sum = 0 ; <nl> for ( int i = 0 ; i < = j ; + + i ) { <nl> - sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; <nl> + sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; <nl> } <nl> maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; <nl> } <nl> } <nl> if ( maxCosine < = orthoTolerance ) { <nl> / / convergence has been reached <nl> - updateResidualsAndCost ( ) ; <nl> - current = new VectorialPointValuePair ( point , objective ) ; <nl> return current ; <nl> } <nl> double [ ] tmpVec = residuals ; <nl> residuals = oldRes ; <nl> oldRes = tmpVec ; <nl> - tmpVec = objective ; <nl> - objective = oldObj ; <nl> - oldObj = tmpVec ; <nl> / / determine the Levenberg - Marquardt parameter <nl> - determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; <nl> + determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; <nl> / / compute the new point and the norm of the evolution direction <nl> double lmNorm = 0 ; <nl> / / evaluate the function at x + p and calculate its norm <nl> updateResidualsAndCost ( ) ; <nl> + current = new VectorialPointValuePair ( point , objective ) ; <nl> / / compute the scaled actual reduction <nl> double actRed = - 1 . 0 ; <nl> xNorm + = xK * xK ; <nl> } <nl> xNorm = Math . sqrt ( xNorm ) ; <nl> - current = new VectorialPointValuePair ( point , objective ) ; <nl> / / tests for convergence . <nl> - if ( checker ! = null ) { <nl> / / we use the vectorial convergence checker <nl> - if ( checker . converged ( getIterations ( ) , previous , current ) ) { <nl> - return current ; <nl> - } <nl> - } <nl> } else { <nl> / / failed iteration , reset the previous values <nl> cost = previousCost ; <nl> tmpVec = residuals ; <nl> residuals = oldRes ; <nl> oldRes = tmpVec ; <nl> - tmpVec = objective ; <nl> - objective = oldObj ; <nl> - oldObj = tmpVec ; <nl> } <nl> if ( checker = = null ) { <nl> if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & <nl> ( delta < = parRelativeTolerance * xNorm ) ) { <nl> return current ; <nl> } <nl> + } else { <nl> + if ( checker . converged ( getIterations ( ) , previous , current ) ) { <nl> + return current ; <nl> + } <nl> } <nl> / / tests for termination and stringent tolerances <nl> / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 ) <nl> 
1<ml>Math_45.src.patch<ml>Math_45.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / linear / OpenMapRealMatrix . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / OpenMapRealMatrix . java <nl> * / <nl> public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { <nl> super ( rowDimension , columnDimension ) ; <nl> - long lRow = ( long ) rowDimension ; <nl> - long lCol = ( long ) columnDimension ; <nl> - if ( lRow * lCol > = ( long ) Integer . MAX_VALUE ) { <nl> - throw new NumberIsTooLargeException ( lRow * lCol , Integer . MAX_VALUE , false ) ; <nl> - } <nl> this . rows = rowDimension ; <nl> this . columns = columnDimension ; <nl> this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ; <nl> 
1<ml>Math_1.src.patch<ml>Math_1.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / fraction / BigFraction . java <nl> ppp b / src / main / java / org / apache / commons / math3 / fraction / BigFraction . java <nl> if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { <nl> / / in maxDenominator mode , if the last fraction was very close to the actual value <nl> / / q2 may overflow in the next iteration ; in this case return the last one . <nl> - if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { <nl> - break ; <nl> - } <nl> throw new FractionConversionException ( value , p2 , q2 ) ; <nl> } <nl> mmm a / src / main / java / org / apache / commons / math3 / fraction / Fraction . java <nl> ppp b / src / main / java / org / apache / commons / math3 / fraction / Fraction . java <nl> if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { <nl> / / in maxDenominator mode , if the last fraction was very close to the actual value <nl> / / q2 may overflow in the next iteration ; in this case return the last one . <nl> - if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { <nl> - break ; <nl> - } <nl> throw new FractionConversionException ( value , p2 , q2 ) ; <nl> } <nl> 
1<ml>Math_51.src.patch<ml>Math_51.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> case PEGASUS : <nl> f0 * = f1 / ( f1 + fx ) ; <nl> break ; <nl> - case REGULA_FALSI : <nl> - if ( x = = x1 ) { <nl> - final double delta = FastMath . max ( rtol * FastMath . abs ( x1 ) , <nl> - atol ) ; <nl> / / Update formula cannot make any progress : Update the <nl> / / search interval . <nl> - x0 = 0 . 5 * ( x0 + x1 - delta ) ; <nl> - f0 = computeObjectiveValue ( x0 ) ; <nl> - } <nl> - break ; <nl> default : <nl> / / Should never happen . <nl> - throw new MathInternalError ( ) ; <nl> } <nl> } <nl> / / Update from [ x0 , x1 ] to [ x0 , x ] . <nl> 
1<ml>Math_69.src.patch<ml>Math_69.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java <nl> } else { <nl> double r = correlationMatrix . getEntry ( i , j ) ; <nl> double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; <nl> - out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; <nl> + out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; <nl> } <nl> } <nl> } <nl> 
1<ml>Math_102.src.patch<ml>Math_102.src.patch<ml>mmm a / src / java / org / apache / commons / math / stat / inference / ChiSquareTestImpl . java <nl> ppp b / src / java / org / apache / commons / math / stat / inference / ChiSquareTestImpl . java <nl> throw new IllegalArgumentException ( <nl> " observed counts must be non - negative and expected counts must be postive " ) ; <nl> } <nl> - double sumExpected = 0d ; <nl> - double sumObserved = 0d ; <nl> - for ( int i = 0 ; i < observed . length ; i + + ) { <nl> - sumExpected + = expected [ i ] ; <nl> - sumObserved + = observed [ i ] ; <nl> - } <nl> - double ratio = 1 . 0d ; <nl> - boolean rescale = false ; <nl> - if ( Math . abs ( sumExpected - sumObserved ) > 10E - 6 ) { <nl> - ratio = sumObserved / sumExpected ; <nl> - rescale = true ; <nl> - } <nl> double sumSq = 0 . 0d ; <nl> double dev = 0 . 0d ; <nl> for ( int i = 0 ; i < observed . length ; i + + ) { <nl> - if ( rescale ) { <nl> - dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; <nl> - sumSq + = dev * dev / ( ratio * expected [ i ] ) ; <nl> - } else { <nl> dev = ( ( double ) observed [ i ] - expected [ i ] ) ; <nl> sumSq + = dev * dev / expected [ i ] ; <nl> - } <nl> } <nl> return sumSq ; <nl> } <nl> 
1<ml>Math_13.src.patch<ml>Math_13.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / general / AbstractLeastSquaresOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / general / AbstractLeastSquaresOptimizer . java <nl> * @ return the square - root of the weight matrix . <nl> * / <nl> private RealMatrix squareRoot ( RealMatrix m ) { <nl> - if ( m instanceof DiagonalMatrix ) { <nl> - final int dim = m . getRowDimension ( ) ; <nl> - final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; <nl> - for ( int i = 0 ; i < dim ; i + + ) { <nl> - sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; <nl> - } <nl> - return sqrtM ; <nl> - } else { <nl> final EigenDecomposition dec = new EigenDecomposition ( m ) ; <nl> return dec . getSquareRoot ( ) ; <nl> - } <nl> } <nl> } <nl> 
1<ml>Math_81.src.patch<ml>Math_81.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java <nl> lowerSpectra = Math . min ( lowerSpectra , lower ) ; <nl> final double upper = dCurrent + eCurrent ; <nl> work [ upperStart + m - 1 ] = upper ; <nl> - upperSpectra = Math . max ( upperSpectra , upper ) ; <nl> minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; <nl> } <nl> diagMax = work [ 4 * i0 ] ; <nl> offDiagMin = work [ 4 * i0 + 2 ] ; <nl> double previousEMin = work [ 4 * i0 + 3 ] ; <nl> - for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { <nl> - if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | <nl> + for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { <nl> + if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & <nl> ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { <nl> / / insert a split <nl> work [ i + 2 ] = - sigma ; <nl> double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <nl> / / approximate contribution to norm squared from i < nn - 2 . <nl> - if ( end - start > 3 ) { <nl> + if ( end - start > 2 ) { <nl> b2 = work [ nn - 13 ] / work [ nn - 15 ] ; <nl> a2 = a2 + b2 ; <nl> for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <nl> 
1<ml>Math_48.src.patch<ml>Math_48.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java <nl> case REGULA_FALSI : <nl> / / Detect early that algorithm is stuck , instead of waiting <nl> / / for the maximum number of iterations to be exceeded . <nl> - if ( x = = x1 ) { <nl> - throw new ConvergenceException ( ) ; <nl> - } <nl> break ; <nl> default : <nl> / / Should never happen . <nl> 
1<ml>Math_32.src.patch<ml>Math_32.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java <nl> if ( v . length = = 0 ) { <nl> final BSPTree < Euclidean2D > tree = getTree ( false ) ; <nl> - if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { <nl> + if ( ( Boolean ) tree . getAttribute ( ) ) { <nl> / / the instance covers the whole space <nl> setSize ( Double . POSITIVE_INFINITY ) ; <nl> setBarycenter ( Vector2D . NaN ) ; <nl> 
1<ml>Math_26.src.patch<ml>Math_26.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / fraction / Fraction . java <nl> ppp b / src / main / java / org / apache / commons / math3 / fraction / Fraction . java <nl> long overflow = Integer . MAX_VALUE ; <nl> double r0 = value ; <nl> long a0 = ( long ) FastMath . floor ( r0 ) ; <nl> - if ( FastMath . abs ( a0 ) > overflow ) { <nl> + if ( a0 > overflow ) { <nl> throw new FractionConversionException ( value , a0 , 1l ) ; <nl> } <nl> long a1 = ( long ) FastMath . floor ( r1 ) ; <nl> p2 = ( a1 * p1 ) + p0 ; <nl> q2 = ( a1 * q1 ) + q0 ; <nl> - if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { <nl> + if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { <nl> throw new FractionConversionException ( value , p2 , q2 ) ; <nl> } <nl> 
1<ml>Math_95.src.patch<ml>Math_95.src.patch<ml>mmm a / src / java / org / apache / commons / math / distribution / FDistributionImpl . java <nl> ppp b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java <nl> * @ return initial domain value <nl> * / <nl> protected double getInitialDomain ( double p ) { <nl> - double ret = 1 . 0 ; <nl> + double ret ; <nl> double d = getDenominatorDegreesOfFreedom ( ) ; <nl> - if ( d > 2 . 0 ) { <nl> / / use mean <nl> ret = d / ( d - 2 . 0 ) ; <nl> - } <nl> return ret ; <nl> } <nl> 
1<ml>Math_39.src.patch<ml>Math_39.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> } <nl> stepSize = hNew ; <nl> - if ( forward ) { <nl> - if ( stepStart + stepSize > = t ) { <nl> - stepSize = t - stepStart ; <nl> - } <nl> - } else { <nl> - if ( stepStart + stepSize < = t ) { <nl> - stepSize = t - stepStart ; <nl> - } <nl> - } <nl> / / next stages <nl> for ( int k = 1 ; k < stages ; + + k ) { <nl> 
1<ml>Math_43.src.patch<ml>Math_43.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java <nl> secondMoment . increment ( value ) ; <nl> / / If mean , variance or geomean have been overridden , <nl> / / need to increment these <nl> - if ( meanImpl ! = mean ) { <nl> + if ( ! ( meanImpl instanceof Mean ) ) { <nl> meanImpl . increment ( value ) ; <nl> } <nl> - if ( varianceImpl ! = variance ) { <nl> + if ( ! ( varianceImpl instanceof Variance ) ) { <nl> varianceImpl . increment ( value ) ; <nl> } <nl> - if ( geoMeanImpl ! = geoMean ) { <nl> + if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { <nl> geoMeanImpl . increment ( value ) ; <nl> } <nl> n + + ; <nl> 
1<ml>Math_7.src.patch<ml>Math_7.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java <nl> final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; <nl> / / advance all event states to current time <nl> - for ( final EventState state : eventsStates ) { <nl> - state . stepAccepted ( eventT , eventY ) ; <nl> - isLastStep = isLastStep | | state . stop ( ) ; <nl> - } <nl> + currentEvent . stepAccepted ( eventT , eventY ) ; <nl> + isLastStep = currentEvent . stop ( ) ; <nl> / / handle the first part of the step , up to the event <nl> for ( final StepHandler handler : stepHandlers ) { <nl> if ( isLastStep ) { <nl> / / the event asked to stop integration <nl> System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; <nl> + for ( final EventState remaining : occuringEvents ) { <nl> + remaining . stepAccepted ( eventT , eventY ) ; <nl> + } <nl> return eventT ; <nl> } <nl> - boolean needReset = false ; <nl> - for ( final EventState state : eventsStates ) { <nl> - needReset = needReset | | state . reset ( eventT , eventY ) ; <nl> - } <nl> + boolean needReset = currentEvent . reset ( eventT , eventY ) ; <nl> if ( needReset ) { <nl> / / some event handler has triggered changes that <nl> / / invalidate the derivatives , we need to recompute them <nl> System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; <nl> computeDerivatives ( eventT , y , yDot ) ; <nl> resetOccurred = true ; <nl> + for ( final EventState remaining : occuringEvents ) { <nl> + remaining . stepAccepted ( eventT , eventY ) ; <nl> + } <nl> return eventT ; <nl> } <nl> 
1<ml>Math_76.src.patch<ml>Math_76.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / linear / SingularValueDecompositionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / linear / SingularValueDecompositionImpl . java <nl> if ( m > = n ) { <nl> / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal <nl> final RealMatrix e = <nl> - eigenDecomposition . getV ( ) . getSubMatrix ( 0 , n - 1 , 0 , p - 1 ) ; <nl> + eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; <nl> final double [ ] [ ] eData = e . getData ( ) ; <nl> final double [ ] [ ] wData = new double [ m ] [ p ] ; <nl> double [ ] ei1 = eData [ 0 ] ; <nl> - for ( int i = 0 ; i < p ; + + i ) { <nl> + for ( int i = 0 ; i < p - 1 ; + + i ) { <nl> / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix <nl> final double mi = mainBidiagonal [ i ] ; <nl> final double [ ] ei0 = ei1 ; <nl> final double [ ] wi = wData [ i ] ; <nl> - if ( i < n - 1 ) { <nl> ei1 = eData [ i + 1 ] ; <nl> final double si = secondaryBidiagonal [ i ] ; <nl> for ( int j = 0 ; j < p ; + + j ) { <nl> wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; <nl> } <nl> - } else { <nl> + } <nl> for ( int j = 0 ; j < p ; + + j ) { <nl> - wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; <nl> + wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; <nl> } <nl> - } <nl> - } <nl> for ( int i = p ; i < m ; + + i ) { <nl> wData [ i ] = new double [ p ] ; <nl> / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal <nl> / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix <nl> final RealMatrix e = <nl> - eigenDecomposition . getV ( ) . getSubMatrix ( 0 , m - 1 , 0 , p - 1 ) ; <nl> + eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; <nl> final double [ ] [ ] eData = e . getData ( ) ; <nl> final double [ ] [ ] wData = new double [ n ] [ p ] ; <nl> double [ ] ei1 = eData [ 0 ] ; <nl> - for ( int i = 0 ; i < p ; + + i ) { <nl> + for ( int i = 0 ; i < p - 1 ; + + i ) { <nl> final double mi = mainBidiagonal [ i ] ; <nl> final double [ ] ei0 = ei1 ; <nl> final double [ ] wi = wData [ i ] ; <nl> - if ( i < m - 1 ) { <nl> ei1 = eData [ i + 1 ] ; <nl> final double si = secondaryBidiagonal [ i ] ; <nl> for ( int j = 0 ; j < p ; + + j ) { <nl> wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; <nl> } <nl> - } else { <nl> + } <nl> for ( int j = 0 ; j < p ; + + j ) { <nl> - wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; <nl> + wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; <nl> } <nl> - } <nl> - } <nl> for ( int i = p ; i < n ; + + i ) { <nl> wData [ i ] = new double [ p ] ; <nl> } <nl> 
1<ml>Math_18.src.patch<ml>Math_18.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> double [ ] res = new double [ x . length ] ; <nl> for ( int i = 0 ; i < x . length ; i + + ) { <nl> double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; <nl> - res [ i ] = x [ i ] / diff ; <nl> + res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; <nl> } <nl> return res ; <nl> } <nl> double [ ] res = new double [ x . length ] ; <nl> for ( int i = 0 ; i < x . length ; i + + ) { <nl> double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; <nl> - res [ i ] = diff * x [ i ] ; <nl> + res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; <nl> } <nl> return res ; <nl> } <nl> return true ; <nl> } <nl> - final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; <nl> - final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; <nl> for ( int i = 0 ; i < x . length ; i + + ) { <nl> - if ( x [ i ] < bLoEnc [ i ] ) { <nl> + if ( x [ i ] < 0 ) { <nl> return false ; <nl> } <nl> - if ( x [ i ] > bHiEnc [ i ] ) { <nl> + if ( x [ i ] > 1 . 0 ) { <nl> return false ; <nl> } <nl> } <nl> 
1<ml>Math_62.src.patch<ml>Math_62.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java <nl> final GoalType goal , <nl> final double min , final double max ) <nl> throws FunctionEvaluationException { <nl> - return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; <nl> + return optimize ( f , goal , min , max , 0 ) ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> / / Multi - start loop . <nl> for ( int i = 0 ; i < starts ; + + i ) { <nl> try { <nl> - final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; <nl> - optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; <nl> + final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; <nl> + final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; <nl> + optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; <nl> } catch ( FunctionEvaluationException fee ) { <nl> optima [ i ] = null ; <nl> } catch ( ConvergenceException ce ) { <nl> 
1<ml>Math_87.src.patch<ml>Math_87.src.patch<ml>mmm a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> private Integer getBasicRow ( final int col ) { <nl> Integer row = null ; <nl> for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { <nl> - if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { <nl> + if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { <nl> + if ( row = = null ) { <nl> row = i ; <nl> - } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { <nl> + } else { <nl> return null ; <nl> + } <nl> } <nl> } <nl> return row ; <nl> 
1<ml>Math_93.src.patch<ml>Math_93.src.patch<ml>mmm a / src / java / org / apache / commons / math / util / MathUtils . java <nl> ppp b / src / java / org / apache / commons / math / util / MathUtils . java <nl> * @ throws IllegalArgumentException if n < 0 <nl> * / <nl> public static long factorial ( final int n ) { <nl> - if ( n < 0 ) { <nl> - throw new IllegalArgumentException ( " must have n > = 0 for n ! " ) ; <nl> - } <nl> - if ( n > 20 ) { <nl> + long result = Math . round ( factorialDouble ( n ) ) ; <nl> + if ( result = = Long . MAX_VALUE ) { <nl> throw new ArithmeticException ( <nl> " factorial value is too large to fit in a long " ) ; <nl> } <nl> if ( n < 0 ) { <nl> throw new IllegalArgumentException ( " must have n > = 0 for n ! " ) ; <nl> } <nl> - if ( n < 21 ) { <nl> - return factorial ( n ) ; <nl> - } <nl> return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; <nl> } <nl> if ( n < 0 ) { <nl> throw new IllegalArgumentException ( " must have n > 0 for n ! " ) ; <nl> } <nl> - if ( n < 21 ) { <nl> - return Math . log ( factorial ( n ) ) ; <nl> - } <nl> double logSum = 0 ; <nl> for ( int i = 2 ; i < = n ; i + + ) { <nl> logSum + = Math . log ( ( double ) i ) ; <nl> 
1<ml>Math_20.src.patch<ml>Math_20.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java <nl> * @ return the original objective variables , possibly repaired . <nl> * / <nl> public double [ ] repairAndDecode ( final double [ ] x ) { <nl> - return boundaries ! = null & & isRepairMode ? <nl> - decode ( repair ( x ) ) : <nl> + return <nl> decode ( x ) ; <nl> } <nl> 
1<ml>Math_104.src.patch<ml>Math_104.src.patch<ml>mmm a / src / java / org / apache / commons / math / special / Gamma . java <nl> ppp b / src / java / org / apache / commons / math / special / Gamma . java <nl> private static final long serialVersionUID = - 6587513359895466954L ; <nl> / * * Maximum allowed numerical error . * / <nl> - private static final double DEFAULT_EPSILON = 10e - 15 ; <nl> + private static final double DEFAULT_EPSILON = 10e - 9 ; <nl> / * * Lanczos coefficients * / <nl> private static double [ ] lanczos = <nl> 
1<ml>Math_15.src.patch<ml>Math_15.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> / * * 2 ^ 52 - double numbers this large must be integral ( no fraction ) or NaN or Infinite * / <nl> private static final double TWO_POWER_52 = 4503599627370496 . 0 ; <nl> / * * 2 ^ 53 - double numbers this large must be even . * / <nl> - private static final double TWO_POWER_53 = 2 * TWO_POWER_52 ; <nl> / * * Constant : { @ value } . * / <nl> private static final double F_1_3 = 1d / 3d ; <nl> / * Handle special case x < 0 * / <nl> if ( x < 0 ) { <nl> / / y is an even integer in this case <nl> - if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { <nl> + if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { <nl> return pow ( - x , y ) ; <nl> } <nl> 
1<ml>Math_28.src.patch<ml>Math_28.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java <nl> / / there ' s a degeneracy as indicated by a tie in the minimum ratio test <nl> / / 1 . check if there ' s an artificial variable that can be forced out of the basis <nl> - if ( tableau . getNumArtificialVariables ( ) > 0 ) { <nl> for ( Integer row : minRatioPositions ) { <nl> for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { <nl> int column = i + tableau . getArtificialVariableOffset ( ) ; <nl> } <nl> } <nl> } <nl> - } <nl> / / 2 . apply Bland ' s rule to prevent cycling : <nl> / / take the row for which the corresponding basic variable has the smallest index <nl> / / Additional heuristic : if we did not get a solution after half of maxIterations <nl> / / revert to the simple case of just returning the top - most row <nl> / / This heuristic is based on empirical data gathered while investigating MATH - 828 . <nl> - if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { <nl> Integer minRow = null ; <nl> int minIndex = tableau . getWidth ( ) ; <nl> for ( Integer row : minRatioPositions ) { <nl> } <nl> } <nl> return minRow ; <nl> - } <nl> } <nl> return minRatioPositions . get ( 0 ) ; <nl> } <nl> 
1<ml>Math_2.src.patch<ml>Math_2.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / HypergeometricDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / HypergeometricDistribution . java <nl> * size { @ code n } , the mean is { @ code n * m / N } . <nl> * / <nl> public double getNumericalMean ( ) { <nl> - return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; <nl> + return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; <nl> } <nl> / * * <nl> 
1<ml>Math_52.src.patch<ml>Math_52.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotation . java <nl> ppp b / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotation . java <nl> Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; <nl> Vector3D u3 = u1 . crossProduct ( u2 ) ; <nl> double c = k . dotProduct ( u3 ) ; <nl> - final double inPlaneThreshold = 0 . 001 ; <nl> - if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { <nl> + if ( c = = 0 ) { <nl> / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane <nl> / / we try other vectors <nl> Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; <nl> Vector3D u2Prime = u1 . crossProduct ( u3 ) ; <nl> c = k . dotProduct ( u2Prime ) ; <nl> - if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { <nl> + if ( c = = 0 ) { <nl> / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , <nl> / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) <nl> k = v2Su2 . crossProduct ( v3Su3 ) ; ; <nl> c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; <nl> - if ( c < = 0 ) { <nl> + if ( c = = 0 ) { <nl> / / the ( q1 , q2 , q3 ) vector is aligned with everything <nl> / / this is really the identity rotation <nl> q0 = 1 . 0 ; <nl> 
1<ml>Math_46.src.patch<ml>Math_46.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math / complex / Complex . java <nl> if ( divisor . isZero ) { <nl> / / return isZero ? NaN : INF ; / / See MATH - 657 <nl> - return NaN ; <nl> + return isZero ? NaN : INF ; <nl> } <nl> if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { <nl> } <nl> if ( divisor = = 0d ) { <nl> / / return isZero ? NaN : INF ; / / See MATH - 657 <nl> - return NaN ; <nl> + return isZero ? NaN : INF ; <nl> } <nl> if ( Double . isInfinite ( divisor ) ) { <nl> return ! isInfinite ( ) ? ZERO : NaN ; <nl> 
1<ml>Math_67.src.patch<ml>Math_67.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / MultiStartUnivariateRealOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / MultiStartUnivariateRealOptimizer . java <nl> / * * { @ inheritDoc } * / <nl> public double getFunctionValue ( ) { <nl> - return optimaValues [ 0 ] ; <nl> + return optimizer . getFunctionValue ( ) ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> public double getResult ( ) { <nl> - return optima [ 0 ] ; <nl> + return optimizer . getResult ( ) ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> 
1<ml>Math_73.src.patch<ml>Math_73.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; <nl> } <nl> - if ( yMin * yMax > 0 ) { <nl> - throw MathRuntimeException . createIllegalArgumentException ( <nl> - NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; <nl> - } <nl> / / full Brent algorithm starting with provided initial guess <nl> return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; <nl> 
1<ml>Math_25.src.patch<ml>Math_25.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / fitting / HarmonicFitter . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / fitting / HarmonicFitter . java <nl> } <nl> a = 0 . 5 * ( yMax - yMin ) ; <nl> } else { <nl> - if ( c2 = = 0 ) { <nl> / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser <nl> / / procedure cannot produce sensible results . <nl> - throw new MathIllegalStateException ( LocalizedFormats . ZERO_DENOMINATOR ) ; <nl> - } <nl> a = FastMath . sqrt ( c1 / c2 ) ; <nl> omega = FastMath . sqrt ( c2 / c3 ) ; <nl> 
1<ml>Math_96.src.patch<ml>Math_96.src.patch<ml>mmm a / src / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / java / org / apache / commons / math / complex / Complex . java <nl> if ( rhs . isNaN ( ) ) { <nl> ret = this . isNaN ( ) ; <nl> } else { <nl> - ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; <nl> + ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; <nl> } <nl> } catch ( ClassCastException ex ) { <nl> / / ignore exception <nl> 
1<ml>Math_82.src.patch<ml>Math_82.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java <nl> for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { <nl> final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; <nl> final double entry = tableau . getEntry ( i , col ) ; <nl> - if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { <nl> + if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { <nl> final double ratio = rhs / entry ; <nl> if ( ratio < minRatio ) { <nl> minRatio = ratio ; <nl> 
1<ml>Math_31.src.patch<ml>Math_31.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / util / ContinuedFraction . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / ContinuedFraction . java <nl> int n = 1 ; <nl> double dPrev = 0 . 0 ; <nl> + double p0 = 1 . 0 ; <nl> + double q1 = 1 . 0 ; <nl> double cPrev = hPrev ; <nl> double hN = hPrev ; <nl> final double a = getA ( n , x ) ; <nl> final double b = getB ( n , x ) ; <nl> - double dN = a + b * dPrev ; <nl> - if ( Precision . equals ( dN , 0 . 0 , small ) ) { <nl> - dN = small ; <nl> - } <nl> - double cN = a + b / cPrev ; <nl> - if ( Precision . equals ( cN , 0 . 0 , small ) ) { <nl> - cN = small ; <nl> + double cN = a * hPrev + b * p0 ; <nl> + double q2 = a * q1 + b * dPrev ; <nl> + if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { <nl> + double scaleFactor = 1d ; <nl> + double lastScaleFactor = 1d ; <nl> + final int maxPower = 5 ; <nl> + final double scale = FastMath . max ( a , b ) ; <nl> + if ( scale < = 0 ) { / / Can ' t scale <nl> + throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; <nl> + } <nl> + for ( int i = 0 ; i < maxPower ; i + + ) { <nl> + lastScaleFactor = scaleFactor ; <nl> + scaleFactor * = scale ; <nl> + if ( a ! = 0 . 0 & & a > b ) { <nl> + cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; <nl> + q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; <nl> + } else if ( b ! = 0 ) { <nl> + cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; <nl> + q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; <nl> + } <nl> + if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { <nl> + break ; <nl> + } <nl> + } <nl> } <nl> - dN = 1 / dN ; <nl> - final double deltaN = cN * dN ; <nl> - hN = hPrev * deltaN ; <nl> + final double deltaN = cN / q2 / cPrev ; <nl> + hN = cPrev * deltaN ; <nl> if ( Double . isInfinite ( hN ) ) { <nl> throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , <nl> break ; <nl> } <nl> - dPrev = dN ; <nl> - cPrev = cN ; <nl> - hPrev = hN ; <nl> + dPrev = q1 ; <nl> + cPrev = cN / q2 ; <nl> + p0 = hPrev ; <nl> + hPrev = cN ; <nl> + q1 = q2 ; <nl> n + + ; <nl> } <nl> 
1<ml>Math_10.src.patch<ml>Math_10.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / analysis / differentiation / DSCompiler . java <nl> ppp b / src / main / java / org / apache / commons / math3 / analysis / differentiation / DSCompiler . java <nl> } <nl> / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly <nl> - result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; <nl> } <nl> 
1<ml>Math_101.src.patch<ml>Math_101.src.patch<ml>mmm a / src / java / org / apache / commons / math / complex / ComplexFormat . java <nl> ppp b / src / java / org / apache / commons / math / complex / ComplexFormat . java <nl> int n = getImaginaryCharacter ( ) . length ( ) ; <nl> startIndex = pos . getIndex ( ) ; <nl> int endIndex = startIndex + n ; <nl> - if ( ( startIndex > = source . length ( ) ) | | <nl> - ( endIndex > source . length ( ) ) | | <nl> + if ( <nl> source . substring ( startIndex , endIndex ) . compareTo ( <nl> getImaginaryCharacter ( ) ) ! = 0 ) { <nl> / / set index back to initial , error index should be the start index <nl> 
1<ml>Math_61.src.patch<ml>Math_61.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / distribution / PoissonDistributionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / distribution / PoissonDistributionImpl . java <nl> import java . io . Serializable ; <nl> import org . apache . commons . math . MathException ; <nl> - import org . apache . commons . math . exception . NotStrictlyPositiveException ; <nl> + import org . apache . commons . math . MathRuntimeException ; <nl> import org . apache . commons . math . exception . util . LocalizedFormats ; <nl> import org . apache . commons . math . special . Gamma ; <nl> import org . apache . commons . math . util . MathUtils ; <nl> * / <nl> public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { <nl> if ( p < = 0 ) { <nl> - throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; <nl> + throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; <nl> } <nl> mean = p ; <nl> normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ; <nl> 
1<ml>Math_54.src.patch<ml>Math_54.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / dfp / Dfp . java <nl> ppp b / src / main / java / org / apache / commons / math / dfp / Dfp . java <nl> / / Zero or sub - normal <nl> if ( x = = 0 ) { <nl> / / make sure 0 has the right sign <nl> - if ( ( bits & 0x8000000000000000L ) ! = 0 ) { <nl> - sign = - 1 ; <nl> - } <nl> return ; <nl> } <nl> Dfp y = this ; <nl> boolean negate = false ; <nl> - int cmp0 = compare ( this , getZero ( ) ) ; <nl> - if ( cmp0 = = 0 ) { <nl> - return sign < 0 ? - 0 . 0 : + 0 . 0 ; <nl> - } else if ( cmp0 < 0 ) { <nl> + if ( lessThan ( getZero ( ) ) ) { <nl> y = negate ( ) ; <nl> negate = true ; <nl> } <nl> 
1<ml>Math_4.src.patch<ml>Math_4.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / SubLine . java <nl> / / compute the intersection on infinite line <nl> Vector3D v1D = line . intersection ( subLine . line ) ; <nl> - if ( v1D = = null ) { <nl> - return null ; <nl> - } <nl> / / check location of point with respect to first sub - line <nl> Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; <nl> mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / SubLine . java <nl> / / compute the intersection on infinite line <nl> Vector2D v2D = line1 . intersection ( line2 ) ; <nl> - if ( v2D = = null ) { <nl> - return null ; <nl> - } <nl> / / check location of point with respect to first sub - line <nl> Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; <nl> 
1<ml>Math_40.src.patch<ml>Math_40.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java <nl> double targetY ; <nl> if ( agingA > = MAXIMAL_AGING ) { <nl> / / we keep updating the high bracket , try to compensate this <nl> - final int p = agingA - MAXIMAL_AGING ; <nl> - final double weightA = ( 1 < < p ) - 1 ; <nl> - final double weightB = p + 1 ; <nl> - targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; <nl> + targetY = - REDUCTION_FACTOR * yB ; <nl> } else if ( agingB > = MAXIMAL_AGING ) { <nl> / / we keep updating the low bracket , try to compensate this <nl> - final int p = agingB - MAXIMAL_AGING ; <nl> - final double weightA = p + 1 ; <nl> - final double weightB = ( 1 < < p ) - 1 ; <nl> - targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; <nl> + targetY = - REDUCTION_FACTOR * yA ; <nl> } else { <nl> / / bracketing is balanced , try to find the root itself <nl> targetY = 0 ; <nl> 
1<ml>Math_89.src.patch<ml>Math_89.src.patch<ml>mmm a / src / java / org / apache / commons / math / stat / Frequency . java <nl> ppp b / src / java / org / apache / commons / math / stat / Frequency . java <nl> * / <nl> @ Deprecated <nl> public void addValue ( Object v ) { <nl> - if ( v instanceof Comparable < ? > ) { <nl> addValue ( ( Comparable < ? > ) v ) ; <nl> - } else { <nl> - throw new IllegalArgumentException ( " Object must implement Comparable " ) ; <nl> - } <nl> } <nl> / * * <nl> 
1<ml>Math_16.src.patch<ml>Math_16.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / FastMath . java <nl> * / <nl> public class FastMath { <nl> / * * StrictMath . log ( Double . MAX_VALUE ) : { @ value } * / <nl> - private static final double LOG_MAX_VALUE = StrictMath . log ( Double . MAX_VALUE ) ; <nl> / * * Archimede ' s constant PI , ratio of circle circumference to diameter . * / <nl> public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; <nl> / / exp ( - z ) can be ignored in comparison with exp ( z ) <nl> if ( x > 20 ) { <nl> - if ( x > = LOG_MAX_VALUE ) { <nl> / / Avoid overflow ( MATH - 905 ) . <nl> - final double t = exp ( 0 . 5 * x ) ; <nl> - return ( 0 . 5 * t ) * t ; <nl> - } else { <nl> return 0 . 5 * exp ( x ) ; <nl> } <nl> - } else if ( x < - 20 ) { <nl> - if ( x < = - LOG_MAX_VALUE ) { <nl> + if ( x < - 20 ) { <nl> / / Avoid overflow ( MATH - 905 ) . <nl> - final double t = exp ( - 0 . 5 * x ) ; <nl> - return ( 0 . 5 * t ) * t ; <nl> - } else { <nl> return 0 . 5 * exp ( - x ) ; <nl> - } <nl> } <nl> final double hiPrec [ ] = new double [ 2 ] ; <nl> / / exp ( - z ) can be ignored in comparison with exp ( z ) <nl> if ( x > 20 ) { <nl> - if ( x > = LOG_MAX_VALUE ) { <nl> / / Avoid overflow ( MATH - 905 ) . <nl> - final double t = exp ( 0 . 5 * x ) ; <nl> - return ( 0 . 5 * t ) * t ; <nl> - } else { <nl> return 0 . 5 * exp ( x ) ; <nl> } <nl> - } else if ( x < - 20 ) { <nl> - if ( x < = - LOG_MAX_VALUE ) { <nl> + if ( x < - 20 ) { <nl> / / Avoid overflow ( MATH - 905 ) . <nl> - final double t = exp ( - 0 . 5 * x ) ; <nl> - return ( - 0 . 5 * t ) * t ; <nl> - } else { <nl> return - 0 . 5 * exp ( - x ) ; <nl> - } <nl> } <nl> if ( x = = 0 ) { <nl> 
1<ml>Math_78.src.patch<ml>Math_78.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / ode / events / EventState . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / events / EventState . java <nl> if ( g0Positive ^ ( gb > = 0 ) ) { <nl> / / there is a sign change : an event is expected during this step <nl> - if ( ga * gb > 0 ) { <nl> / / this is a corner case : <nl> / / - there was an event near ta , <nl> / / - there is another event between ta and tb <nl> / / this implies that the real sign of ga is the same as gb , so we need to slightly <nl> / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain <nl> / / about bracketing <nl> - final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; <nl> - for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { <nl> - ta + = epsilon ; <nl> - interpolator . setInterpolatedTime ( ta ) ; <nl> - ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; <nl> - } <nl> - if ( ga * gb > 0 ) { <nl> / / this should never happen <nl> - throw MathRuntimeException . createInternalError ( null ) ; <nl> - } <nl> - } <nl> / / variation direction , with respect to the integration direction <nl> increasing = gb > = ga ; <nl> 
1<ml>Math_90.src.patch<ml>Math_90.src.patch<ml>mmm a / src / java / org / apache / commons / math / stat / Frequency . java <nl> ppp b / src / java / org / apache / commons / math / stat / Frequency . java <nl> * / <nl> @ Deprecated <nl> public void addValue ( Object v ) { <nl> - addValue ( ( Comparable < ? > ) v ) ; <nl> - } <nl> / * * <nl> * Adds 1 to the frequency count for v . <nl> * @ param v the value to add . <nl> * @ throws IllegalArgumentException if < code > v < / code > is not comparable with previous entries <nl> * / <nl> - public void addValue ( Comparable < ? > v ) { <nl> Object obj = v ; <nl> if ( v instanceof Integer ) { <nl> obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ; <nl> 
1<ml>Math_59.src.patch<ml>Math_59.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / util / FastMath . java <nl> ppp b / src / main / java / org / apache / commons / math / util / FastMath . java <nl> * @ return b if a is lesser or equal to b , a otherwise <nl> * / <nl> public static float max ( final float a , final float b ) { <nl> - return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; <nl> + return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; <nl> } <nl> / * * Compute the maximum of two values <nl> 
1<ml>Math_9.src.patch<ml>Math_9.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / Line . java <nl> ppp b / src / main / java / org / apache / commons / math3 / geometry / euclidean / threed / Line . java <nl> * @ return a new instance , with reversed direction <nl> * / <nl> public Line revert ( ) { <nl> - final Line reverted = new Line ( this ) ; <nl> - reverted . direction = reverted . direction . negate ( ) ; <nl> + final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; <nl> return reverted ; <nl> } <nl> 
1<ml>Math_23.src.patch<ml>Math_23.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / univariate / BrentOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / univariate / BrentOptimizer . java <nl> UnivariatePointValuePair current <nl> = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; <nl> / / Best point encountered so far ( which is the initial guess ) . <nl> - UnivariatePointValuePair best = current ; <nl> int iter = 0 ; <nl> while ( true ) { <nl> / / User - defined convergence checker . <nl> previous = current ; <nl> current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; <nl> - best = best ( best , <nl> - best ( current , <nl> - previous , <nl> - isMinim ) , <nl> - isMinim ) ; <nl> if ( checker ! = null ) { <nl> if ( checker . converged ( iter , previous , current ) ) { <nl> - return best ; <nl> + return best ( current , previous , isMinim ) ; <nl> } <nl> } <nl> } <nl> } <nl> } else { / / Default termination ( Brent ' s criterion ) . <nl> - return best ( best , <nl> + return <nl> best ( current , <nl> previous , <nl> - isMinim ) , <nl> isMinim ) ; <nl> } <nl> + + iter ; <nl> 
1<ml>Math_37.src.patch<ml>Math_37.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math / complex / Complex . java <nl> * @ since 1 . 2 <nl> * / <nl> public Complex tan ( ) { <nl> - if ( isNaN | | Double . isInfinite ( real ) ) { <nl> + if ( isNaN ) { <nl> return NaN ; <nl> } <nl> - if ( imaginary > 20 . 0 ) { <nl> - return createComplex ( 0 . 0 , 1 . 0 ) ; <nl> - } <nl> - if ( imaginary < - 20 . 0 ) { <nl> - return createComplex ( 0 . 0 , - 1 . 0 ) ; <nl> - } <nl> double real2 = 2 . 0 * real ; <nl> double imaginary2 = 2 . 0 * imaginary ; <nl> * @ since 1 . 2 <nl> * / <nl> public Complex tanh ( ) { <nl> - if ( isNaN | | Double . isInfinite ( imaginary ) ) { <nl> + if ( isNaN ) { <nl> return NaN ; <nl> } <nl> - if ( real > 20 . 0 ) { <nl> - return createComplex ( 1 . 0 , 0 . 0 ) ; <nl> - } <nl> - if ( real < - 20 . 0 ) { <nl> - return createComplex ( - 1 . 0 , 0 . 0 ) ; <nl> - } <nl> double real2 = 2 . 0 * real ; <nl> double imaginary2 = 2 . 0 * imaginary ; <nl> double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ; <nl> 
1<ml>Math_84.src.patch<ml>Math_84.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java <nl> protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) <nl> throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { <nl> - final RealConvergenceChecker checker = getConvergenceChecker ( ) ; <nl> while ( true ) { <nl> incrementIterationsCounter ( ) ; <nl> final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; <nl> if ( comparator . compare ( contracted , best ) < 0 ) { <nl> / / accept the contracted simplex <nl> - return ; <nl> - } <nl> / / check convergence <nl> - final int iter = getIterations ( ) ; <nl> - boolean converged = true ; <nl> - for ( int i = 0 ; i < simplex . length ; + + i ) { <nl> - converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; <nl> - } <nl> - if ( converged ) { <nl> return ; <nl> } <nl> 
1<ml>Math_47.src.patch<ml>Math_47.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math / complex / Complex . java <nl> / * * Record whether this complex number is infinite . * / <nl> private final transient boolean isInfinite ; <nl> / * * Record whether this complex number is zero . * / <nl> - private final transient boolean isZero ; <nl> / * * <nl> * Create a complex number given only the real part . <nl> isNaN = Double . isNaN ( real ) | | Double . isNaN ( imaginary ) ; <nl> isInfinite = ! isNaN & & <nl> ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) ) ; <nl> - isZero = real = = 0 & & imaginary = = 0 ; <nl> } <nl> / * * <nl> return NaN ; <nl> } <nl> - if ( divisor . isZero ) { <nl> - return isZero ? NaN : INF ; <nl> + if ( divisor . getReal ( ) = = 0 . 0 & & divisor . getImaginary ( ) = = 0 . 0 ) { <nl> + return NaN ; <nl> } <nl> if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { <nl> return NaN ; <nl> } <nl> if ( divisor = = 0d ) { <nl> - return isZero ? NaN : INF ; <nl> + return NaN ; <nl> } <nl> if ( Double . isInfinite ( divisor ) ) { <nl> return ! isInfinite ( ) ? ZERO : NaN ; <nl> 
1<ml>Math_29.src.patch<ml>Math_29.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / linear / OpenMapRealVector . java <nl> ppp b / src / main / java / org / apache / commons / math3 / linear / OpenMapRealVector . java <nl> * this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then <nl> * this [ i ] / v [ i ] = NaN , and not 0d . <nl> * / <nl> - final int n = getDimension ( ) ; <nl> - for ( int i = 0 ; i < n ; i + + ) { <nl> - res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; <nl> + Iterator iter = entries . iterator ( ) ; <nl> + while ( iter . hasNext ( ) ) { <nl> + iter . advance ( ) ; <nl> + res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; <nl> } <nl> return res ; <nl> } <nl> * <nl> * These special cases are handled below . <nl> * / <nl> - if ( v . isNaN ( ) | | v . isInfinite ( ) ) { <nl> - final int n = getDimension ( ) ; <nl> - for ( int i = 0 ; i < n ; i + + ) { <nl> - final double y = v . getEntry ( i ) ; <nl> - if ( Double . isNaN ( y ) ) { <nl> - res . setEntry ( i , Double . NaN ) ; <nl> - } else if ( Double . isInfinite ( y ) ) { <nl> - final double x = this . getEntry ( i ) ; <nl> - res . setEntry ( i , x * y ) ; <nl> - } <nl> - } <nl> - } <nl> return res ; <nl> } <nl> 
1<ml>Math_3.src.patch<ml>Math_3.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / util / MathArrays . java <nl> ppp b / src / main / java / org / apache / commons / math3 / util / MathArrays . java <nl> throw new DimensionMismatchException ( len , b . length ) ; <nl> } <nl> - if ( len = = 1 ) { <nl> / / Revert to scalar multiplication . <nl> - return a [ 0 ] * b [ 0 ] ; <nl> - } <nl> final double [ ] prodHigh = new double [ len ] ; <nl> double prodLowSum = 0 ; <nl> 
1<ml>Math_53.src.patch<ml>Math_53.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / complex / Complex . java <nl> ppp b / src / main / java / org / apache / commons / math / complex / Complex . java <nl> public Complex add ( Complex rhs ) <nl> throws NullArgumentException { <nl> MathUtils . checkNotNull ( rhs ) ; <nl> - if ( isNaN | | rhs . isNaN ) { <nl> - return NaN ; <nl> - } <nl> return createComplex ( real + rhs . getReal ( ) , <nl> imaginary + rhs . getImaginary ( ) ) ; <nl> } <nl> 
1<ml>Math_72.src.patch<ml>Math_72.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> ppp b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java <nl> / / return the first endpoint if it is good enough <nl> double yMin = f . value ( min ) ; <nl> if ( Math . abs ( yMin ) < = functionValueAccuracy ) { <nl> - setResult ( min , 0 ) ; <nl> + setResult ( yMin , 0 ) ; <nl> return result ; <nl> } <nl> / / return the second endpoint if it is good enough <nl> double yMax = f . value ( max ) ; <nl> if ( Math . abs ( yMax ) < = functionValueAccuracy ) { <nl> - setResult ( max , 0 ) ; <nl> + setResult ( yMax , 0 ) ; <nl> return result ; <nl> } <nl> 
1<ml>Math_66.src.patch<ml>Math_66.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / univariate / BrentOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / univariate / BrentOptimizer . java <nl> * Construct a solver . <nl> * / <nl> public BrentOptimizer ( ) { <nl> - setMaxEvaluations ( 1000 ) ; <nl> + setMaxEvaluations ( Integer . MAX_VALUE ) ; <nl> setMaximalIterationCount ( 100 ) ; <nl> - setAbsoluteAccuracy ( 1e - 11 ) ; <nl> - setRelativeAccuracy ( 1e - 9 ) ; <nl> + setAbsoluteAccuracy ( 1E - 10 ) ; <nl> + setRelativeAccuracy ( 1 . 0e - 14 ) ; <nl> } <nl> / * * <nl> * / <nl> protected double doOptimize ( ) <nl> throws MaxIterationsExceededException , FunctionEvaluationException { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { <nl> + clearResult ( ) ; <nl> return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , <nl> - getMin ( ) , getStartValue ( ) , getMax ( ) , <nl> + f , goalType , min , startValue , max , <nl> getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; <nl> } <nl> + public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { <nl> + return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; <nl> + } <nl> / * * <nl> * Find the minimum of the function within the interval { @ code ( lo , hi ) } . <nl> * the function . <nl> * / <nl> private double localMin ( boolean isMinim , <nl> + UnivariateRealFunction f , <nl> + GoalType goalType , <nl> double lo , double mid , double hi , <nl> double eps , double t ) <nl> throws MaxIterationsExceededException , FunctionEvaluationException { <nl> double w = x ; <nl> double d = 0 ; <nl> double e = 0 ; <nl> - double fx = computeObjectiveValue ( x ) ; <nl> - if ( ! isMinim ) { <nl> + double fx = computeObjectiveValue ( f , x ) ; <nl> + if ( goalType = = GoalType . MAXIMIZE ) { <nl> fx = - fx ; <nl> } <nl> double fv = fx ; <nl> double fw = fx ; <nl> - while ( true ) { <nl> + int count = 0 ; <nl> + while ( count < maximalIterationCount ) { <nl> double m = 0 . 5 * ( a + b ) ; <nl> final double tol1 = eps * Math . abs ( x ) + t ; <nl> final double tol2 = 2 * tol1 ; <nl> u = x + d ; <nl> } <nl> - double fu = computeObjectiveValue ( u ) ; <nl> - if ( ! isMinim ) { <nl> + double fu = computeObjectiveValue ( f , u ) ; <nl> + if ( goalType = = GoalType . MAXIMIZE ) { <nl> fu = - fu ; <nl> } <nl> } <nl> } <nl> } else { / / termination <nl> - setFunctionValue ( isMinim ? fx : - fx ) ; <nl> + setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; <nl> return x ; <nl> } <nl> - incrementIterationsCounter ( ) ; <nl> + + + count ; <nl> } <nl> + throw new MaxIterationsExceededException ( maximalIterationCount ) ; <nl> } <nl> } <nl> 
1<ml>Math_83.src.patch<ml>Math_83.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> * / <nl> private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { <nl> Integer row = null ; <nl> - int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; <nl> + int start = getNumObjectiveFunctions ( ) ; <nl> for ( int i = start ; i < getHeight ( ) ; i + + ) { <nl> if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { <nl> row = i ; <nl> * / <nl> protected RealPointValuePair getSolution ( ) { <nl> double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; <nl> - Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; <nl> + Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; <nl> double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; <nl> Set < Integer > basicRows = new HashSet < Integer > ( ) ; <nl> for ( int i = 0 ; i < coefficients . length ; i + + ) { <nl> - Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; <nl> + Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; <nl> if ( basicRows . contains ( basicRow ) ) { <nl> / / if multiple variables can take a given value <nl> / / then we choose the first and set the rest equal to 0 <nl> 
1<ml>Math_24.src.patch<ml>Math_24.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / optimization / univariate / BrentOptimizer . java <nl> ppp b / src / main / java / org / apache / commons / math3 / optimization / univariate / BrentOptimizer . java <nl> if ( checker ! = null ) { <nl> if ( checker . converged ( iter , previous , current ) ) { <nl> - return best ( current , previous , isMinim ) ; <nl> + return current ; <nl> } <nl> } <nl> } <nl> } <nl> } else { / / Default termination ( Brent ' s criterion ) . <nl> - return best ( current , previous , isMinim ) ; <nl> + return current ; <nl> } <nl> + + iter ; <nl> } <nl> 
1<ml>Math_97.src.patch<ml>Math_97.src.patch<ml>mmm a / src / java / org / apache / commons / math / analysis / BrentSolver . java <nl> ppp b / src / java / org / apache / commons / math / analysis / BrentSolver . java <nl> / / Verify bracketing <nl> double sign = yMin * yMax ; <nl> - if ( sign > 0 ) { <nl> + if ( sign > = 0 ) { <nl> / / check if either value is close to a zero <nl> - if ( Math . abs ( yMin ) < = functionValueAccuracy ) { <nl> - setResult ( min , 0 ) ; <nl> - ret = min ; <nl> - } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { <nl> - setResult ( max , 0 ) ; <nl> - ret = max ; <nl> - } else { <nl> / / neither value is close to zero and min and max do not bracket root . <nl> throw new IllegalArgumentException <nl> ( " Function values at endpoints do not have different signs . " + <nl> " Endpoints : [ " + min + " , " + max + " ] " + <nl> " Values : [ " + yMin + " , " + yMax + " ] " ) ; <nl> - } <nl> - } else if ( sign < 0 ) { <nl> + } else { <nl> / / solve using only the first endpoint as initial guess <nl> ret = solve ( min , yMin , max , yMax , min , yMin ) ; <nl> - } else { <nl> / / either min or max is a root <nl> - if ( yMin = = 0 . 0 ) { <nl> - ret = min ; <nl> - } else { <nl> - ret = max ; <nl> - } <nl> } <nl> return ret ; <nl> 
1<ml>Math_11.src.patch<ml>Math_11.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / MultivariateNormalDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / MultivariateNormalDistribution . java <nl> throw new DimensionMismatchException ( vals . length , dim ) ; <nl> } <nl> - return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * <nl> + return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * <nl> FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * <nl> getExponentTerm ( vals ) ; <nl> } <nl> 
1<ml>Math_100.src.patch<ml>Math_100.src.patch<ml>mmm a / src / java / org / apache / commons / math / estimation / AbstractEstimator . java <nl> ppp b / src / java / org / apache / commons / math / estimation / AbstractEstimator . java <nl> / / compute transpose ( J ) . J , avoiding building big intermediate matrices <nl> final int rows = problem . getMeasurements ( ) . length ; <nl> - final int cols = problem . getUnboundParameters ( ) . length ; <nl> + final int cols = problem . getAllParameters ( ) . length ; <nl> final int max = cols * rows ; <nl> double [ ] [ ] jTj = new double [ cols ] [ cols ] ; <nl> for ( int i = 0 ; i < cols ; + + i ) { <nl> public double [ ] guessParametersErrors ( EstimationProblem problem ) <nl> throws EstimationException { <nl> int m = problem . getMeasurements ( ) . length ; <nl> - int p = problem . getUnboundParameters ( ) . length ; <nl> + int p = problem . getAllParameters ( ) . length ; <nl> if ( m < = p ) { <nl> throw new EstimationException ( " no degrees of freedom ( { 0 } measurements , { 1 } parameters ) " , <nl> new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; <nl> } <nl> - double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; <nl> + double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; <nl> final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; <nl> double [ ] [ ] covar = getCovariances ( problem ) ; <nl> for ( int i = 0 ; i < errors . length ; + + i ) { <nl> 
1<ml>Math_74.src.patch<ml>Math_74.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> ppp b / src / main / java / org / apache / commons / math / ode / nonstiff / EmbeddedRungeKuttaIntegrator . java <nl> } <nl> if ( firstTime ) { <nl> - final double [ ] scale = new double [ y0 . length ] ; <nl> + final double [ ] scale ; <nl> if ( vecAbsoluteTolerance = = null ) { <nl> - for ( int i = 0 ; i < scale . length ; + + i ) { <nl> - scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; <nl> - } <nl> + scale = new double [ y0 . length ] ; <nl> + java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; <nl> } else { <nl> - for ( int i = 0 ; i < scale . length ; + + i ) { <nl> - scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; <nl> - } <nl> + scale = vecAbsoluteTolerance ; <nl> } <nl> hNew = initializeStep ( equations , forward , getOrder ( ) , scale , <nl> stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ; <nl> 
1<ml>Math_60.src.patch<ml>Math_60.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / distribution / NormalDistributionImpl . java <nl> ppp b / src / main / java / org / apache / commons / math / distribution / NormalDistributionImpl . java <nl> * / <nl> public double cumulativeProbability ( double x ) throws MathException { <nl> final double dev = x - mean ; <nl> - if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { <nl> - return dev < 0 ? 0 . 0d : 1 . 0d ; <nl> - } <nl> + try { <nl> return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / <nl> ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; <nl> + } catch ( MaxIterationsExceededException ex ) { <nl> + if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 <nl> + return 0 ; <nl> + } else if ( x > ( mean + 20 * standardDeviation ) ) { <nl> + return 1 ; <nl> + } else { <nl> + throw ex ; <nl> + } <nl> + } <nl> } <nl> / * * <nl> 
1<ml>Math_41.src.patch<ml>Math_41.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java <nl> ppp b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java <nl> } <nl> double sumWts = 0 ; <nl> - for ( int i = begin ; i < begin + length ; i + + ) { <nl> + for ( int i = 0 ; i < weights . length ; i + + ) { <nl> sumWts + = weights [ i ] ; <nl> } <nl> 
1<ml>Math_88.src.patch<ml>Math_88.src.patch<ml>mmm a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> ppp b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java <nl> Integer basicRow = <nl> getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; <nl> double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; <nl> - Set < Integer > basicRows = new HashSet < Integer > ( ) ; <nl> for ( int i = 0 ; i < coefficients . length ; i + + ) { <nl> basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; <nl> - if ( basicRows . contains ( basicRow ) ) { <nl> / / if multiple variables can take a given value <nl> / / then we choose the first and set the rest equal to 0 <nl> - coefficients [ i ] = 0 ; <nl> - } else { <nl> - basicRows . add ( basicRow ) ; <nl> coefficients [ i ] = <nl> ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - <nl> ( restrictToNonNegative ? 0 : mostNegative ) ; <nl> + if ( basicRow ! = null ) { <nl> + for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { <nl> + if ( tableau . getEntry ( basicRow , j ) = = 1 ) { <nl> + coefficients [ i ] = 0 ; <nl> + } <nl> + } <nl> } <nl> } <nl> return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; <nl> 
1<ml>Math_55.src.patch<ml>Math_55.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / geometry / Vector3D . java <nl> ppp b / src / main / java / org / apache / commons / math / geometry / Vector3D . java <nl> * / <nl> public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { <nl> - final double n1 = v1 . getNormSq ( ) ; <nl> - final double n2 = v2 . getNormSq ( ) ; <nl> - if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { <nl> - return ZERO ; <nl> - } <nl> / / rescale both vectors without losing precision , <nl> / / to ensure their norm are the same order of magnitude <nl> - final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; <nl> - final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; <nl> - final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; <nl> - final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; <nl> - final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; <nl> - final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; <nl> - final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; <nl> / / we reduce cancellation errors by preconditioning , <nl> / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute <nl> / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf <nl> / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 <nl> - final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; <nl> - final double rho = FastMath . rint ( 256 * ratio ) / 256 ; <nl> - final double x3 = x1 - rho * x2 ; <nl> - final double y3 = y1 - rho * y2 ; <nl> - final double z3 = z1 - rho * z2 ; <nl> / / compute cross product from v3 and v2 instead of v1 and v2 <nl> - return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; <nl> + return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; <nl> } <nl> 
1<ml>Math_17.src.patch<ml>Math_17.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / dfp / Dfp . java <nl> ppp b / src / main / java / org / apache / commons / math3 / dfp / Dfp . java <nl> * @ return product of this and x <nl> * / <nl> public Dfp multiply ( final int x ) { <nl> - if ( x > = 0 & & x < RADIX ) { <nl> return multiplyFast ( x ) ; <nl> - } else { <nl> - return multiply ( newInstance ( x ) ) ; <nl> - } <nl> } <nl> / * * Multiply this by a single digit 0 & lt ; = x & lt ; radix . <nl> 
1<ml>Math_106.src.patch<ml>Math_106.src.patch<ml>mmm a / src / java / org / apache / commons / math / fraction / ProperFractionFormat . java <nl> ppp b / src / java / org / apache / commons / math / fraction / ProperFractionFormat . java <nl> return null ; <nl> } <nl> - if ( num . intValue ( ) < 0 ) { <nl> / / minus signs should be leading , invalid expression <nl> - pos . setIndex ( initialIndex ) ; <nl> - return null ; <nl> - } <nl> / / parse ' / ' <nl> int startIndex = pos . getIndex ( ) ; <nl> return null ; <nl> } <nl> - if ( den . intValue ( ) < 0 ) { <nl> / / minus signs must be leading , invalid <nl> - pos . setIndex ( initialIndex ) ; <nl> - return null ; <nl> - } <nl> int w = whole . intValue ( ) ; <nl> int n = num . intValue ( ) ; <nl> 
1<ml>Math_36.src.patch<ml>Math_36.src.patch<ml>mmm a / src / main / java / org / apache / commons / math / fraction / BigFraction . java <nl> ppp b / src / main / java / org / apache / commons / math / fraction / BigFraction . java <nl> @ Override <nl> public double doubleValue ( ) { <nl> double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; <nl> - if ( Double . isNaN ( result ) ) { <nl> / / Numerator and / or denominator must be out of range : <nl> / / Calculate how far to shift them to put them in range . <nl> - int shift = Math . max ( numerator . bitLength ( ) , <nl> - denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; <nl> - result = numerator . shiftRight ( shift ) . doubleValue ( ) / <nl> - denominator . shiftRight ( shift ) . doubleValue ( ) ; <nl> - } <nl> return result ; <nl> } <nl> @ Override <nl> public float floatValue ( ) { <nl> float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; <nl> - if ( Double . isNaN ( result ) ) { <nl> / / Numerator and / or denominator must be out of range : <nl> / / Calculate how far to shift them to put them in range . <nl> - int shift = Math . max ( numerator . bitLength ( ) , <nl> - denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; <nl> - result = numerator . shiftRight ( shift ) . floatValue ( ) / <nl> - denominator . shiftRight ( shift ) . floatValue ( ) ; <nl> - } <nl> return result ; <nl> } <nl> 
1<ml>Math_85.src.patch<ml>Math_85.src.patch<ml>mmm a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> ppp b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java <nl> } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & <nl> ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; <nl> - if ( fa * fb > 0 . 0 ) { <nl> + if ( fa * fb > = 0 . 0 ) { <nl> throw new ConvergenceException ( <nl> " number of iterations = { 0 } , maximum iterations = { 1 } , " + <nl> " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + <nl> 
1<ml>Math_91.src.patch<ml>Math_91.src.patch<ml>mmm a / src / java / org / apache / commons / math / fraction / Fraction . java <nl> ppp b / src / java / org / apache / commons / math / fraction / Fraction . java <nl> * than < tt > object < / tt > , 0 if they are equal . <nl> * / <nl> public int compareTo ( Fraction object ) { <nl> - long nOd = ( ( long ) numerator ) * object . denominator ; <nl> - long dOn = ( ( long ) denominator ) * object . numerator ; <nl> + double nOd = doubleValue ( ) ; <nl> + double dOn = object . doubleValue ( ) ; <nl> return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; <nl> } <nl> 
1<ml>Math_8.src.patch<ml>Math_8.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java <nl> * @ throws NotStrictlyPositiveException if { @ code sampleSize } is not <nl> * positive . <nl> * / <nl> - public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { <nl> + public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { <nl> if ( sampleSize < = 0 ) { <nl> throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , <nl> sampleSize ) ; <nl> } <nl> - final Object [ ] out = new Object [ sampleSize ] ; <nl> + final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; <nl> for ( int i = 0 ; i < sampleSize ; i + + ) { <nl> out [ i ] = sample ( ) ; <nl> 
1<ml>Math_22.src.patch<ml>Math_22.src.patch<ml>mmm a / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / FDistribution . java <nl> / * * { @ inheritDoc } * / <nl> public boolean isSupportLowerBoundInclusive ( ) { <nl> - return false ; <nl> + return true ; <nl> } <nl> / * * { @ inheritDoc } * / <nl> mmm a / src / main / java / org / apache / commons / math3 / distribution / UniformRealDistribution . java <nl> ppp b / src / main / java / org / apache / commons / math3 / distribution / UniformRealDistribution . java <nl> / * * { @ inheritDoc } * / <nl> public boolean isSupportUpperBoundInclusive ( ) { <nl> - return true ; <nl> + return false ; <nl> } <nl> / * * <nl> 
1<ml>Time_12.src.patch<ml>Time_12.src.patch<ml>mmm a / src / main / java / org / joda / time / LocalDate . java <nl> ppp b / src / main / java / org / joda / time / LocalDate . java <nl> if ( calendar = = null ) { <nl> throw new IllegalArgumentException ( " The calendar must not be null " ) ; <nl> } <nl> - int era = calendar . get ( Calendar . ERA ) ; <nl> int yearOfEra = calendar . get ( Calendar . YEAR ) ; <nl> return new LocalDate ( <nl> - ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , <nl> + yearOfEra , <nl> calendar . get ( Calendar . MONTH ) + 1 , <nl> calendar . get ( Calendar . DAY_OF_MONTH ) <nl> ) ; <nl> if ( date = = null ) { <nl> throw new IllegalArgumentException ( " The date must not be null " ) ; <nl> } <nl> - if ( date . getTime ( ) < 0 ) { <nl> / / handle years in era BC <nl> - GregorianCalendar cal = new GregorianCalendar ( ) ; <nl> - cal . setTime ( date ) ; <nl> - return fromCalendarFields ( cal ) ; <nl> - } <nl> return new LocalDate ( <nl> date . getYear ( ) + 1900 , <nl> date . getMonth ( ) + 1 , <nl> mmm a / src / main / java / org / joda / time / LocalDateTime . java <nl> ppp b / src / main / java / org / joda / time / LocalDateTime . java <nl> if ( calendar = = null ) { <nl> throw new IllegalArgumentException ( " The calendar must not be null " ) ; <nl> } <nl> - int era = calendar . get ( Calendar . ERA ) ; <nl> int yearOfEra = calendar . get ( Calendar . YEAR ) ; <nl> return new LocalDateTime ( <nl> - ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , <nl> + yearOfEra , <nl> calendar . get ( Calendar . MONTH ) + 1 , <nl> calendar . get ( Calendar . DAY_OF_MONTH ) , <nl> calendar . get ( Calendar . HOUR_OF_DAY ) , <nl> if ( date = = null ) { <nl> throw new IllegalArgumentException ( " The date must not be null " ) ; <nl> } <nl> - if ( date . getTime ( ) < 0 ) { <nl> / / handle years in era BC <nl> - GregorianCalendar cal = new GregorianCalendar ( ) ; <nl> - cal . setTime ( date ) ; <nl> - return fromCalendarFields ( cal ) ; <nl> - } <nl> return new LocalDateTime ( <nl> date . getYear ( ) + 1900 , <nl> date . getMonth ( ) + 1 , <nl> 
1<ml>Time_27.src.patch<ml>Time_27.src.patch<ml>mmm a / src / main / java / org / joda / time / format / PeriodFormatterBuilder . java <nl> ppp b / src / main / java / org / joda / time / format / PeriodFormatterBuilder . java <nl> int size = elementPairs . size ( ) ; <nl> if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { <nl> Separator sep = ( Separator ) elementPairs . get ( 0 ) ; <nl> - if ( sep . iAfterParser = = null & & sep . iAfterPrinter = = null ) { <nl> PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; <nl> sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; <nl> return new PeriodFormatter ( sep , sep ) ; <nl> - } <nl> } <nl> Object [ ] comp = createComposite ( elementPairs ) ; <nl> if ( notPrinter ) { <nl> 
1<ml>Time_6.src.patch<ml>Time_6.src.patch<ml>mmm a / src / main / java / org / joda / time / chrono / GJChronology . java <nl> ppp b / src / main / java / org / joda / time / chrono / GJChronology . java <nl> cutoverInstant = DEFAULT_CUTOVER ; <nl> } else { <nl> cutoverInstant = gregorianCutover . toInstant ( ) ; <nl> - LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis ( ) , GregorianChronology . getInstance ( zone ) ) ; <nl> - if ( cutoverDate . getYear ( ) < = 0 ) { <nl> - throw new IllegalArgumentException ( " Cutover too early . Must be on or after 0001 - 01 - 01 . " ) ; <nl> - } <nl> } <nl> GJChronology chrono ; <nl> if ( instant < iCutover ) { <nl> / / Only adjust if gap fully crossed . <nl> if ( instant + iGapDuration < iCutover ) { <nl> - if ( iConvertByWeekyear ) { <nl> - int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; <nl> - if ( wyear < = 0 ) { <nl> - instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; <nl> - } <nl> - } else { <nl> - int year = iGregorianChronology . year ( ) . get ( instant ) ; <nl> - if ( year < = 0 ) { <nl> - instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; <nl> - } <nl> - } <nl> instant = gregorianToJulian ( instant ) ; <nl> } <nl> } <nl> if ( instant < iCutover ) { <nl> / / Only adjust if gap fully crossed . <nl> if ( instant + iGapDuration < iCutover ) { <nl> - if ( iConvertByWeekyear ) { <nl> - int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; <nl> - if ( wyear < = 0 ) { <nl> - instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; <nl> - } <nl> - } else { <nl> - int year = iGregorianChronology . year ( ) . get ( instant ) ; <nl> - if ( year < = 0 ) { <nl> - instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; <nl> - } <nl> - } <nl> instant = gregorianToJulian ( instant ) ; <nl> } <nl> } <nl> 
1<ml>Time_21.src.patch<ml>Time_21.src.patch<ml>mmm a / src / main / java / org / joda / time / tz / DefaultNameProvider . java <nl> ppp b / src / main / java / org / joda / time / tz / DefaultNameProvider . java <nl> if ( byNameKeyCache = = null ) { <nl> byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; <nl> - String [ ] [ ] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings ( ) ; <nl> - String [ ] setEn = null ; <nl> - for ( String [ ] strings : zoneStringsEn ) { <nl> - if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { <nl> - setEn = strings ; <nl> - break ; <nl> - } <nl> - } <nl> String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; <nl> String [ ] setLoc = null ; <nl> for ( String [ ] strings : zoneStringsLoc ) { <nl> if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { <nl> setLoc = strings ; <nl> - break ; <nl> - } <nl> - } <nl> - if ( setEn ! = null & & setLoc ! = null ) { <nl> - byNameKeyCache . put ( setEn [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; <nl> + byNameKeyCache . put ( setLoc [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; <nl> / / need to handle case where summer and winter have the same <nl> / / abbreviation , such as EST in Australia [ 1716305 ] <nl> / / we handle this by appending " - Summer " , cf ZoneInfoCompiler <nl> - if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { <nl> - byNameKeyCache . put ( setEn [ 4 ] + " - Summer " , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; <nl> + if ( setLoc [ 2 ] . equals ( setLoc [ 4 ] ) ) { <nl> + byNameKeyCache . put ( setLoc [ 4 ] + " - Summer " , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; <nl> } else { <nl> - byNameKeyCache . put ( setEn [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; <nl> + byNameKeyCache . put ( setLoc [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; <nl> + } <nl> + break ; <nl> } <nl> } <nl> } <nl> 
1<ml>Time_14.src.patch<ml>Time_14.src.patch<ml>mmm a / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java <nl> ppp b / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java <nl> if ( valueToAdd = = 0 ) { <nl> return values ; <nl> } <nl> - if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { <nl> / / month is largest field and being added to , such as month - day <nl> - int curMonth0 = partial . getValue ( 0 ) - 1 ; <nl> - int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; <nl> - return set ( partial , 0 , values , newMonth ) ; <nl> - } <nl> if ( DateTimeUtils . isContiguous ( partial ) ) { <nl> long instant = 0L ; <nl> for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { <nl> 
1<ml>Time_1.src.patch<ml>Time_1.src.patch<ml>mmm a / src / main / java / org / joda / time / Partial . java <nl> ppp b / src / main / java / org / joda / time / Partial . java <nl> DateTimeFieldType loopType = types [ i ] ; <nl> DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; <nl> if ( i > 0 ) { <nl> - if ( loopUnitField . isSupported ( ) = = false ) { <nl> - if ( lastUnitField . isSupported ( ) ) { <nl> - throw new IllegalArgumentException ( " Types array must be in order largest - smallest : " + <nl> - types [ i - 1 ] . getName ( ) + " < " + loopType . getName ( ) ) ; <nl> - } else { <nl> - throw new IllegalArgumentException ( " Types array must not contain duplicate unsupported : " + <nl> - types [ i - 1 ] . getName ( ) + " and " + loopType . getName ( ) ) ; <nl> - } <nl> - } <nl> int compare = lastUnitField . compareTo ( loopUnitField ) ; <nl> if ( compare < 0 ) { <nl> throw new IllegalArgumentException ( " Types array must be in order largest - smallest : " + <nl> types [ i - 1 ] . getName ( ) + " < " + loopType . getName ( ) ) ; <nl> - } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { <nl> + } else if ( compare = = 0 ) { <nl> if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { <nl> if ( loopType . getRangeDurationType ( ) = = null ) { <nl> throw new IllegalArgumentException ( " Types array must not contain duplicate : " + <nl> mmm a / src / main / java / org / joda / time / field / UnsupportedDurationField . java <nl> ppp b / src / main / java / org / joda / time / field / UnsupportedDurationField . java <nl> * @ return zero always <nl> * / <nl> public int compareTo ( DurationField durationField ) { <nl> + if ( durationField . isSupported ( ) ) { <nl> + return 1 ; <nl> + } <nl> return 0 ; <nl> } <nl> 
1<ml>Time_13.src.patch<ml>Time_13.src.patch<ml>mmm a / src / main / java / org / joda / time / format / PeriodFormatterBuilder . java <nl> ppp b / src / main / java / org / joda / time / format / PeriodFormatterBuilder . java <nl> if ( iFieldType > = SECONDS_MILLIS ) { <nl> / / valueLong contains the seconds and millis fields <nl> / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative <nl> - sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; <nl> + sum = Math . max ( sum , 4 ) ; <nl> / / plus one for the decimal point <nl> sum + + ; <nl> if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & <nl> if ( iPrefix ! = null ) { <nl> iPrefix . printTo ( buf , value ) ; <nl> } <nl> - int bufLen = buf . length ( ) ; <nl> int minDigits = iMinPrintedDigits ; <nl> if ( minDigits < = 1 ) { <nl> FormatUtils . appendUnpaddedInteger ( buf , value ) ; <nl> if ( iFieldType > = SECONDS_MILLIS ) { <nl> int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; <nl> if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { <nl> - if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { <nl> - buf . insert ( bufLen , ' - ' ) ; <nl> - } <nl> buf . append ( ' . ' ) ; <nl> FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; <nl> } <nl> 
1<ml>Time_26.src.patch<ml>Time_26.src.patch<ml>mmm a / src / main / java / org / joda / time / chrono / ZonedChronology . java <nl> ppp b / src / main / java / org / joda / time / chrono / ZonedChronology . java <nl> } else { <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . add ( localInstant , value ) ; <nl> - return iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + return iZone . convertLocalToUTC ( localInstant , false ) ; <nl> } <nl> } <nl> } else { <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . add ( localInstant , value ) ; <nl> - return iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + return iZone . convertLocalToUTC ( localInstant , false ) ; <nl> } <nl> } <nl> } else { <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . addWrapField ( localInstant , value ) ; <nl> - return iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + return iZone . convertLocalToUTC ( localInstant , false ) ; <nl> } <nl> } <nl> public long set ( long instant , int value ) { <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . set ( localInstant , value ) ; <nl> - long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + long result = iZone . convertLocalToUTC ( localInstant , false ) ; <nl> if ( get ( result ) ! = value ) { <nl> throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , <nl> " Illegal instant due to time zone offset transition : " + <nl> / / cannot verify that new value stuck because set may be lenient <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . set ( localInstant , text , locale ) ; <nl> - return iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + return iZone . convertLocalToUTC ( localInstant , false ) ; <nl> } <nl> public int getDifference ( long minuendInstant , long subtrahendInstant ) { <nl> } else { <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . roundFloor ( localInstant ) ; <nl> - return iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + return iZone . convertLocalToUTC ( localInstant , false ) ; <nl> } <nl> } <nl> } else { <nl> long localInstant = iZone . convertUTCToLocal ( instant ) ; <nl> localInstant = iField . roundCeiling ( localInstant ) ; <nl> - return iZone . convertLocalToUTC ( localInstant , false , instant ) ; <nl> + return iZone . convertLocalToUTC ( localInstant , false ) ; <nl> } <nl> } <nl> 
1<ml>Time_7.src.patch<ml>Time_7.src.patch<ml>mmm a / src / main / java / org / joda / time / format / DateTimeFormatter . java <nl> ppp b / src / main / java / org / joda / time / format / DateTimeFormatter . java <nl> long instantMillis = instant . getMillis ( ) ; <nl> Chronology chrono = instant . getChronology ( ) ; <nl> - int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; <nl> long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; <nl> chrono = selectChronology ( chrono ) ; <nl> + int defaultYear = chrono . year ( ) . get ( instantLocal ) ; <nl> DateTimeParserBucket bucket = new DateTimeParserBucket ( <nl> instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ; <nl> 
1<ml>Time_18.src.patch<ml>Time_18.src.patch<ml>mmm a / src / main / java / org / joda / time / chrono / GJChronology . java <nl> ppp b / src / main / java / org / joda / time / chrono / GJChronology . java <nl> / / Assume date is Gregorian . <nl> long instant ; <nl> - try { <nl> instant = iGregorianChronology . getDateTimeMillis <nl> ( year , monthOfYear , dayOfMonth , <nl> hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; <nl> - } catch ( IllegalFieldValueException ex ) { <nl> - if ( monthOfYear ! = 2 | | dayOfMonth ! = 29 ) { <nl> - throw ex ; <nl> - } <nl> - instant = iGregorianChronology . getDateTimeMillis <nl> - ( year , monthOfYear , 28 , <nl> - hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; <nl> - if ( instant > = iCutoverMillis ) { <nl> - throw ex ; <nl> - } <nl> - } <nl> if ( instant < iCutoverMillis ) { <nl> / / Maybe it ' s Julian . <nl> instant = iJulianChronology . getDateTimeMillis <nl> 
1<ml>Time_20.src.patch<ml>Time_20.src.patch<ml>mmm a / src / main / java / org / joda / time / format / DateTimeFormatterBuilder . java <nl> ppp b / src / main / java / org / joda / time / format / DateTimeFormatterBuilder . java <nl> public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { <nl> String str = text . substring ( position ) ; <nl> - String best = null ; <nl> for ( String id : ALL_IDS ) { <nl> if ( str . startsWith ( id ) ) { <nl> - if ( best = = null | | id . length ( ) > best . length ( ) ) { <nl> - best = id ; <nl> - } <nl> + bucket . setZone ( DateTimeZone . forID ( id ) ) ; <nl> + return position + id . length ( ) ; <nl> } <nl> } <nl> - if ( best ! = null ) { <nl> - bucket . setZone ( DateTimeZone . forID ( best ) ) ; <nl> - return position + best . length ( ) ; <nl> - } <nl> return ~ position ; <nl> } <nl> } <nl> 
1<ml>Time_15.src.patch<ml>Time_15.src.patch<ml>mmm a / src / main / java / org / joda / time / field / FieldUtils . java <nl> ppp b / src / main / java / org / joda / time / field / FieldUtils . java <nl> public static long safeMultiply ( long val1 , int val2 ) { <nl> switch ( val2 ) { <nl> case - 1 : <nl> - if ( val1 = = Long . MIN_VALUE ) { <nl> - throw new ArithmeticException ( " Multiplication overflows a long : " + val1 + " * " + val2 ) ; <nl> - } <nl> return - val1 ; <nl> case 0 : <nl> return 0L ; <nl> 
1<ml>Time_2.src.patch<ml>Time_2.src.patch<ml>mmm a / src / main / java / org / joda / time / Partial . java <nl> ppp b / src / main / java / org / joda / time / Partial . java <nl> DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; <nl> if ( i > 0 ) { <nl> int compare = lastUnitField . compareTo ( loopUnitField ) ; <nl> - if ( compare < 0 ) { <nl> + if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { <nl> throw new IllegalArgumentException ( " Types array must be in order largest - smallest : " + <nl> types [ i - 1 ] . getName ( ) + " < " + loopType . getName ( ) ) ; <nl> } else if ( compare = = 0 ) { <nl> if ( compare > 0 ) { <nl> break ; <nl> } else if ( compare = = 0 ) { <nl> - if ( fieldType . getRangeDurationType ( ) = = null ) { <nl> - break ; <nl> - } <nl> DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; <nl> DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; <nl> if ( rangeField . compareTo ( loopRangeField ) > 0 ) { <nl> mmm a / src / main / java / org / joda / time / field / UnsupportedDurationField . java <nl> ppp b / src / main / java / org / joda / time / field / UnsupportedDurationField . java <nl> * @ return zero always <nl> * / <nl> public int compareTo ( DurationField durationField ) { <nl> - if ( durationField . isSupported ( ) ) { <nl> - return 1 ; <nl> - } <nl> return 0 ; <nl> } <nl> 
1<ml>Time_25.src.patch<ml>Time_25.src.patch<ml>mmm a / src / main / java / org / joda / time / DateTimeZone . java <nl> ppp b / src / main / java / org / joda / time / DateTimeZone . java <nl> return offsetLocal ; <nl> } <nl> } <nl> - } else if ( offsetLocal > 0 ) { <nl> - long prev = previousTransition ( instantAdjusted ) ; <nl> - if ( prev < instantAdjusted ) { <nl> - int offsetPrev = getOffset ( prev ) ; <nl> - int diff = offsetPrev - offsetLocal ; <nl> - if ( instantAdjusted - prev < = diff ) { <nl> - return offsetPrev ; <nl> - } <nl> - } <nl> } <nl> return offsetAdjusted ; <nl> } <nl> 
1<ml>Time_10.src.patch<ml>Time_10.src.patch<ml>mmm a / src / main / java / org / joda / time / base / BaseSingleFieldPeriod . java <nl> ppp b / src / main / java / org / joda / time / base / BaseSingleFieldPeriod . java <nl> / * * Serialization version . * / <nl> private static final long serialVersionUID = 9386874258972L ; <nl> / * * The start of 1972 . * / <nl> - private static final long START_1972 = 2L * 365L * 86400L * 1000L ; <nl> / * * The period in the units of this period . * / <nl> private volatile int iPeriod ; <nl> throw new IllegalArgumentException ( " ReadablePartial objects must be contiguous " ) ; <nl> } <nl> Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; <nl> - int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; <nl> + int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; <nl> return values [ 0 ] ; <nl> } <nl> 
1<ml>Time_4.src.patch<ml>Time_4.src.patch<ml>mmm a / src / main / java / org / joda / time / Partial . java <nl> ppp b / src / main / java / org / joda / time / Partial . java <nl> System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; <nl> / / use public constructor to ensure full validation <nl> / / this isn ' t overly efficient , but is safe <nl> - Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; <nl> + Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; <nl> iChronology . validate ( newPartial , newValues ) ; <nl> return newPartial ; <nl> } <nl> 
1<ml>Time_16.src.patch<ml>Time_16.src.patch<ml>mmm a / src / main / java / org / joda / time / format / DateTimeFormatter . java <nl> ppp b / src / main / java / org / joda / time / format / DateTimeFormatter . java <nl> chrono = selectChronology ( chrono ) ; <nl> DateTimeParserBucket bucket = new DateTimeParserBucket ( <nl> - instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; <nl> + instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; <nl> int newPos = parser . parseInto ( bucket , text , position ) ; <nl> instant . setMillis ( bucket . computeMillis ( false , text ) ) ; <nl> if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) { <nl> 
1<ml>Time_9.src.patch<ml>Time_9.src.patch<ml>mmm a / src / main / java / org / joda / time / DateTimeZone . java <nl> ppp b / src / main / java / org / joda / time / DateTimeZone . java <nl> if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { <nl> return DateTimeZone . UTC ; <nl> } <nl> - if ( hoursOffset < - 23 | | hoursOffset > 23 ) { <nl> - throw new IllegalArgumentException ( " Hours out of range : " + hoursOffset ) ; <nl> - } <nl> if ( minutesOffset < 0 | | minutesOffset > 59 ) { <nl> throw new IllegalArgumentException ( " Minutes out of range : " + minutesOffset ) ; <nl> } <nl> int offset = 0 ; <nl> try { <nl> - int hoursInMinutes = hoursOffset * 60 ; <nl> + int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; <nl> if ( hoursInMinutes < 0 ) { <nl> - minutesOffset = hoursInMinutes - minutesOffset ; <nl> + minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; <nl> } else { <nl> - minutesOffset = hoursInMinutes + minutesOffset ; <nl> + minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; <nl> } <nl> offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; <nl> } catch ( ArithmeticException ex ) { <nl> * @ return the DateTimeZone object for the offset <nl> * / <nl> public static DateTimeZone forOffsetMillis ( int millisOffset ) { <nl> - if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { <nl> - throw new IllegalArgumentException ( " Millis out of range : " + millisOffset ) ; <nl> - } <nl> String id = printOffset ( millisOffset ) ; <nl> return fixedOffsetZone ( id , millisOffset ) ; <nl> } <nl> 
1<ml>Time_23.src.patch<ml>Time_23.src.patch<ml>mmm a / src / main / java / org / joda / time / DateTimeZone . java <nl> ppp b / src / main / java / org / joda / time / DateTimeZone . java <nl> / / Backwards compatibility with TimeZone . <nl> map = new HashMap < String , String > ( ) ; <nl> map . put ( " GMT " , " UTC " ) ; <nl> - map . put ( " WET " , " WET " ) ; <nl> - map . put ( " CET " , " CET " ) ; <nl> - map . put ( " MET " , " CET " ) ; <nl> - map . put ( " ECT " , " CET " ) ; <nl> - map . put ( " EET " , " EET " ) ; <nl> map . put ( " MIT " , " Pacific / Apia " ) ; <nl> map . put ( " HST " , " Pacific / Honolulu " ) ; / / JDK 1 . 1 compatible <nl> map . put ( " AST " , " America / Anchorage " ) ; <nl> map . put ( " PNT " , " America / Phoenix " ) ; <nl> map . put ( " CST " , " America / Chicago " ) ; <nl> map . put ( " EST " , " America / New_York " ) ; / / JDK 1 . 1 compatible <nl> - map . put ( " IET " , " America / Indiana / Indianapolis " ) ; <nl> + map . put ( " IET " , " America / Indianapolis " ) ; <nl> map . put ( " PRT " , " America / Puerto_Rico " ) ; <nl> map . put ( " CNT " , " America / St_Johns " ) ; <nl> - map . put ( " AGT " , " America / Argentina / Buenos_Aires " ) ; <nl> + map . put ( " AGT " , " America / Buenos_Aires " ) ; <nl> map . put ( " BET " , " America / Sao_Paulo " ) ; <nl> + map . put ( " WET " , " Europe / London " ) ; <nl> + map . put ( " ECT " , " Europe / Paris " ) ; <nl> map . put ( " ART " , " Africa / Cairo " ) ; <nl> map . put ( " CAT " , " Africa / Harare " ) ; <nl> + map . put ( " EET " , " Europe / Bucharest " ) ; <nl> map . put ( " EAT " , " Africa / Addis_Ababa " ) ; <nl> + map . put ( " MET " , " Asia / Tehran " ) ; <nl> map . put ( " NET " , " Asia / Yerevan " ) ; <nl> map . put ( " PLT " , " Asia / Karachi " ) ; <nl> - map . put ( " IST " , " Asia / Kolkata " ) ; <nl> + map . put ( " IST " , " Asia / Calcutta " ) ; <nl> map . put ( " BST " , " Asia / Dhaka " ) ; <nl> - map . put ( " VST " , " Asia / Ho_Chi_Minh " ) ; <nl> + map . put ( " VST " , " Asia / Saigon " ) ; <nl> map . put ( " CTT " , " Asia / Shanghai " ) ; <nl> map . put ( " JST " , " Asia / Tokyo " ) ; <nl> map . put ( " ACT " , " Australia / Darwin " ) ; <nl> 
1<ml>Time_3.src.patch<ml>Time_3.src.patch<ml>mmm a / src / main / java / org / joda / time / MutableDateTime . java <nl> ppp b / src / main / java / org / joda / time / MutableDateTime . java <nl> if ( type = = null ) { <nl> throw new IllegalArgumentException ( " Field must not be null " ) ; <nl> } <nl> - if ( amount ! = 0 ) { <nl> setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addYears ( final int years ) { <nl> - if ( years ! = 0 ) { <nl> setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addWeekyears ( final int weekyears ) { <nl> - if ( weekyears ! = 0 ) { <nl> setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addMonths ( final int months ) { <nl> - if ( months ! = 0 ) { <nl> setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addWeeks ( final int weeks ) { <nl> - if ( weeks ! = 0 ) { <nl> setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addDays ( final int days ) { <nl> - if ( days ! = 0 ) { <nl> setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addHours ( final int hours ) { <nl> - if ( hours ! = 0 ) { <nl> setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addMinutes ( final int minutes ) { <nl> - if ( minutes ! = 0 ) { <nl> setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addSeconds ( final int seconds ) { <nl> - if ( seconds ! = 0 ) { <nl> setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> * @ throws IllegalArgumentException if the value is invalid <nl> * / <nl> public void addMillis ( final int millis ) { <nl> - if ( millis ! = 0 ) { <nl> setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; <nl> - } <nl> } <nl> / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> 
1<ml>Time_24.src.patch<ml>Time_24.src.patch<ml>mmm a / src / main / java / org / joda / time / format / DateTimeParserBucket . java <nl> ppp b / src / main / java / org / joda / time / format / DateTimeParserBucket . java <nl> for ( int i = 0 ; i < count ; i + + ) { <nl> millis = savedFields [ i ] . set ( millis , resetFields ) ; <nl> } <nl> - if ( resetFields ) { <nl> - for ( int i = 0 ; i < count ; i + + ) { <nl> - millis = savedFields [ i ] . set ( millis , i = = ( count - 1 ) ) ; <nl> - } <nl> - } <nl> } catch ( IllegalFieldValueException e ) { <nl> if ( text ! = null ) { <nl> e . prependMessage ( " Cannot parse \ " " + text + ' " ' ) ; <nl> 
1<ml>Time_11.src.patch<ml>Time_11.src.patch<ml>mmm a / src / main / java / org / joda / time / tz / ZoneInfoCompiler . java <nl> ppp b / src / main / java / org / joda / time / tz / ZoneInfoCompiler . java <nl> static Chronology cLenientISO ; <nl> - static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) { <nl> - protected Boolean initialValue ( ) { <nl> - return Boolean . FALSE ; <nl> - } <nl> - } ; <nl> + static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) ; <nl> + static { <nl> + cVerbose . set ( Boolean . FALSE ) ; <nl> + } <nl> / * * <nl> * Gets a flag indicating that verbose logging is required . <nl> 
1<ml>Time_5.src.patch<ml>Time_5.src.patch<ml>mmm a / src / main / java / org / joda / time / Period . java <nl> ppp b / src / main / java / org / joda / time / Period . java <nl> int years = getYears ( ) ; <nl> int months = getMonths ( ) ; <nl> if ( years ! = 0 | | months ! = 0 ) { <nl> - long totalMonths = years * 12L + months ; <nl> - if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { <nl> - int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; <nl> - result = result . withYears ( normalizedYears ) ; <nl> - totalMonths = totalMonths - ( normalizedYears * 12 ) ; <nl> + years = FieldUtils . safeAdd ( years , months / 12 ) ; <nl> + months = months % 12 ; <nl> + if ( years ! = 0 ) { <nl> + result = result . withYears ( years ) ; <nl> } <nl> - if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { <nl> - int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; <nl> - result = result . withMonths ( normalizedMonths ) ; <nl> - totalMonths = totalMonths - normalizedMonths ; <nl> - } <nl> - if ( totalMonths ! = 0 ) { <nl> - throw new UnsupportedOperationException ( " Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : " + toString ( ) ) ; <nl> + if ( months ! = 0 ) { <nl> + result = result . withMonths ( months ) ; <nl> } <nl> } <nl> return result ; <nl> 
1<ml>Time_17.src.patch<ml>Time_17.src.patch<ml>mmm a / src / main / java / org / joda / time / DateTimeZone . java <nl> ppp b / src / main / java / org / joda / time / DateTimeZone . java <nl> / / a bit messy , but will work in all non - pathological cases <nl> / / evaluate 3 hours before and after to work out if anything is happening <nl> - long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; <nl> - long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; <nl> - long offsetBefore = getOffset ( instantBefore ) ; <nl> - long offsetAfter = getOffset ( instantAfter ) ; <nl> - if ( offsetBefore < = offsetAfter ) { <nl> + long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; <nl> + long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; <nl> + if ( instantBefore = = instantAfter ) { <nl> return instant ; / / not an overlap ( less than is a gap , equal is normal case ) <nl> } <nl> / / work out range of instants that have duplicate local times <nl> - long diff = offsetBefore - offsetAfter ; <nl> - long transition = nextTransition ( instantBefore ) ; <nl> - long overlapStart = transition - diff ; <nl> - long overlapEnd = transition + diff ; <nl> - if ( instant < overlapStart | | instant > = overlapEnd ) { <nl> - return instant ; / / not an overlap <nl> - } <nl> + long local = convertUTCToLocal ( instant ) ; <nl> + return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; <nl> / / calculate result <nl> - long afterStart = instant - overlapStart ; <nl> - if ( afterStart > = diff ) { <nl> / / currently in later offset <nl> - return earlierOrLater ? instant : instant - diff ; <nl> - } else { <nl> / / currently in earlier offset <nl> - return earlierOrLater ? instant + diff : instant ; <nl> - } <nl> } <nl> / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + " " + new DateTime ( transitionStart , this ) ) ; <nl> 
1<ml>Time_8.src.patch<ml>Time_8.src.patch<ml>mmm a / src / main / java / org / joda / time / DateTimeZone . java <nl> ppp b / src / main / java / org / joda / time / DateTimeZone . java <nl> if ( hoursOffset < - 23 | | hoursOffset > 23 ) { <nl> throw new IllegalArgumentException ( " Hours out of range : " + hoursOffset ) ; <nl> } <nl> - if ( minutesOffset < - 59 | | minutesOffset > 59 ) { <nl> + if ( minutesOffset < 0 | | minutesOffset > 59 ) { <nl> throw new IllegalArgumentException ( " Minutes out of range : " + minutesOffset ) ; <nl> } <nl> - if ( hoursOffset > 0 & & minutesOffset < 0 ) { <nl> - throw new IllegalArgumentException ( " Positive hours must not have negative minutes : " + minutesOffset ) ; <nl> - } <nl> int offset = 0 ; <nl> try { <nl> int hoursInMinutes = hoursOffset * 60 ; <nl> if ( hoursInMinutes < 0 ) { <nl> - minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; <nl> + minutesOffset = hoursInMinutes - minutesOffset ; <nl> } else { <nl> minutesOffset = hoursInMinutes + minutesOffset ; <nl> } <nl> 
1<ml>Time_22.src.patch<ml>Time_22.src.patch<ml>mmm a / src / main / java / org / joda / time / base / BasePeriod . java <nl> ppp b / src / main / java / org / joda / time / base / BasePeriod . java <nl> * @ param duration the duration , in milliseconds <nl> * / <nl> protected BasePeriod ( long duration ) { <nl> - super ( ) ; <nl> + this ( duration , null , null ) ; <nl> / / bug [ 3264409 ] <nl> - iType = PeriodType . time ( ) ; <nl> - int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; <nl> - iType = PeriodType . standard ( ) ; <nl> - iValues = new int [ 8 ] ; <nl> - System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; <nl> } <nl> / * * <nl> 
